<html><head><style id="sbt">
        .actionButton {
            margin-right:10px;
            padding: 10px 20px 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease;
        }
        .actionButton:hover {
            background-color: #1abc9c;
        }
		
		
    </style></head><body style="padding-left: 60px; padding-right: 60px; margin: 0px; font-family: Arial, sans-serif;"><div id="splashScreen" style="height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; background: linear-gradient(rgb(203, 229, 255), white); text-align: center;"><h1 style="font-size: 48px; color: rgb(11, 61, 145); margin: 0px;">GOLANG</h1><p style="font-size: 18px; color: rgb(85, 85, 85); margin: 10px 0px 30px;">Cборник задач</p><button id="startButton" style="font-size: 18px; padding: 15px 30px; background-color: rgb(11, 61, 145); color: white; border: none; border-radius: 8px; cursor: pointer; box-shadow: rgba(0, 0, 0, 0.1) 0px 4px 6px; transition: background-color 0.3s;">Начать учиться</button><p style="font-size: 14px; color: rgb(51, 51, 51); margin-top: 50px;">asbcorp24@gmail.com</p><script>
    window.onload = function() {
    // Получаем все элементы div
    const divs = document.querySelectorAll('div');

    // Проходим по каждому div
    divs.forEach(function(div) {
        // Если id элемента не равен "splashScreen", скрываем его
        if (div.id !== "splashScreen") {
            div.style.display = 'none';
        }
    });
};

	    const startButton = document.getElementById("startButton");
	   
	   startButton.addEventListener('mouseenter', () => {
            startButton.style.backgroundColor = '#094080';
        });

        startButton.addEventListener('mouseleave', () => {
            startButton.style.backgroundColor = '#0b3d91';
        });

        // Обработчик клика по кнопке
        startButton.addEventListener('click', () => {
              
             const divs2 = document.querySelectorAll('div');

    // Проходим по каждому div
    divs2.forEach(function(div) {
        // Устанавливаем отображение элемента
        div.style.display = 'block';  // или 'flex', 'inline', в зависимости от изначального стиля
    });
     const splashScreen = document.getElementById("splashScreen");
   splashScreen.style.display = 'none';
        });
        // Добавляем элементы на сплэш-скрин
       </script></div><div id="toc" class="toc"><h2>Содержание</h2><style>a {
    color: #3498db;
    text-decoration: none;
    font-weight: bold;
    transition: color 0.3s ease, border-bottom 0.3s ease;
    border-bottom: 2px solid transparent;
}

a:hover {
    color: #1abc9c;
    border-bottom: 2px solid #1abc9c;
}

/* Оглавление */
.toc {
    margin-top: 20px;
    list-style-type: none;
    counter-reset: toc-counter;
    padding-left: 1em;
}

.toc li {
    margin: 10px 0;
    font-size: 1em;
    display: flex;
    align-items: center;
    gap: 0.5em;
}

/* Нумерация с квадратиками */
.toc li::before {
    content: counter(toc-counter);
    counter-increment: toc-counter;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    width: 2em;
    height: 2em;
    color: white;
    font-size: 0.9em;
    border-radius: 4px;
}

/* Цвета для квадратиков */
.toc li:nth-child(6n+1)::before { background-color: #3498db; }
.toc li:nth-child(6n+2)::before { background-color: #1abc9c; }
.toc li:nth-child(6n+3)::before { background-color: #e74c3c; }
.toc li:nth-child(6n+4)::before { background-color: #f39c12; }
.toc li:nth-child(6n+5)::before { background-color: #9b59b6; }
.toc li:nth-child(6n+6)::before { background-color: #2ecc71; }

/* Заголовок оглавления */
h2 {
    font-size: 1.5em;
    color: #2c3e50;
    font-family: Arial, sans-serif;
    margin-bottom: 0.5em;
}

/* Стили для класса numbered */
.numbered {
    position: relative;
    padding-left: 1.5em;
}

.numbered::before {
    content: attr(data-id);
    display: inline-flex;
    justify-content: center;
    align-items: center;
    width: 2.5em;
    height: 2.5em;
    font-size: 1em;
    margin-right: 0.5em;
    color: white;
    background-color: var(--bg-color);
    border-radius: 10%;
}

/* Адаптивные стили */
@media (max-width: 768px) {
    .toc li {
        font-size: 1em;
    }
    .toc li::before, .numbered::before {
        width: 2em;
        height: 2em;
    }
}

@media (max-width: 480px) {
    .toc li {
        font-size: 0.9em;
    }
    .toc li::before, .numbered::before {
        width: 1.8em;
        height: 1.8em;
        font-size: 0.8em;
    }
}4
pre {
    white-space: pre-wrap; /* Разрешить перенос текста */
    word-wrap: break-word; /* Переносить длинные слова */
    font-size: 16px; /* Базовый размер шрифта */
    padding: 10px;
    border: 1px solid #ccc;
   
    overflow-x: auto; /* Добавить горизонтальную прокрутку при необходимости */
}

/* Меньший размер шрифта на маленьких экранах */
@media (max-width: 768px) {
    pre {
        font-size: 14px;
        padding: 8px;
    }
}

/* Ещё меньший размер на очень маленьких экранах */
@media (max-width: 480px) {
    pre {
        font-size: 12px;
        padding: 6px;
    }
}
.columns {
    column-count: 1; /* Базовое значение для мобильных */
    column-gap: 20px;
    padding: 10px;
    border: 1px solid #ccc;
    margin: 20px 0;
}

/* Для экранов шире 600px (планшеты) */
@media (min-width: 600px) {
    .columns {
        column-count: 2; /* Две колонки на планшетах */
    }
}

/* Для экранов шире 1024px (настольные компьютеры) */
@media (min-width: 1024px) {
    .columns {
        column-count: 3; /* Три колонки на больших экранах */
    }
} 
body {
    margin: 0;
    font-family: Arial, sans-serif;
    padding-left: 5vw; /* Процент ширины окна */
    padding-right: 5vw;
}

@media (min-width: 768px) { /* Планшеты и выше */
    body {
        padding-left: 40px;
        padding-right: 40px;
    }
}

@media (min-width: 1024px) { /* Десктопы и выше */
    body {
        padding-left: 60px;
        padding-right: 60px;
    }
}
    </style><ul class="toc columns"><li><a href="#heading-1">
ПЕРЕМЕННЫЕ</a></li><li><a href="#heading-2">
ТИПЫ ДАННЫХ</a></li><li><a href="#heading-3">
КОНСТАНТЫ</a></li><li><a href="#heading-4">
АРИФМЕТИЧЕСКИЕ ОПЕРАЦИИ</a></li><li><a href="#heading-5">
УСЛОВНЫЕ ВЫРАЖЕНИЯ</a></li><li><a href="#heading-6">
ПОРАЗРЯДНЫЕ ОПЕРАЦИИ</a></li><li><a href="#heading-7">
МАССИВЫ</a></li><li><a href="#heading-8">
УСЛОВНЫЕ КОНСТРУКЦИИ</a></li><li><a href="#heading-9">
ФУНКЦИИ</a></li><li><a href="#heading-10">
ЦИКЛЫ</a></li><li><a href="#heading-11">ФУНКЦИИ И ИХ ПАРАМЕТРЫ</a></li><li><a href="#heading-12">
ВОЗВРАЩЕНИЕ РЕЗУЛЬТАТА ИЗ ФУНКЦИИ</a></li><li><a href="#heading-13">АНОНИМНЫЕ ФУНКЦИИ</a></li><li><a href="#heading-14">
DEFER И PANIC</a></li><li><a href="#heading-15">СРЕЗЫ</a></li><li><a href="#heading-16">ОТОБРАЖЕНИЯ (КАРТЫ)</a></li><li><a href="#heading-17">
УКАЗАТЕЛИ</a></li><li><a href="#heading-18">УКАЗАТЕЛИ И ФУНКЦИИ</a></li><li><a href="#heading-19">ИМЕНОВАННЫЕ ТИПЫ И ПСЕВДОНИМЫ</a></li><li><a href="#heading-20">СТРУКТУРЫ</a></li><li><a href="#heading-21">ВЛОЖЕННЫЕ СТРУКТУРЫ</a></li><li><a href="#heading-22">МЕТОДЫ</a></li><li><a href="#heading-23">ПАКЕТЫ И ИХ ИМПОРТ</a></li><li><a href="#heading-24">ВВЕДЕНИЕ В МОДУЛИ</a></li><li><a href="#heading-25">ВВЕДЕНИЕ В ИНТЕРФЕЙСЫ</a></li><li><a href="#heading-26">СООТВЕТСТВИЕ ИНТЕРФЕЙСУ</a></li><li><a href="#heading-27">ПОЛИМОРФИЗМ</a></li><li><a href="#heading-28">РЕФЛЕКСИЯ</a></li><li><a href="#heading-29">ГОРУТИНЫ</a></li><li><a href="#heading-30"></a></li><li><a href="#heading-31">КАНАЛЫ</a></li><li><a href="#heading-32">ЗАКРЫТИЕ КАНАЛА</a></li><li><a href="#heading-33">СИНХРОНИЗАЦИЯ</a></li><li><a href="#heading-34">МЬЮТЕКСЫ</a></li><li><a href="#heading-35">WAITGROUP</a></li><li><a href="#heading-36">READER И WRITER</a></li><li><a href="#heading-37">СОЗДАНИЕ И ОТКРЫТИЕ ФАЙЛОВ</a></li><li><a href="#heading-38">
ОТПРАВКА ЗАПРОСОВ</a></li><li><a href="#heading-39">
СЕРВЕР. ОБРАБОТКА ПОДКЛЮЧЕНИЙ</a></li><li><a href="#heading-40">
ВЗАИМОДЕЙСТВИЕ КЛИЕНТА И СЕРВЕРА</a></li><li><a href="#heading-41">
УСТАНОВКА ТАЙМАУТА</a></li><li><a href="#heading-42">
СЕТЕВОЕ ПРОГРАММИРОВАНИЕ</a></li><li><a href="#heading-43">
ОТПРАВКА ЗАПРОСОВ</a></li><li><a href="#heading-44">
СЕРВЕР. ОБРАБОТКА ПОДКЛЮЧЕНИЙ</a></li><li><a href="#heading-45">
ВЗАИМОДЕЙСТВИЕ КЛИЕНТА И СЕРВЕРА</a></li><li><a href="#heading-46">
MYSQL</a></li><li><a href="#heading-47">
MONGODB</a></li><li><a href="#heading-48">
ФУНКЦИЯ HANDLEFUNC</a></li><li><a href="#heading-49">
ФУНКЦИЯ HANDLE</a></li><li><a href="#heading-50">
ФУНКЦИЯ HANDLEFUNC</a></li><li><a href="#heading-51">
ФУНКЦИЯ HANDLE</a></li><li><a href="#heading-52">GORILLA/MUX,</a></li><li><a href="#heading-53">
ОТПРАВКА ФОРМ
</a></li><li><a href="#heading-54">ОПРЕДЕЛЕНИЕ И ИСПОЛЬЗОВАНИЕ ШАБЛОНОВ МАРШРУТОВ В GO С ИСПОЛЬЗОВАНИЕМ GORILLA/MUX</a></li><li><a href="#heading-55">СИНТАКСИС ШАБЛОНОВ, ЦИКЛЫ И УСЛОВНЫЕ КОНСТРУКЦИИ В GO</a></li></ul></div><div><article dir="auto"><h5></h5></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><h3> </h3><h1 id="heading-1" class="numbered" data-id="1" style="--bg-color: undefined;">
ПЕРЕМЕННЫЕ</h1><h4>Базовые задачи</h4><ol><li><p><strong>Объявление и инициализация переменной</strong></p><ul><li>Задача: Объявите переменную <code>age</code>, присвойте ей значение 25 и выведите на экран.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    age := <span>25</span>
    fmt.Println(<span>"Age:"</span>, age) <span>// Вывод: Age: 25</span>
}
</code></div></div></pre></li><li>Комментарий: Используем оператор <code>:=</code> для объявления и инициализации переменной.</li></ul></li><li><p><strong>Переменные разных типов</strong></p><ul><li>Задача: Объявите переменные для имени (строка), возраста (целое число) и росте (число с плавающей точкой).</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    name := <span>"Alice"</span>
    age := <span>30</span>
    height := <span>1.65</span>
    fmt.Println(name, age, height) <span>// Вывод: Alice 30 1.65</span>
}
</code></div></div></pre></li><li>Комментарий: Go является статически типизированным языком, поэтому типы переменных определяются на этапе компиляции.</li></ul></li><li><p><strong>Изменение значений переменных</strong></p><ul><li>Задача: Обновите значение переменной <code>age</code> на 26 и выведите новое значение.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    age := <span>25</span>
    age = <span>26</span>
    fmt.Println(<span>"Updated Age:"</span>, age) <span>// Вывод: Updated Age: 26</span>
}
</code></div></div></pre></li><li>Комментарий: Переменные можно обновлять в процессе выполнения программы.</li></ul></li><li><p><strong>Групповая инициализация переменных</strong></p><ul><li>Задача: Инициализируйте несколько переменных одной строкой.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> ( 
        name  = <span>"Bob"</span>
        age   = <span>22</span>
        score = <span>88.5</span>
    )
    fmt.Println(name, age, score) <span>// Вывод: Bob 22 88.5</span>
}
</code></div></div></pre></li><li>Комментарий: Групповая инициализация позволяет структурировать код и уменьшить его объем.</li></ul></li><li><p><strong>Переменные в функции</strong></p><ul><li>Задача: Создайте функцию, принимающую имя и возраст, и выводящую их.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>printInfo</span><span>(name <span>string</span>, age <span>int</span>)</span></span> {
    fmt.Println(name, <span>"is"</span>, age, <span>"years old"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    printInfo(<span>"Charlie"</span>, <span>28</span>) <span>// Вывод: Charlie is 28 years old</span>
}
</code></div></div></pre></li><li>Комментарий: Функции позволяют структурировать код и использовать переменные многократно.</li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Объявление переменных с использованием указателей</strong></p><ul><li>Задача: Используйте указатели для изменения значения переменной.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>changeAge</span><span>(age *<span>int</span>)</span></span> {
    *age = <span>30</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    age := <span>25</span>
    changeAge(&amp;age)
    fmt.Println(<span>"Changed Age:"</span>, age) <span>// Вывод: Changed Age: 30</span>
}
</code></div></div></pre></li><li>Комментарий: Указатели позволяют передавать адрес переменной, чтобы изменять её значение внутри функции.</li></ul></li><li><p><strong>Переменные в структуре</strong></p><ul><li>Задача: Создайте структуру <code>Person</code> с переменными <code>name</code> и <code>age</code>, и создайте экземпляр этой структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Person <span>struct</span> {
    name <span>string</span>
    age  <span>int</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := Person{name: <span>"David"</span>, age: <span>34</span>}
    fmt.Println(p.name, <span>"is"</span>, p.age, <span>"years old"</span>) <span>// Вывод: David is 34 years old</span>
}
</code></div></div></pre></li><li>Комментарий: Структуры позволяют объединять связанные переменные в единую сущность.</li></ul></li><li><p><strong>Константы и переменные</strong></p><ul><li>Задача: Используйте константы и переменные для хранения значений.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>const</span> Pi = <span>3.14</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> radius <span>float64</span> = <span>5</span>
    area := Pi * radius * radius
    fmt.Println(<span>"Area of circle:"</span>, area) <span>// Вывод: Area of circle: 78.5</span>
}
</code></div></div></pre></li><li>Комментарий: Константы позволяют хранить неизменяемые значения, такие как математические константы.</li></ul></li><li><p><strong>Переменные окружения</strong></p><ul><li>Задача: Получите значение переменной окружения и выведите её.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    path := os.Getenv(<span>"PATH"</span>)
    fmt.Println(<span>"PATH:"</span>, path) <span>// Выводит значение переменной окружения PATH</span>
}
</code></div></div></pre></li><li>Комментарий: Переменные окружения полезны для конфигурации приложений.</li></ul></li><li><p><strong>Глобальные переменные</strong></p><ul><li>Задача: Используйте глобальную переменную в нескольких функциях.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>var</span> globalAge <span>int</span> = <span>25</span>

<span><span>func</span> <span>increaseAge</span><span>()</span></span> {
    globalAge++
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    increaseAge()
    fmt.Println(<span>"Global Age:"</span>, globalAge) <span>// Вывод: Global Age: 26</span>
}
</code></div></div></pre></li><li>Комментарий: Глобальные переменные доступны из любой функции, но следует использовать их с осторожностью.</li></ul></li></ol><h3>2. </h3><h1 id="heading-2" class="numbered" data-id="2" style="--bg-color: red;">
ТИПЫ ДАННЫХ</h1><h4>Базовые задачи</h4><ol><li><p><strong>Типы данных</strong></p><ul><li>Задача: Определите и выведите переменные разных типов данных.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> age <span>int</span> = <span>30</span>
    <span>var</span> height <span>float64</span> = <span>1.75</span>
    <span>var</span> name <span>string</span> = <span>"Eve"</span>
    <span>var</span> isStudent <span>bool</span> = <span>true</span>
    fmt.Println(age, height, name, isStudent) <span>// Вывод: 30 1.75 Eve true</span>
}
</code></div></div></pre></li><li>Комментарий: Go поддерживает несколько типов данных, включая целые числа, числа с плавающей точкой, строки и логические значения.</li></ul></li><li><p><strong>Строки</strong></p><ul><li>Задача: Объедините две строки и выведите результат.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    firstName := <span>"John"</span>
    lastName := <span>"Doe"</span>
    fullName := firstName + <span>" "</span> + lastName
    fmt.Println(<span>"Full Name:"</span>, fullName) <span>// Вывод: Full Name: John Doe</span>
}
</code></div></div></pre></li><li>Комментарий: Строки можно объединять с помощью оператора <code>+</code>.</li></ul></li><li><p><strong>Типы данных в массивах</strong></p><ul><li>Задача: Создайте массив и выведите его элементы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    numbers := [<span>5</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    <span>for</span> _, number := <span>range</span> numbers {
        fmt.Println(number) <span>// Вывод: 1 2 3 4 5</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Массивы хранят фиксированное количество элементов одного типа.</li></ul></li><li><p><strong>Срезы</strong></p><ul><li>Задача: Создайте срез, добавьте элементы и выведите его.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    fruits := []<span>string</span>{<span>"apple"</span>, <span>"banana"</span>}
    fruits = <span>append</span>(fruits, <span>"orange"</span>)
    fmt.Println(fruits) <span>// Вывод: [apple banana orange]</span>
}
</code></div></div></pre></li><li>Комментарий: Срезы представляют собой динамические массивы и позволяют добавлять элементы.</li></ul></li><li><p><strong>Словари</strong></p><ul><li>Задача: Создайте словарь с именами и возрастами и выведите его.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    ages := <span>map</span>[<span>string</span>]<span>int</span>{<span>"Alice"</span>: <span>25</span>, <span>"Bob"</span>: <span>30</span>}
    fmt.Println(ages) <span>// Вывод: map[Alice:25 Bob:30]</span>
}
</code></div></div></pre></li><li>Комментарий: Словари (или карты) позволяют хранить пары ключ-значение.</li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Тип данных структуры</strong></p><ul><li>Задача: Определите структуру <code>Book</code> и создайте экземпляр этой структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Book <span>struct</span> {
    title  <span>string</span>
    author <span>string</span>
    pages  <span>int</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    myBook := Book{<span>"The Go Programming Language"</span>, <span>"Alan A. A. Donovan"</span>, <span>380</span>}
    fmt.Println(myBook) <span>// Вывод: {The Go Programming Language Alan A. A. Donovan 380}</span>
}
</code></div></div></pre></li><li>Комментарий: Структуры позволяют создавать сложные типы данных, объединяющие несколько простых типов.</li></ul></li><li><p><strong>Использование интерфейсов</strong></p><ul><li>Задача: Создайте интерфейс <code>Shape</code> и реализации для него.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}

<span>type</span> Rectangle <span>struct</span> {
    width, height <span>float64</span>
}

<span><span>func</span> <span>(r Rectangle)</span></span> Area() <span>float64</span> {
    <span>return</span> r.width * r.height
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rect := Rectangle{width: <span>10</span>, height: <span>5</span>}
    fmt.Println(<span>"Area of rectangle:"</span>, rect.Area()) <span>// Вывод: Area of rectangle: 50</span>
}
</code></div></div></pre></li><li>Комментарий: Интерфейсы позволяют создавать абстракции и реализовывать полиморфизм.</li></ul></li><li><p><strong>Неопределённые типы</strong></p><ul><li>Задача: Используйте <code>interface{}</code> для создания функции, которая может принимать разные типы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>printValue</span><span>(value <span>interface</span>{})</span></span> {
    fmt.Println(<span>"Value:"</span>, value)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    printValue(<span>10</span>)        <span>// Вывод: Value: 10</span>
    printValue(<span>"Hello"</span>)   <span>// Вывод: Value: Hello</span>
    printValue(<span>3.14</span>)      <span>// Вывод: Value: 3.14</span>
}
</code></div></div></pre></li><li>Комментарий: <code>interface{}</code> позволяет функции принимать значения любого типа.</li></ul></li><li><p><strong>Пользовательские типы</strong></p><ul><li>Задача: Создайте пользовательский тип и используйте его.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Celsius <span>float64</span>

<span><span>func</span> <span>(c Celsius)</span></span> ToFahrenheit() <span>float64</span> {
    <span>return</span> <span>float64</span>(c)*<span>1.8</span> + <span>32</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> temp Celsius = <span>25</span>
    fmt.Println(temp.ToFahrenheit()) <span>// Вывод: 77</span>
}
</code></div></div></pre></li><li>Комментарий: Пользовательские типы позволяют добавлять методы к существующим типам.</li></ul></li><li><p><strong>Типы данных и их безопасность</strong></p><ul><li>Задача: Создайте функцию, которая принимает аргументы разного типа и возвращает ошибку для неподходящих типов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"errors"</span>
    <span>"fmt"</span>
)

<span><span>func</span> <span>process</span><span>(value <span>interface</span>{})</span></span> <span>error</span> {
    <span>if</span> _, ok := value.(<span>int</span>); !ok {
        <span>return</span> errors.New(<span>"value must be an integer"</span>)
    }
    <span>return</span> <span>nil</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>if</span> err := process(<span>"not an int"</span>); err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err) <span>// Вывод: Error: value must be an integer</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Проверка типов и обработка ошибок необходимы для обеспечения безопасности типов в Go.</li></ul></li></ol><h3>3. </h3><h1 id="heading-3" class="numbered" data-id="3" style="--bg-color: blue;">
КОНСТАНТЫ</h1><h4>Базовые задачи</h4><ol><li><p><strong>Объявление констант</strong></p><ul><li>Задача: Объявите константу <code>Pi</code> и выведите её.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>const</span> Pi = <span>3.14</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(<span>"Pi:"</span>, Pi) <span>// Вывод: Pi: 3.14</span>
}
</code></div></div></pre></li><li>Комментарий: Константы не могут быть изменены после их объявления.</li></ul></li><li><p><strong>Константы разных типов</strong></p><ul><li>Задача: Объявите константы для числа, строки и логического значения.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>const</span> (
    Name  = <span>"Alice"</span>
    Age   = <span>30</span>
    IsStudent = <span>false</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(Name, Age, IsStudent) <span>// Вывод: Alice 30 false</span>
}
</code></div></div></pre></li><li>Комментарий: Константы могут быть группированы для более удобного объявления.</li></ul></li><li><p><strong>Использование констант в арифметических операциях</strong></p><ul><li>Задача: Используйте константу в арифметической операции.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>const</span> Pi = <span>3.14</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    radius := <span>5.0</span>
    area := Pi * radius * radius
    fmt.Println(<span>"Area of circle:"</span>, area) <span>// Вывод: Area of circle: 78.5</span>
}
</code></div></div></pre></li><li>Комментарий: Константы могут быть использованы в вычислениях, что помогает избежать магических чисел в коде.</li></ul></li><li><p><strong>Константы для единиц измерения</strong></p><ul><li>Задача: Определите константы для единиц измерения и используйте их.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>const</span> (
    Meter   = <span>1.0</span>
    Kilometer = <span>1000.0</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    distance := <span>5</span> * Kilometer
    fmt.Println(<span>"Distance:"</span>, distance, <span>"meters"</span>) <span>// Вывод: Distance: 5000 meters</span>
}
</code></div></div></pre></li><li>Комментарий: Константы могут быть использованы для улучшения читабельности кода.</li></ul></li><li><p><strong>Константы с типом</strong></p><ul><li>Задача: Объявите константы с пользовательским типом.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Currency <span>string</span>

<span>const</span> (
    USD Currency = <span>"USD"</span>
    EUR Currency = <span>"EUR"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(<span>"Currency:"</span>, USD) <span>// Вывод: Currency: USD</span>
}
</code></div></div></pre></li><li>Комментарий: Константы с пользовательским типом помогают улучшить безопасность типов.</li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Константы и арифметические выражения</strong></p><ul><li>Задача: Объявите константы для математических операций и используйте их в вычислениях.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>const</span> (
    Width  = <span>10</span>
    Height = <span>5</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    area := Width * Height
    fmt.Println(<span>"Area:"</span>, area) <span>// Вывод: Area: 50</span>
}
</code></div></div></pre></li><li>Комментарий: Константы могут использоваться в выражениях, что помогает избежать ошибок при вводе значений.</li></ul></li><li><p><strong>Групповые константы</strong></p><ul><li>Задача: Используйте групповые константы для представления разных статусов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>const</span> (
    StatusPending   = <span>"Pending"</span>
    StatusCompleted = <span>"Completed"</span>
    StatusFailed    = <span>"Failed"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(<span>"Current status:"</span>, StatusPending) <span>// Вывод: Current status: Pending</span>
}
</code></div></div></pre></li><li>Комментарий: Группировка констант по смыслу облегчает управление ими.</li></ul></li><li><p><strong>Константы и параметры функции</strong></p><ul><li>Задача: Передайте константу в качестве параметра функции.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>const</span> Discount = <span>0.10</span>

<span><span>func</span> <span>calculatePrice</span><span>(price <span>float64</span>)</span></span> <span>float64</span> {
    <span>return</span> price * (<span>1</span> - Discount)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(<span>"Discounted Price:"</span>, calculatePrice(<span>100</span>)) <span>// Вывод: Discounted Price: 90</span>
}
</code></div></div></pre></li><li>Комментарий: Использование констант в функциях улучшает читабельность и избегает повторений.</li></ul></li><li><p><strong>Константы и ошибки</strong></p><ul><li>Задача: Используйте константы для представления кодов ошибок.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"errors"</span>
    <span>"fmt"</span>
)

<span>const</span> (
    ErrNotFound = <span>"Not Found"</span>
    ErrInvalid  = <span>"Invalid Input"</span>
)

<span><span>func</span> <span>validateInput</span><span>(input <span>int</span>)</span></span> <span>error</span> {
    <span>if</span> input &lt; <span>0</span> {
        <span>return</span> errors.New(ErrInvalid)
    }
    <span>return</span> <span>nil</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>if</span> err := validateInput(<span>-1</span>); err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err) <span>// Вывод: Error: Invalid Input</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Константы для кодов ошибок помогают стандартизировать обработку ошибок.</li></ul></li><li><p><strong>Константы и флаги</strong></p><ul><li>Задача: Используйте константы для определения режимов работы программы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>const</span> (
    ModeDebug   = <span>true</span>
    ModeRelease = <span>false</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>if</span> ModeDebug {
        fmt.Println(<span>"Running in debug mode"</span>) <span>// Вывод: Running in debug mode</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Константы для режимов работы помогают управлять поведением программы без необходимости изменять код.</li></ul></li></ol><h3>4.</h3><h1 id="heading-4" class="numbered" data-id="4" style="--bg-color: green;">
АРИФМЕТИЧЕСКИЕ ОПЕРАЦИИ</h1><h4>Базовые задачи</h4><ol><li><p><strong>Основные арифметические операции</strong></p><ul><li>Задача: Выполните базовые арифметические операции и выведите результаты.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b := <span>10</span>, <span>5</span>
    fmt.Println(<span>"Addition:"</span>, a+b)       <span>// Вывод: Addition: 15</span>
    fmt.Println(<span>"Subtraction:"</span>, a-b)    <span>// Вывод: Subtraction: 5</span>
    fmt.Println(<span>"Multiplication:"</span>, a*b)  <span>// Вывод: Multiplication: 50</span>
    fmt.Println(<span>"Division:"</span>, a/b)        <span>// Вывод: Division: 2</span>
}
</code></div></div></pre></li><li>Комментарий: Арифметические операции являются основными в большинстве приложений.</li></ul></li><li><p><strong>Остаток от деления</strong></p><ul><li>Задача: Найдите остаток от деления двух чисел.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b := <span>10</span>, <span>3</span>
    fmt.Println(<span>"Remainder:"</span>, a%b) <span>// Вывод: Remainder: 1</span>
}
</code></div></div></pre></li><li>Комментарий: Остаток от деления используется для проверки четности, делимости и других операций.</li></ul></li><li><p><strong>Инкремент и декремент</strong></p><ul><li>Задача: Увеличьте и уменьшите значение переменной.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    counter := <span>0</span>
    counter++ <span>// Инкремент</span>
    fmt.Println(<span>"Counter after increment:"</span>, counter) <span>// Вывод: Counter after increment: 1</span>
    counter-- <span>// Декремент</span>
    fmt.Println(<span>"Counter after decrement:"</span>, counter) <span>// Вывод: Counter after decrement: 0</span>
}
</code></div></div></pre></li><li>Комментарий: Инкремент и декремент позволяют изменять значения переменных компактным образом.</li></ul></li><li><p><strong>Порядок операций</strong></p><ul><li>Задача: Используйте скобки для определения порядка операций.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    result := (<span>2</span> + <span>3</span>) * <span>4</span>
    fmt.Println(<span>"Result:"</span>, result) <span>// Вывод: Result: 20</span>
}
</code></div></div></pre></li><li>Комментарий: Порядок операций важен для правильных вычислений.</li></ul></li><li><p><strong>Арифметические операции с плавающей точкой</strong></p><ul><li>Задача: Выполните арифметические операции с числами с плавающей точкой.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b := <span>5.0</span>, <span>2.0</span>
    fmt.Println(<span>"Addition:"</span>, a+b)       <span>// Вывод: Addition: 7</span>
    fmt.Println(<span>"Subtraction:"</span>, a-b)    <span>// Вывод: Subtraction: 3</span>
    fmt.Println(<span>"Multiplication:"</span>, a*b)  <span>// Вывод: Multiplication: 10</span>
    fmt.Println(<span>"Division:"</span>, a/b)        <span>// Вывод: Division: 2.5</span>
}
</code></div></div></pre></li><li>Комментарий: Арифметические операции с плавающей точкой позволяют работать с дробными числами.</li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Сложные арифметические выражения</strong></p><ul><li>Задача: Рассчитайте сложное арифметическое выражение.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b, c := <span>10</span>, <span>20</span>, <span>30</span>
    result := a + b*<span>2</span> - c/<span>3</span>
    fmt.Println(<span>"Complex Expression Result:"</span>, result) <span>// Вывод: Complex Expression Result: 39</span>
}
</code></div></div></pre></li><li>Комментарий: Сложные выражения требуют внимательного обращения с порядком операций.</li></ul></li><li><p><strong>Применение функции для арифметических операций</strong></p><ul><li>Задача: Создайте функцию для выполнения арифметических операций.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>calculate</span><span>(a <span>int</span>, b <span>int</span>, operation <span>string</span>)</span></span> <span>int</span> {
    <span>switch</span> operation {
    <span>case</span> <span>"add"</span>:
        <span>return</span> a + b
    <span>case</span> <span>"subtract"</span>:
        <span>return</span> a - b
    <span>case</span> <span>"multiply"</span>:
        <span>return</span> a * b
    <span>case</span> <span>"divide"</span>:
        <span>return</span> a / b
    <span>default</span>:
        <span>return</span> <span>0</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(<span>"Addition:"</span>, calculate(<span>10</span>, <span>5</span>, <span>"add"</span>)) <span>// Вывод: Addition: 15</span>
}
</code></div></div></pre></li><li>Комментарий: Функции позволяют инкапсулировать логику и повторно использовать её.</li></ul></li><li><p><strong>Сложение элементов массива</strong></p><ul><li>Задача: Найдите сумму элементов массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    numbers := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    sum := <span>0</span>
    <span>for</span> _, num := <span>range</span> numbers {
        sum += num
    }
    fmt.Println(<span>"Sum:"</span>, sum) <span>// Вывод: Sum: 15</span>
}
</code></div></div></pre></li><li>Комментарий: Суммирование элементов массива часто используется в статистических расчетах.</li></ul></li><li><p><strong>Среднее значение</strong></p><ul><li>Задача: Рассчитайте среднее значение массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    numbers := []<span>float64</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    sum := <span>0.0</span>
    <span>for</span> _, num := <span>range</span> numbers {
        sum += num
    }
    average := sum / <span>float64</span>(<span>len</span>(numbers))
    fmt.Println(<span>"Average:"</span>, average) <span>// Вывод: Average: 3</span>
}
</code></div></div></pre></li><li>Комментарий: Среднее значение используется в аналитике данных.</li></ul></li><li><p><strong>Применение математических функций</strong></p><ul><li>Задача: Используйте математические функции для вычислений.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"math"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    radius := <span>5.0</span>
    area := math.Pi * radius * radius
    fmt.Println(<span>"Area of Circle:"</span>, area) <span>// Вывод: Area of Circle: 78.53981633974483</span>
}
</code></div></div></pre></li><li>Комментарий: Математические функции из пакета <code>math</code> позволяют выполнять сложные вычисления.</li></ul></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h2>1. </h2><h1 id="heading-5" class="numbered" data-id="5" style="--bg-color: orange;">
УСЛОВНЫЕ ВЫРАЖЕНИЯ</h1><h3>Базовые задачи</h3><ol><li><p><strong>Проверка четности числа</strong></p><ul><li>Задача: Проверьте, является ли число четным или нечетным.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    number := <span>10</span>
    <span>if</span> number%<span>2</span> == <span>0</span> {
        fmt.Println(<span>"Число четное"</span>) <span>// Вывод: Число четное</span>
    } <span>else</span> {
        fmt.Println(<span>"Число нечетное"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Условные выражения позволяют выполнять код в зависимости от истинности условия.</li></ul></li><li><p><strong>Определение возраста</strong></p><ul><li>Задача: Определите, достиг ли человек совершеннолетия.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    age := <span>17</span>
    <span>if</span> age &gt;= <span>18</span> {
        fmt.Println(<span>"Совершеннолетний"</span>)
    } <span>else</span> {
        fmt.Println(<span>"Несовершеннолетний"</span>) <span>// Вывод: Несовершеннолетний</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Условные выражения позволяют делать логические проверки для принятия решений.</li></ul></li><li><p><strong>Проверка знака числа</strong></p><ul><li>Задача: Определите, положительное, отрицательное или ноль.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    num := <span>-5</span>
    <span>if</span> num &gt; <span>0</span> {
        fmt.Println(<span>"Положительное число"</span>)
    } <span>else</span> <span>if</span> num &lt; <span>0</span> {
        fmt.Println(<span>"Отрицательное число"</span>) <span>// Вывод: Отрицательное число</span>
    } <span>else</span> {
        fmt.Println(<span>"Ноль"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Множественные условия позволяют обрабатывать разные варианты.</li></ul></li><li><p><strong>Проверка уровня доступа</strong></p><ul><li>Задача: Определите уровень доступа пользователя.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    role := <span>"admin"</span>
    <span>if</span> role == <span>"admin"</span> {
        fmt.Println(<span>"Доступ к админ-панели"</span>) <span>// Вывод: Доступ к админ-панели</span>
    } <span>else</span> {
        fmt.Println(<span>"Ограниченный доступ"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Условные выражения используются для управления доступом в приложениях.</li></ul></li><li><p><strong>Оценка успеваемости</strong></p><ul><li>Задача: Определите оценку на основе баллов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    score := <span>85</span>
    <span>if</span> score &gt;= <span>90</span> {
        fmt.Println(<span>"Оценка: A"</span>)
    } <span>else</span> <span>if</span> score &gt;= <span>80</span> {
        fmt.Println(<span>"Оценка: B"</span>) <span>// Вывод: Оценка: B</span>
    } <span>else</span> <span>if</span> score &gt;= <span>70</span> {
        fmt.Println(<span>"Оценка: C"</span>)
    } <span>else</span> {
        fmt.Println(<span>"Оценка: D"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Условные конструкции помогают в оценке результатов.</li></ul></li><li><p><strong>Проверка наличия товара</strong></p><ul><li>Задача: Определите, есть ли товар в наличии.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    inStock := <span>false</span>
    <span>if</span> inStock {
        fmt.Println(<span>"Товар доступен"</span>)
    } <span>else</span> {
        fmt.Println(<span>"Товар отсутствует"</span>) <span>// Вывод: Товар отсутствует</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Проверка условий важна для управления состоянием приложения.</li></ul></li><li><p><strong>Сравнение строк</strong></p><ul><li>Задача: Проверьте, совпадают ли две строки.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    str1 := <span>"Hello"</span>
    str2 := <span>"World"</span>
    <span>if</span> str1 == str2 {
        fmt.Println(<span>"Строки совпадают"</span>)
    } <span>else</span> {
        fmt.Println(<span>"Строки не совпадают"</span>) <span>// Вывод: Строки не совпадают</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Условные выражения могут сравнивать строки для выполнения различных действий.</li></ul></li><li><p><strong>Проверка пароля</strong></p><ul><li>Задача: Проверьте, верен ли введенный пароль.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    password := <span>"secret123"</span>
    <span>if</span> password == <span>"secret123"</span> {
        fmt.Println(<span>"Пароль верен"</span>) <span>// Вывод: Пароль верен</span>
    } <span>else</span> {
        fmt.Println(<span>"Неверный пароль"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Условия проверяют важные аспекты безопасности.</li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Определение треугольника по сторонам</strong></p><ul><li>Задача: Проверьте, существует ли треугольник с заданными сторонами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b, c := <span>3</span>, <span>4</span>, <span>5</span>
    <span>if</span> a+b &gt; c &amp;&amp; a+c &gt; b &amp;&amp; b+c &gt; a {
        fmt.Println(<span>"Треугольник существует"</span>) <span>// Вывод: Треугольник существует</span>
    } <span>else</span> {
        fmt.Println(<span>"Треугольник не существует"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Условия могут использоваться для сложных математических проверок.</li></ul></li><li><p><strong>Определение сезона по месяцу</strong></p><ul><li>Задача: Определите сезон на основе номера месяца.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    month := <span>7</span>
    <span>if</span> month &gt;= <span>3</span> &amp;&amp; month &lt;= <span>5</span> {
        fmt.Println(<span>"Весна"</span>)
    } <span>else</span> <span>if</span> month &gt;= <span>6</span> &amp;&amp; month &lt;= <span>8</span> {
        fmt.Println(<span>"Лето"</span>) <span>// Вывод: Лето</span>
    } <span>else</span> <span>if</span> month &gt;= <span>9</span> &amp;&amp; month &lt;= <span>11</span> {
        fmt.Println(<span>"Осень"</span>)
    } <span>else</span> {
        fmt.Println(<span>"Зима"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Условия позволяют определить категорию на основе диапазонов.</li></ul></li><li><p><strong>Классификация чисел</strong></p><ul><li>Задача: Классифицируйте число как положительное, отрицательное или ноль, а также четное или нечетное.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    num := <span>-6</span>
    <span>if</span> num == <span>0</span> {
        fmt.Println(<span>"Ноль"</span>)
    } <span>else</span> <span>if</span> num &gt; <span>0</span> {
        fmt.Print(<span>"Положительное "</span>)
    } <span>else</span> {
        fmt.Print(<span>"Отрицательное "</span>)
    }
    <span>if</span> num%<span>2</span> == <span>0</span> {
        fmt.Println(<span>"четное число"</span>) <span>// Вывод: Отрицательное четное число</span>
    } <span>else</span> {
        fmt.Println(<span>"нечетное число"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Комбинированные условия позволяют создавать более сложные логические проверки.</li></ul></li><li><p><strong>Определение типа фигуры</strong></p><ul><li>Задача: Определите тип фигуры по количеству сторон.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    sides := <span>4</span>
    <span>if</span> sides == <span>3</span> {
        fmt.Println(<span>"Треугольник"</span>)
    } <span>else</span> <span>if</span> sides == <span>4</span> {
        fmt.Println(<span>"Квадрат"</span>) <span>// Вывод: Квадрат</span>
    } <span>else</span> {
        fmt.Println(<span>"Неизвестная фигура"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Условные конструкции помогают идентифицировать объекты по их характеристикам.</li></ul></li><li><p><strong>Проверка на аномалию</strong></p><ul><li>Задача: Проверьте, является ли число аномально высоким или низким.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    value := <span>150</span>
    <span>if</span> value &lt; <span>0</span> {
        fmt.Println(<span>"Ненормальное низкое значение"</span>)
    } <span>else</span> <span>if</span> value &gt; <span>100</span> {
        fmt.Println(<span>"Ненормально высокое значение"</span>) <span>// Вывод: Ненормально высокое значение</span>
    } <span>else</span> {
        fmt.Println(<span>"Нормальное значение"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Условия могут использоваться для выявления аномалий в данных.</li></ul></li></ol><h2>2. </h2><h1 id="heading-6" class="numbered" data-id="6" style="--bg-color: purple;">
ПОРАЗРЯДНЫЕ ОПЕРАЦИИ</h1><h3>Базовые задачи</h3><ol><li><p><strong>Побитовые операции</strong></p><ul><li>Задача: Выполните побитовые операции AND.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b := <span>12</span>, <span>5</span>
    result := a &amp; b
    fmt.Println(<span>"a &amp; b ="</span>, result) <span>// Вывод: a &amp; b = 4</span>
}
</code></div></div></pre></li><li>Комментарий: Побитовые операции позволяют работать на уровне битов, что полезно для низкоуровневого программирования.</li></ul></li><li><p><strong>Побитовые операции OR</strong></p><ul><li>Задача: Выполните побитовые операции OR.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b := <span>12</span>, <span>5</span>
    result := a | b
    fmt.Println(<span>"a | b ="</span>, result) <span>// Вывод: a | b = 13</span>
}
</code></div></div></pre></li><li>Комментарий: Используется для установки битов.</li></ul></li><li><p><strong>Побитовые операции XOR</strong></p><ul><li>Задача: Выполните побитовые операции XOR.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b := <span>12</span>, <span>5</span>
    result := a ^ b
    fmt.Println(<span>"a ^ b ="</span>, result) <span>// Вывод: a ^ b = 9</span>
}
</code></div></div></pre></li><li>Комментарий: XOR используется для нахождения различий между битами.</li></ul></li><li><p><strong>Побитовые сдвиги</strong></p><ul><li>Задача: Выполните побитовый сдвиг влево.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a := <span>3</span>
    result := a &lt;&lt; <span>2</span>
    fmt.Println(<span>"a &lt;&lt; 2 ="</span>, result) <span>// Вывод: a &lt;&lt; 2 = 12</span>
}
</code></div></div></pre></li><li>Комментарий: Сдвиги полезны для умножения или деления на степени двойки.</li></ul></li><li><p><strong>Побитовые сдвиги вправо</strong></p><ul><li>Задача: Выполните побитовый сдвиг вправо.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a := <span>12</span>
    result := a &gt;&gt; <span>2</span>
    fmt.Println(<span>"a &gt;&gt; 2 ="</span>, result) <span>// Вывод: a &gt;&gt; 2 = 3</span>
}
</code></div></div></pre></li><li>Комментарий: Сдвиг вправо используется для деления.</li></ul></li><li><p><strong>Комбинирование операций</strong></p><ul><li>Задача: Используйте комбинацию побитовых операций.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b := <span>12</span>, <span>5</span>
    result := (a &amp; b) | (a ^ b)
    fmt.Println(<span>"Combined result ="</span>, result) <span>// Вывод: Combined result = 13</span>
}
</code></div></div></pre></li><li>Комментарий: Комбинирование позволяет создавать более сложные операции.</li></ul></li><li><p><strong>Проверка бита</strong></p><ul><li>Задача: Проверьте, установлен ли определенный бит.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a := <span>12</span>
    bitPosition := <span>2</span>
    <span>if</span> a&amp;(<span>1</span>&lt;&lt;bitPosition) != <span>0</span> {
        fmt.Println(<span>"Бит установлен"</span>) <span>// Вывод: Бит установлен</span>
    } <span>else</span> {
        fmt.Println(<span>"Бит не установлен"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Проверка битов полезна для управления состоянием.</li></ul></li><li><p><strong>Изменение бита</strong></p><ul><li>Задача: Установите или сбросьте бит.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a := <span>12</span>
    bitPosition := <span>1</span>
    a |= (<span>1</span> &lt;&lt; bitPosition) <span>// Установить бит</span>
    fmt.Println(<span>"Установленный бит:"</span>, a) <span>// Вывод: Установленный бит: 14</span>
    a &amp;= ^(<span>1</span> &lt;&lt; bitPosition) <span>// Сбросить бит</span>
    fmt.Println(<span>"Сброшенный бит:"</span>, a) <span>// Вывод: Сброшенный бит: 12</span>
}
</code></div></div></pre></li><li>Комментарий: Управление битами позволяет реализовать множество оптимизаций.</li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Определение четности с помощью побитовых операций</strong></p><ul><li>Задача: Определите, является ли число четным или нечетным, используя побитовые операции.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    number := <span>5</span>
    <span>if</span> number&amp;<span>1</span> == <span>0</span> {
        fmt.Println(<span>"Четное число"</span>)
    } <span>else</span> {
        fmt.Println(<span>"Нечетное число"</span>) <span>// Вывод: Нечетное число</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Побитовые операции могут использоваться для оптимизации проверок.</li></ul></li><li><p><strong>Обмен значений с помощью побитовых операций</strong></p><ul><li>Задача: Обменяйте значения двух переменных без использования временной переменной.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b := <span>5</span>, <span>10</span>
    a = a ^ b
    b = a ^ b
    a = a ^ b
    fmt.Println(<span>"a ="</span>, a, <span>", b ="</span>, b) <span>// Вывод: a = 10 , b = 5</span>
}
</code></div></div></pre></li><li>Комментарий: Этот метод обмена значениями является эффективным и интересным примером использования XOR.</li></ul></li><li><p><strong>Установка нескольких битов</strong></p><ul><li>Задача: Установите несколько битов одновременно.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a := <span>5</span> <span>// 0101</span>
    mask := <span>0</span>b1110 <span>// 1110</span>
    a |= mask
    fmt.Println(<span>"Результат установки битов:"</span>, a) <span>// Вывод: Результат установки битов: 15</span>
}
</code></div></div></pre></li><li>Комментарий: Установка нескольких битов позволяет быстро изменять состояние.</li></ul></li><li><p><strong>Сброс нескольких битов</strong></p><ul><li>Задача: Сбросьте несколько битов одновременно.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a := <span>15</span> <span>// 1111</span>
    mask := <span>0</span>b1101 <span>// 1101</span>
    a &amp;= ^mask
    fmt.Println(<span>"Результат сброса битов:"</span>, a) <span>// Вывод: Результат сброса битов: 2</span>
}
</code></div></div></pre></li><li>Комментарий: Сброс нескольких битов позволяет эффективно управлять состоянием.</li></ul></li><li><p><strong>Проверка совпадения битов</strong></p><ul><li>Задача: Проверьте, совпадают ли определенные биты в двух числах.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b := <span>12</span>, <span>5</span> <span>// 1100 и 0101</span>
    position := <span>2</span>
    <span>if</span> (a &amp; (<span>1</span> &lt;&lt; position)) == (b &amp; (<span>1</span> &lt;&lt; position)) {
        fmt.Println(<span>"Биты совпадают"</span>) <span>// Вывод: Биты совпадают</span>
    } <span>else</span> {
        fmt.Println(<span>"Биты не совпадают"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Проверка совпадения битов полезна для различных логических операций.</li></ul></li></ol><h2>3. </h2><h1 id="heading-7" class="numbered" data-id="7" style="--bg-color: pink;">
МАССИВЫ</h1><h3>Базовые задачи</h3><ol><li><p><strong>Создание и вывод массива</strong></p><ul><li>Задача: Создайте массив и выведите его элементы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>3</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    fmt.Println(<span>"Массив:"</span>, arr) <span>// Вывод: Массив: [1 2 3]</span>
}
</code></div></div></pre></li><li>Комментарий: Массивы хранят фиксированный набор значений одного типа.</li></ul></li><li><p><strong>Доступ к элементам массива</strong></p><ul><li>Задача: Получите доступ к элементу массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>3</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    fmt.Println(<span>"Первый элемент:"</span>, arr[<span>0</span>]) <span>// Вывод: Первый элемент: 1</span>
}
</code></div></div></pre></li><li>Комментарий: Доступ к элементам массива осуществляется по индексу.</li></ul></li><li><p><strong>Изменение элемента массива</strong></p><ul><li>Задача: Измените значение элемента массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>3</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    arr[<span>1</span>] = <span>20</span>
    fmt.Println(<span>"Измененный массив:"</span>, arr) <span>// Вывод: Измененный массив: [1 20 3]</span>
}
</code></div></div></pre></li><li>Комментарий: Массивы позволяют изменять свои значения после инициализации.</li></ul></li><li><p><strong>Определение длины массива</strong></p><ul><li>Задача: Определите длину массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>5</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    fmt.Println(<span>"Длина массива:"</span>, <span>len</span>(arr)) <span>// Вывод: Длина массива: 5</span>
}
</code></div></div></pre></li><li>Комментарий: Длина массива позволяет управлять его размером в коде.</li></ul></li><li><p><strong>Перебор массива с помощью цикла</strong></p><ul><li>Задача: Переберите массив и выведите его элементы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>3</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    <span>for</span> i := <span>0</span>; i &lt; <span>len</span>(arr); i++ {
        fmt.Println(arr[i]) <span>// Вывод: 1 2 3</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Циклы используются для работы с массивами.</li></ul></li><li><p><strong>Сумма элементов массива</strong></p><ul><li>Задача: Найдите сумму элементов массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>3</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    sum := <span>0</span>
    <span>for</span> _, value := <span>range</span> arr {
        sum += value
    }
    fmt.Println(<span>"Сумма элементов:"</span>, sum) <span>// Вывод: Сумма элементов: 6</span>
}
</code></div></div></pre></li><li>Комментарий: Использование <code>range</code> упрощает работу с элементами массива.</li></ul></li><li><p><strong>Копирование массива</strong></p><ul><li>Задача: Скопируйте массив в другой массив.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr1 := [<span>3</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    arr2 := arr1
    arr2[<span>0</span>] = <span>10</span>
    fmt.Println(<span>"arr1:"</span>, arr1) <span>// Вывод: arr1: [1 2 3]</span>
    fmt.Println(<span>"arr2:"</span>, arr2) <span>// Вывод: arr2: [10 2 3]</span>
}
</code></div></div></pre></li><li>Комментарий: Копирование массива создает независимый экземпляр.</li></ul></li><li><p><strong>Массив строк</strong></p><ul><li>Задача: Создайте массив строк и выведите его элементы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    fruits := [<span>3</span>]<span>string</span>{<span>"apple"</span>, <span>"banana"</span>, <span>"cherry"</span>}
    fmt.Println(<span>"Фрукты:"</span>, fruits) <span>// Вывод: Фрукты: [apple banana cherry]</span>
}
</code></div></div></pre></li><li>Комментарий: Массивы могут содержать элементы разных типов.</li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Реверс массива</strong></p><ul><li>Задача: Реверсируйте массив.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>5</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    <span>for</span> i, j := <span>0</span>, <span>len</span>(arr)<span>-1</span>; i &lt; j; i, j = i+<span>1</span>, j<span>-1</span> {
        arr[i], arr[j] = arr[j], arr[i]
    }
    fmt.Println(<span>"Реверсированный массив:"</span>, arr) <span>// Вывод: Реверсированный массив: [5 4 3 2 1]</span>
}
</code></div></div></pre></li><li>Комментарий: Перестановка значений позволяет изменять порядок элементов.</li></ul></li><li><p><strong>Поиск максимального элемента</strong></p><ul><li>Задача: Найдите максимальный элемент массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>5</span>]<span>int</span>{<span>1</span>, <span>3</span>, <span>5</span>, <span>7</span>, <span>2</span>}
    max := arr[<span>0</span>]
    <span>for</span> _, value := <span>range</span> arr {
        <span>if</span> value &gt; max {
            max = value
        }
    }
    fmt.Println(<span>"Максимальный элемент:"</span>, max) <span>// Вывод: Максимальный элемент: 7</span>
}
</code></div></div></pre></li><li>Комментарий: Поиск максимального элемента полезен для анализа данных.</li></ul></li><li><p><strong>Удаление элемента из массива</strong></p><ul><li>Задача: Удалите элемент из массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>5</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    index := <span>2</span>
    arr = <span>append</span>(arr[:index], arr[index+<span>1</span>:]...)
    fmt.Println(<span>"Массив после удаления элемента:"</span>, arr) <span>// Вывод: Массив после удаления элемента: [1 2 4 5]</span>
}
</code></div></div></pre></li><li>Комментарий: Удаление элементов помогает управлять динамическими данными.</li></ul></li><li><p><strong>Слияние двух массивов</strong></p><ul><li>Задача: Слейте два массива в один.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr1 := [<span>3</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    arr2 := [<span>2</span>]<span>int</span>{<span>4</span>, <span>5</span>}
    merged := <span>append</span>(arr1[:], arr2[:]...)
    fmt.Println(<span>"Слитый массив:"</span>, merged) <span>// Вывод: Слитый массив: [1 2 3 4 5]</span>
}
</code></div></div></pre></li><li>Комментарий: Слияние массивов помогает в комбинировании данных.</li></ul></li><li><p><strong>Поиск элемента в массиве</strong></p><ul><li>Задача: Найдите, есть ли элемент в массиве.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>5</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    search := <span>3</span>
    found := <span>false</span>
    <span>for</span> _, value := <span>range</span> arr {
        <span>if</span> value == search {
            found = <span>true</span>
            <span>break</span>
        }
    }
    <span>if</span> found {
        fmt.Println(<span>"Элемент найден"</span>) <span>// Вывод: Элемент найден</span>
    } <span>else</span> {
        fmt.Println(<span>"Элемент не найден"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Поиск элементов необходим для проверки наличия данных.</li></ul></li></ol><h2>4. </h2><h1 id="heading-8" class="numbered" data-id="8" style="--bg-color: red;">
УСЛОВНЫЕ КОНСТРУКЦИИ</h1><h3>Базовые задачи</h3><ol><li><p><strong>Простая конструкция if</strong></p><ul><li>Задача: Проверьте, является ли число положительным.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    num := <span>5</span>
    <span>if</span> num &gt; <span>0</span> {
        fmt.Println(<span>"Положительное число"</span>) <span>// Вывод: Положительное число</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Простые конструкции if позволяют выполнять код, если условие истинно.</li></ul></li><li><p><strong>Условие if-else</strong></p><ul><li>Задача: Проверьте, является ли число четным или нечетным.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    num := <span>4</span>
    <span>if</span> num%<span>2</span> == <span>0</span> {
        fmt.Println(<span>"Четное число"</span>) <span>// Вывод: Четное число</span>
    } <span>else</span> {
        fmt.Println(<span>"Нечетное число"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Конструкция if-else позволяет обрабатывать два случая.</li></ul></li><li><p><strong>Множественные условия</strong></p><ul><li>Задача: Определите диапазон числа.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    num := <span>15</span>
    <span>if</span> num &lt; <span>0</span> {
        fmt.Println(<span>"Отрицательное число"</span>)
    } <span>else</span> <span>if</span> num == <span>0</span> {
        fmt.Println(<span>"Ноль"</span>)
    } <span>else</span> {
        fmt.Println(<span>"Положительное число"</span>) <span>// Вывод: Положительное число</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Множественные условия помогают в более сложных проверках.</li></ul></li><li><p><strong>Использование переменной в условии</strong></p><ul><li>Задача: Проверьте, установлена ли переменная.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    isAvailable := <span>true</span>
    <span>if</span> isAvailable {
        fmt.Println(<span>"Доступно"</span>) <span>// Вывод: Доступно</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Проверка булевых переменных часто используется в условных конструкциях.</li></ul></li><li><p><strong>Конструкция switch</strong></p><ul><li>Задача: Используйте switch для определения дня недели.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    day := <span>3</span>
    <span>switch</span> day {
    <span>case</span> <span>1</span>:
        fmt.Println(<span>"Понедельник"</span>)
    <span>case</span> <span>2</span>:
        fmt.Println(<span>"Вторник"</span>)
    <span>case</span> <span>3</span>:
        fmt.Println(<span>"Среда"</span>) <span>// Вывод: Среда</span>
    <span>default</span>:
        fmt.Println(<span>"Неизвестный день"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Конструкция switch удобна для выбора из нескольких вариантов.</li></ul></li><li><p><strong>Switch с условием</strong></p><ul><li>Задача: Используйте switch с условием.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    num := <span>10</span>
    <span>switch</span> {
    <span>case</span> num &lt; <span>0</span>:
        fmt.Println(<span>"Отрицательное число"</span>)
    <span>case</span> num &gt; <span>0</span>:
        fmt.Println(<span>"Положительное число"</span>) <span>// Вывод: Положительное число</span>
    <span>default</span>:
        fmt.Println(<span>"Ноль"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Switch без аргументов позволяет использовать сложные условия.</li></ul></li><li><p><strong>Fallthrough в switch</strong></p><ul><li>Задача: Используйте fallthrough в конструкции switch.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    num := <span>2</span>
    <span>switch</span> num {
    <span>case</span> <span>1</span>:
        fmt.Println(<span>"Один"</span>)
    <span>case</span> <span>2</span>:
        fmt.Println(<span>"Два"</span>)
        <span>fallthrough</span>
    <span>case</span> <span>3</span>:
        fmt.Println(<span>"Три"</span>) <span>// Вывод: Два Три</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Fallthrough позволяет продолжать выполнение следующего случая.</li></ul></li><li><p><strong>Проверка нескольких условий</strong></p><ul><li>Задача: Проверьте, находится ли число в определенном диапазоне.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    num := <span>25</span>
    <span>if</span> num &gt;= <span>10</span> &amp;&amp; num &lt;= <span>30</span> {
        fmt.Println(<span>"Число в диапазоне от 10 до 30"</span>) <span>// Вывод: Число в диапазоне от 10 до 30</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Проверка нескольких условий позволяет создавать более сложные логические проверки.</li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Проверка года на високосность</strong></p><ul><li>Задача: Проверьте, является ли год високосным.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    year := <span>2024</span>
    <span>if</span> (year%<span>4</span> == <span>0</span> &amp;&amp; year%<span>100</span> != <span>0</span>) || (year%<span>400</span> == <span>0</span>) {
        fmt.Println(<span>"Високосный год"</span>) <span>// Вывод: Високосный год</span>
    } <span>else</span> {
        fmt.Println(<span>"Не високосный год"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Проверка високосного года иллюстрирует использование сложных условий.</li></ul></li><li><p><strong>Определение типа треугольника</strong></p><ul><li>Задача: Определите тип треугольника по длинам сторон.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b, c := <span>3</span>, <span>4</span>, <span>5</span>
    <span>if</span> a == b &amp;&amp; b == c {
        fmt.Println(<span>"Равносторонний треугольник"</span>)
    } <span>else</span> <span>if</span> a == b || b == c || a == c {
        fmt.Println(<span>"Равнобедренный треугольник"</span>)
    } <span>else</span> {
        fmt.Println(<span>"Разносторонний треугольник"</span>) <span>// Вывод: Разносторонний треугольник</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Определение типа треугольника требует проверки всех сторон.</li></ul></li><li><p><strong>Оценка по баллам</strong></p><ul><li>Задача: Оцените студента по баллам.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    score := <span>85</span>
    <span>var</span> grade <span>string</span>
    <span>switch</span> {
    <span>case</span> score &gt;= <span>90</span>:
        grade = <span>"A"</span>
    <span>case</span> score &gt;= <span>80</span>:
        grade = <span>"B"</span>
    <span>case</span> score &gt;= <span>70</span>:
        grade = <span>"C"</span>
    <span>case</span> score &gt;= <span>60</span>:
        grade = <span>"D"</span>
    <span>default</span>:
        grade = <span>"F"</span>
    }
    fmt.Println(<span>"Оценка:"</span>, grade) <span>// Вывод: Оценка: B</span>
}
</code></div></div></pre></li><li>Комментарий: Оценка по баллам требует проверки нескольких условий.</li></ul></li><li><p><strong>Проверка на простое число</strong></p><ul><li>Задача: Проверьте, является ли число простым.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    num := <span>29</span>
    isPrime := <span>true</span>
    <span>for</span> i := <span>2</span>; i*i &lt;= num; i++ {
        <span>if</span> num%i == <span>0</span> {
            isPrime = <span>false</span>
            <span>break</span>
        }
    }
    <span>if</span> isPrime &amp;&amp; num &gt; <span>1</span> {
        fmt.Println(<span>"Простое число"</span>) <span>// Вывод: Простое число</span>
    } <span>else</span> {
        fmt.Println(<span>"Не простое число"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Проверка простоты числа требует использования циклов и условий.</li></ul></li><li><p><strong>Классификация возраста</strong></p><ul><li>Задача: Классифицируйте возраст человека.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    age := <span>20</span>
    <span>switch</span> {
    <span>case</span> age &lt; <span>13</span>:
        fmt.Println(<span>"Ребенок"</span>)
    <span>case</span> age &lt; <span>20</span>:
        fmt.Println(<span>"Подросток"</span>)
    <span>case</span> age &lt; <span>65</span>:
        fmt.Println(<span>"Взрослый"</span>) <span>// Вывод: Взрослый</span>
    <span>default</span>:
        fmt.Println(<span>"Пожилой человек"</span>)
    }
}
</code></div></div></pre></li><li>Комментарий: Классификация возраста иллюстрирует использование условий в реальной жизни.</li></ul></li></ol><h2>5. </h2><h1 id="heading-9" class="numbered" data-id="9" style="--bg-color: blue;">
ФУНКЦИИ</h1><h3>Базовые задачи</h3><ol><li><p><strong>Определение функции</strong></p><ul><li>Задача: Определите простую функцию.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>greet</span><span>()</span></span> {
    fmt.Println(<span>"Привет, мир!"</span>) <span>// Вывод: Привет, мир!</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    greet()
}
</code></div></div></pre></li><li>Комментарий: Определение функции позволяет структурировать код.</li></ul></li><li><p><strong>Функция с параметрами</strong></p><ul><li>Задача: Определите функцию с параметрами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>add</span><span>(a <span>int</span>, b <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> a + b
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    result := add(<span>5</span>, <span>3</span>)
    fmt.Println(<span>"Сумма:"</span>, result) <span>// Вывод: Сумма: 8</span>
}
</code></div></div></pre></li><li>Комментарий: Параметры позволяют передавать значения в функцию.</li></ul></li><li><p><strong>Функция с возвращаемым значением</strong></p><ul><li>Задача: Определите функцию, возвращающую значение.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>multiply</span><span>(a <span>int</span>, b <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> a * b
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    result := multiply(<span>4</span>, <span>5</span>)
    fmt.Println(<span>"Произведение:"</span>, result) <span>// Вывод: Произведение: 20</span>
}
</code></div></div></pre></li><li>Комментарий: Возвращаемые значения позволяют получать результаты из функций.</li></ul></li><li><p><strong>Функция без параметров</strong></p><ul><li>Задача: Определите функцию без параметров.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>sayHello</span><span>()</span></span> {
    fmt.Println(<span>"Здравствуйте!"</span>) <span>// Вывод: Здравствуйте!</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    sayHello()
}
</code></div></div></pre></li><li>Комментарий: Функции могут не принимать параметров.</li></ul></li><li><p><strong>Функция с несколькими возвращаемыми значениями</strong></p><ul><li>Задача: Определите функцию с несколькими возвращаемыми значениями.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>divide</span><span>(a, b <span>int</span>)</span></span> (<span>int</span>, <span>int</span>) {
    <span>return</span> a / b, a % b
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    quotient, remainder := divide(<span>10</span>, <span>3</span>)
    fmt.Println(<span>"Частное:"</span>, quotient, <span>", Остаток:"</span>, remainder) <span>// Вывод: Частное: 3 , Остаток: 1</span>
}
</code></div></div></pre></li><li>Комментарий: Функции могут возвращать несколько значений.</li></ul></li><li><p><strong>Анонимные функции</strong></p><ul><li>Задача: Определите и вызовите анонимную функцию.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span><span>func</span><span>()</span></span> {
        fmt.Println(<span>"Это анонимная функция"</span>) <span>// Вывод: Это анонимная функция</span>
    }()
}
</code></div></div></pre></li><li>Комментарий: Анонимные функции могут быть полезны для однократного использования.</li></ul></li><li><p><strong>Замыкания</strong></p><ul><li>Задача: Используйте замыкание для создания функции.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>makeCounter</span><span>()</span></span> <span><span>func</span><span>()</span></span> <span>int</span> {
    count := <span>0</span>
    <span>return</span> <span><span>func</span><span>()</span></span> <span>int</span> {
        count++
        <span>return</span> count
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    counter := makeCounter()
    fmt.Println(counter()) <span>// Вывод: 1</span>
    fmt.Println(counter()) <span>// Вывод: 2</span>
}
</code></div></div></pre></li><li>Комментарий: Замыкания позволяют сохранять состояние между вызовами.</li></ul></li><li><p><strong>Переменное число аргументов</strong></p><ul><li>Задача: Определите функцию с переменным числом аргументов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>sum</span><span>(numbers ...<span>int</span>)</span></span> <span>int</span> {
    total := <span>0</span>
    <span>for</span> _, number := <span>range</span> numbers {
        total += number
    }
    <span>return</span> total
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    result := sum(<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>)
    fmt.Println(<span>"Сумма:"</span>, result) <span>// Вывод: Сумма: 15</span>
}
</code></div></div></pre></li><li>Комментарий: Переменные аргументы позволяют передавать произвольное количество значений.</li></ul></li></ol><h3>Сложные задачи</h3><ol><li><strong>Рекурсивная функция</strong><ul><li>Задача: Определите рекурсивную функцию для вычисления факториала.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>factorial</span><span>(n <span>int</span>)</span></span> <span>int</span> {
    <span>if</span> n == <span>0</span> {
        <span>return</span> <span>1</span>
    }
    <span>return</span> n * factorial(n<span>-1</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    result := factorial(<span>5</span>)
    fmt.Println(<span>"Факториал:"</span>, result) <span>// Вывод: Факториал: 120</span>
}
</code></div></div></pre></li></ul></li></ol></div></div></div></div><div><div><div><div></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div><div><svg width="41" height="41" viewBox="0 0 41 41" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-md" role="img"><text x="-9999" y="-9999"></text></svg></div></div></div></div></div><div><div><div><div dir="auto"><div><div><h3>5. </h3><h1 id="heading-10" class="numbered" data-id="10" style="--bg-color: green;">
ЦИКЛЫ</h1><p>Циклы — это способ повторять выполнение блока кода несколько раз. Они полезны для работы с массивами, выполнения однотипных операций и многого другого. В Go основным циклом является <code>for</code>, который может работать как классический цикл, цикл с условием или бесконечный цикл.</p><h3>Базовые задачи</h3><ol><li><p><strong>Цикл с фиксированным количеством итераций</strong></p><ul><li>Задача: Выведите числа от 1 до 5.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>for</span> i := <span>1</span>; i &lt;= <span>5</span>; i++ {
        fmt.Println(i) <span>// Вывод: 1 2 3 4 5</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Классический цикл с начальным значением, условием и шагом итерации.</li></ul></li><li><p><strong>Цикл с условием</strong></p><ul><li>Задача: Выведите числа от 1 до 5, используя цикл с условием.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    i := <span>1</span>
    <span>for</span> i &lt;= <span>5</span> {
        fmt.Println(i) <span>// Вывод: 1 2 3 4 5</span>
        i++
    }
}
</code></div></div></pre></li><li>Комментарий: Цикл выполняется, пока условие истинно.</li></ul></li><li><p><strong>Бесконечный цикл</strong></p><ul><li>Задача: Выполните бесконечный цикл с прерыванием.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    i := <span>1</span>
    <span>for</span> {
        fmt.Println(i)
        <span>if</span> i == <span>5</span> {
            <span>break</span> <span>// Выход из цикла при достижении числа 5</span>
        }
        i++
    }
}
</code></div></div></pre></li><li>Комментарий: Бесконечный цикл можно использовать с условием для его прерывания.</li></ul></li><li><p><strong>Пропуск итерации (continue)</strong></p><ul><li>Задача: Выведите числа от 1 до 5, пропуская 3.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>for</span> i := <span>1</span>; i &lt;= <span>5</span>; i++ {
        <span>if</span> i == <span>3</span> {
            <span>continue</span> <span>// Пропуск числа 3</span>
        }
        fmt.Println(i) <span>// Вывод: 1 2 4 5</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Оператор <code>continue</code> пропускает текущую итерацию цикла.</li></ul></li><li><p><strong>Использование цикла <code>range</code> для массивов</strong></p><ul><li>Задача: Выведите все элементы массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := []<span>int</span>{<span>10</span>, <span>20</span>, <span>30</span>, <span>40</span>, <span>50</span>}
    <span>for</span> index, value := <span>range</span> arr {
        fmt.Printf(<span>"Индекс: %d, Значение: %d\n"</span>, index, value)
    }
}
</code></div></div></pre></li><li>Комментарий: Цикл <code>range</code> упрощает работу с массивами, слайсами и картами.</li></ul></li><li><p><strong>Цикл по строке</strong></p><ul><li>Задача: Выведите все символы строки.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    str := <span>"Hello"</span>
    <span>for</span> _, char := <span>range</span> str {
        fmt.Printf(<span>"%c\n"</span>, char) <span>// Вывод: H e l l o</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Цикл <code>range</code> может применяться и к строкам для получения символов.</li></ul></li><li><p><strong>Вывод четных чисел</strong></p><ul><li>Задача: Выведите только четные числа от 1 до 10.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>for</span> i := <span>1</span>; i &lt;= <span>10</span>; i++ {
        <span>if</span> i%<span>2</span> != <span>0</span> {
            <span>continue</span>
        }
        fmt.Println(i) <span>// Вывод: 2 4 6 8 10</span>
    }
}
</code></div></div></pre></li><li>Комментарий: Использование остатка от деления для фильтрации чисел.</li></ul></li><li><p><strong>Цикл по двумерному массиву</strong></p><ul><li>Задача: Выведите элементы двумерного массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>2</span>][<span>2</span>]<span>int</span>{{<span>1</span>, <span>2</span>}, {<span>3</span>, <span>4</span>}}
    <span>for</span> i := <span>0</span>; i &lt; <span>len</span>(arr); i++ {
        <span>for</span> j := <span>0</span>; j &lt; <span>len</span>(arr[i]); j++ {
            fmt.Printf(<span>"Элемент [%d][%d] = %d\n"</span>, i, j, arr[i][j])
        }
    }
}
</code></div></div></pre></li><li>Комментарий: Вложенные циклы используются для работы с многомерными массивами.</li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Вывод чисел Фибоначчи</strong></p><ul><li>Задача: Выведите первые 10 чисел Фибоначчи.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a, b := <span>0</span>, <span>1</span>
    <span>for</span> i := <span>0</span>; i &lt; <span>10</span>; i++ {
        fmt.Println(a)
        a, b = b, a+b
    }
}
</code></div></div></pre></li><li>Комментарий: Числа Фибоначчи часто используются в математических задачах.</li></ul></li><li><p><strong>Реверс строки</strong></p><ul><li>Задача: Разверните строку с использованием цикла.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    str := <span>"Hello"</span>
    reversed := <span>""</span>
    <span>for</span> _, char := <span>range</span> str {
        reversed = <span>string</span>(char) + reversed
    }
    fmt.Println(reversed) <span>// Вывод: olleH</span>
}
</code></div></div></pre></li><li>Комментарий: Использование цикла для манипуляций с символами строки.</li></ul></li><li><p><strong>Поиск минимального элемента в массиве</strong></p><ul><li>Задача: Найдите минимальный элемент в массиве.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := []<span>int</span>{<span>5</span>, <span>3</span>, <span>8</span>, <span>2</span>, <span>4</span>}
    min := arr[<span>0</span>]
    <span>for</span> _, value := <span>range</span> arr {
        <span>if</span> value &lt; min {
            min = value
        }
    }
    fmt.Println(<span>"Минимальный элемент:"</span>, min) <span>// Вывод: Минимальный элемент: 2</span>
}
</code></div></div></pre></li><li>Комментарий: Использование цикла для анализа данных массива.</li></ul></li><li><p><strong>Факториал числа</strong></p><ul><li>Задача: Найдите факториал числа с использованием цикла.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    num := <span>5</span>
    fact := <span>1</span>
    <span>for</span> i := <span>2</span>; i &lt;= num; i++ {
        fact *= i
    }
    fmt.Println(<span>"Факториал:"</span>, fact) <span>// Вывод: Факториал: 120</span>
}
</code></div></div></pre></li><li>Комментарий: Циклы могут использоваться для сложных математических операций.</li></ul></li><li><p><strong>Перемешивание массива</strong></p><ul><li>Задача: Перемешайте элементы массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"math/rand"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    rand.Seed(time.Now().UnixNano())
    arr := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    <span>for</span> i := <span>len</span>(arr) - <span>1</span>; i &gt; <span>0</span>; i-- {
        j := rand.Intn(i + <span>1</span>)
        arr[i], arr[j] = arr[j], arr[i]
    }
    fmt.Println(<span>"Перемешанный массив:"</span>, arr)
}
</code></div></div></pre></li><li>Комментарий: Перемешивание массива требует случайной перестановки его элементов.</li></ul></li></ol><p>Циклы — это мощный инструмент для автоматизации повторяющихся задач, работы с коллекциями данных и выполнения сложных алгоритмов.</p></div></div></div></div><div><div></div></div></div></div></div></div></article><article dir="auto"><h5></h5></article><article dir="auto"><div><div><div><div><div><div><div><svg width="41" height="41" viewBox="0 0 41 41" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-md" role="img"><text x="-9999" y="-9999"></text></svg></div></div></div></div></div><div><div><div><div dir="auto"><div><div><h3>1. <strong><h1 id="heading-11" class="numbered" data-id="11" style="--bg-color: orange;">ФУНКЦИИ И ИХ ПАРАМЕТРЫ</h1></strong></h3><p>Функции с параметрами позволяют передавать данные в функцию, чтобы она могла использовать их в своих вычислениях.</p><h4>Базовые задачи</h4><ol><li><p><strong>Функция сложения двух чисел</strong></p><ul><li>Задача: Напишите функцию, которая принимает два числа и возвращает их сумму.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>add</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> a + b
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(add(<span>3</span>, <span>5</span>)) <span>// Вывод: 8</span>
}
</code></div></div></pre></li><li>Комментарий: Параметры <code>a</code> и <code>b</code> передаются в функцию для выполнения сложения.</li></ul></li><li><p><strong>Функция умножения</strong></p><ul><li>Задача: Напишите функцию для умножения двух чисел.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>multiply</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> a * b
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(multiply(<span>4</span>, <span>6</span>)) <span>// Вывод: 24</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция вывода имени</strong></p><ul><li>Задача: Напишите функцию, которая принимает имя и выводит приветствие.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>greet</span><span>(name <span>string</span>)</span></span> {
    fmt.Printf(<span>"Привет, %s!\n"</span>, name)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    greet(<span>"Алекс"</span>) <span>// Вывод: Привет, Алекс!</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция сложения массива чисел</strong></p><ul><li>Задача: Напишите функцию, которая принимает массив чисел и возвращает их сумму.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>sumArray</span><span>(arr []<span>int</span>)</span></span> <span>int</span> {
    sum := <span>0</span>
    <span>for</span> _, v := <span>range</span> arr {
        sum += v
    }
    <span>return</span> sum
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(sumArray([]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>})) <span>// Вывод: 15</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция с переменным числом аргументов</strong></p><ul><li>Задача: Напишите функцию, принимающую переменное количество чисел и возвращающую их произведение.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>multiplyAll</span><span>(nums ...<span>int</span>)</span></span> <span>int</span> {
    result := <span>1</span>
    <span>for</span> _, n := <span>range</span> nums {
        result *= n
    }
    <span>return</span> result
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(multiplyAll(<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>)) <span>// Вывод: 24</span>
}
</code></div></div></pre></li><li>Комментарий: Использование переменных аргументов позволяет передавать любое количество параметров в функцию.</li></ul></li><li><p><strong>Функция проверки четности</strong></p><ul><li>Задача: Напишите функцию, которая принимает число и проверяет, четное оно или нет.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>isEven</span><span>(num <span>int</span>)</span></span> <span>bool</span> {
    <span>return</span> num%<span>2</span> == <span>0</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(isEven(<span>4</span>))  <span>// Вывод: true</span>
    fmt.Println(isEven(<span>5</span>))  <span>// Вывод: false</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция поиска максимума</strong></p><ul><li>Задача: Напишите функцию, которая принимает два числа и возвращает максимальное из них.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>max</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>if</span> a &gt; b {
        <span>return</span> a
    }
    <span>return</span> b
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(max(<span>10</span>, <span>20</span>)) <span>// Вывод: 20</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция сравнения строк</strong></p><ul><li>Задача: Напишите функцию для сравнения двух строк.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>compareStrings</span><span>(s1, s2 <span>string</span>)</span></span> <span>bool</span> {
    <span>return</span> s1 == s2
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(compareStrings(<span>"hello"</span>, <span>"hello"</span>)) <span>// Вывод: true</span>
    fmt.Println(compareStrings(<span>"hi"</span>, <span>"bye"</span>))      <span>// Вывод: false</span>
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Функция возведения в степень</strong></p><ul><li>Задача: Напишите функцию для возведения числа в степень с использованием цикла.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>power</span><span>(base, exp <span>int</span>)</span></span> <span>int</span> {
    result := <span>1</span>
    <span>for</span> exp &gt; <span>0</span> {
        result *= base
        exp--
    }
    <span>return</span> result
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(power(<span>2</span>, <span>3</span>)) <span>// Вывод: 8</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция поиска минимального числа в массиве</strong></p><ul><li>Задача: Напишите функцию, которая возвращает минимальный элемент в массиве.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>min</span><span>(arr []<span>int</span>)</span></span> <span>int</span> {
    <span>if</span> <span>len</span>(arr) == <span>0</span> {
        <span>return</span> <span>0</span>
    }
    minVal := arr[<span>0</span>]
    <span>for</span> _, v := <span>range</span> arr {
        <span>if</span> v &lt; minVal {
            minVal = v
        }
    }
    <span>return</span> minVal
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(min([]<span>int</span>{<span>5</span>, <span>3</span>, <span>8</span>, <span>2</span>, <span>4</span>})) <span>// Вывод: 2</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция для вычисления среднего значения</strong></p><ul><li>Задача: Напишите функцию, которая принимает массив чисел и возвращает их среднее значение.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>average</span><span>(arr []<span>int</span>)</span></span> <span>float64</span> {
    sum := <span>0</span>
    <span>for</span> _, v := <span>range</span> arr {
        sum += v
    }
    <span>return</span> <span>float64</span>(sum) / <span>float64</span>(<span>len</span>(arr))
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(average([]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>})) <span>// Вывод: 3</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция нахождения НОД (наибольшего общего делителя)</strong></p><ul><li>Задача: Напишите функцию для вычисления НОД двух чисел с использованием алгоритма Евклида.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>gcd</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>for</span> b != <span>0</span> {
        a, b = b, a%b
    }
    <span>return</span> a
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(gcd(<span>48</span>, <span>18</span>)) <span>// Вывод: 6</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция для сортировки массива (Bubble Sort)</strong></p><ul><li>Задача: Напишите функцию, которая сортирует массив чисел методом пузырька.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>bubbleSort</span><span>(arr []<span>int</span>)</span></span> []<span>int</span> {
    n := <span>len</span>(arr)
    <span>for</span> i := <span>0</span>; i &lt; n; i++ {
        <span>for</span> j := <span>0</span>; j &lt; n-i<span>-1</span>; j++ {
            <span>if</span> arr[j] &gt; arr[j+<span>1</span>] {
                arr[j], arr[j+<span>1</span>] = arr[j+<span>1</span>], arr[j]
            }
        }
    }
    <span>return</span> arr
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(bubbleSort([]<span>int</span>{<span>5</span>, <span>3</span>, <span>8</span>, <span>2</span>, <span>4</span>})) <span>// Вывод: [2 3 4 5 8]</span>
}
</code></div></div></pre></li></ul></li></ol><h3>2.</h3><h1 id="heading-12" class="numbered" data-id="12" style="--bg-color: purple;">
ВОЗВРАЩЕНИЕ РЕЗУЛЬТАТА ИЗ ФУНКЦИИ</h1><strong></strong><h3>Базовые задачи</h3><ol><li><p><strong>Простая функция сложения с возвратом результата</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>add</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> a + b
}
</code></div></div></pre></li><li><p><strong>Возвращение нескольких значений (сумма и разность)</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>sumAndDiff</span><span>(a, b <span>int</span>)</span></span> (<span>int</span>, <span>int</span>) {
    <span>return</span> a + b, a - b
}
</code></div></div></pre></li></ol><p>Остальные разделы будут включать примеры по:</p><ul><li>Анонимным функциям и замыканиям</li><li>Рекурсивным функциям</li><li>Использованию <code>defer</code> и <code>panic</code></li><li>Срезам и отображениям (карты)</li></ul><p>Продолжить?</p></div></div></div></div><div><div></div></div></div></div></div></div></article><article dir="auto"><h5>Вы сказали:</h5><div><div><div><div><div><div dir="auto"><div><div><div>да</div></div></div></div></div></div></div></div></div></article><article dir="auto"><h6>ChatGPT сказал:</h6><div><div><div><div><div><div><div><svg width="41" height="41" viewBox="0 0 41 41" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-md" role="img"><text x="-9999" y="-9999">ChatGPT</text></svg></div></div></div></div></div><div><div><div><div dir="auto"><div><div><h3>3. <strong>Типы функции</strong></h3><p>Типы функций в Go позволяют передавать функции как параметры другим функциям, возвращать их из функций и сохранять в переменных.</p><h4>Базовые задачи</h4><ol><li><p><strong>Присваивание функции переменной</strong></p><ul><li>Задача: Присвойте функцию переменной и вызовите её.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>add</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> a + b
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    sumFunc := add
    fmt.Println(sumFunc(<span>3</span>, <span>4</span>)) <span>// Вывод: 7</span>
}
</code></div></div></pre></li><li>Комментарий: Функция <code>add</code> присваивается переменной и вызывается через неё.</li></ul></li><li><p><strong>Функция как параметр</strong></p><ul><li>Задача: Передайте функцию в качестве параметра другой функции.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>multiply</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> a * b
}

<span><span>func</span> <span>compute</span><span>(f <span>func</span>(<span>int</span>, <span>int</span>)</span></span> <span>int</span>, a, b <span>int</span>) <span>int</span> {
    <span>return</span> f(a, b)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    result := compute(multiply, <span>3</span>, <span>4</span>)
    fmt.Println(result) <span>// Вывод: 12</span>
}
</code></div></div></pre></li><li>Комментарий: Функция <code>multiply</code> передаётся как аргумент функции <code>compute</code>.</li></ul></li><li><p><strong>Функция, возвращающая другую функцию</strong></p><ul><li>Задача: Создайте функцию, которая возвращает другую функцию.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>getMultiplier</span><span>(x <span>int</span>)</span></span> <span><span>func</span><span>(<span>int</span>)</span></span> <span>int</span> {
    <span>return</span> <span><span>func</span><span>(y <span>int</span>)</span></span> <span>int</span> {
        <span>return</span> x * y
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    multiplyBy3 := getMultiplier(<span>3</span>)
    fmt.Println(multiplyBy3(<span>5</span>)) <span>// Вывод: 15</span>
}
</code></div></div></pre></li><li>Комментарий: Функция <code>getMultiplier</code> возвращает новую функцию для умножения.</li></ul></li><li><p><strong>Функция, которая принимает и возвращает функцию</strong></p><ul><li>Задача: Напишите функцию, которая принимает функцию и возвращает её же.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>identity</span><span>(f <span>func</span>(<span>int</span>)</span></span> <span>int</span>) <span><span>func</span><span>(<span>int</span>)</span></span> <span>int</span> {
    <span>return</span> f
}

<span><span>func</span> <span>square</span><span>(x <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> x * x
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    newFunc := identity(square)
    fmt.Println(newFunc(<span>4</span>)) <span>// Вывод: 16</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Передача функции сравнения для сортировки</strong></p><ul><li>Задача: Передайте функцию для сравнения элементов массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sort"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>5</span>, <span>2</span>, <span>9</span>, <span>1</span>, <span>6</span>}
    sort.Slice(nums, <span><span>func</span><span>(i, j <span>int</span>)</span></span> <span>bool</span> {
        <span>return</span> nums[i] &lt; nums[j]
    })
    fmt.Println(nums) <span>// Вывод: [1 2 5 6 9]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция с типом обратного вызова (callback)</strong></p><ul><li>Задача: Используйте callback-функцию для обработки данных.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>process</span><span>(numbers []<span>int</span>, callback <span>func</span>(<span>int</span>)</span></span>) {
    <span>for</span> _, n := <span>range</span> numbers {
        callback(n)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    process(nums, <span><span>func</span><span>(n <span>int</span>)</span></span> {
        fmt.Println(n * n) <span>// Вывод: 1 4 9 16 25</span>
    })
}
</code></div></div></pre></li></ul></li><li><p><strong>Передача функции для вычислений</strong></p><ul><li>Задача: Передайте функцию для выполнения математических операций.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>applyOperation</span><span>(a, b <span>int</span>, op <span>func</span>(<span>int</span>, <span>int</span>)</span></span> <span>int</span>) <span>int</span> {
    <span>return</span> op(a, b)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    add := <span><span>func</span><span>(a, b <span>int</span>)</span></span> <span>int</span> { <span>return</span> a + b }
    fmt.Println(applyOperation(<span>3</span>, <span>4</span>, add)) <span>// Вывод: 7</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Замыкания и состояние</strong></p><ul><li>Задача: Напишите функцию, которая запоминает своё состояние через замыкание.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>counter</span><span>()</span></span> <span><span>func</span><span>()</span></span> <span>int</span> {
    count := <span>0</span>
    <span>return</span> <span><span>func</span><span>()</span></span> <span>int</span> {
        count++
        <span>return</span> count
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    c := counter()
    fmt.Println(c()) <span>// Вывод: 1</span>
    fmt.Println(c()) <span>// Вывод: 2</span>
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Функция-генератор</strong></p><ul><li>Задача: Напишите генератор последовательности чисел через замыкание.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>generateSequence</span><span>()</span></span> <span><span>func</span><span>()</span></span> <span>int</span> {
    n := <span>0</span>
    <span>return</span> <span><span>func</span><span>()</span></span> <span>int</span> {
        n++
        <span>return</span> n
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    seq := generateSequence()
    fmt.Println(seq()) <span>// Вывод: 1</span>
    fmt.Println(seq()) <span>// Вывод: 2</span>
    fmt.Println(seq()) <span>// Вывод: 3</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция-декоратор</strong></p><ul><li>Задача: Напишите декоратор для логирования вызовов функции.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>logger</span><span>(f <span>func</span>(<span>int</span>)</span></span> <span>int</span>) <span><span>func</span><span>(<span>int</span>)</span></span> <span>int</span> {
    <span>return</span> <span><span>func</span><span>(x <span>int</span>)</span></span> <span>int</span> {
        fmt.Printf(<span>"Вызов функции с аргументом: %d\n"</span>, x)
        <span>return</span> f(x)
    }
}

<span><span>func</span> <span>square</span><span>(x <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> x * x
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    decorated := logger(square)
    fmt.Println(decorated(<span>5</span>)) <span>// Вывод: Вызов функции с аргументом: 5, 25</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция для работы с отображениями (картами)</strong></p><ul><li>Задача: Напишите функцию, которая применяет операцию ко всем значениям карты.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>applyToMap</span><span>(m <span>map</span>[<span>string</span>]<span>int</span>, f <span>func</span>(<span>int</span>)</span></span> <span>int</span>) <span>map</span>[<span>string</span>]<span>int</span> {
    <span>for</span> k, v := <span>range</span> m {
        m[k] = f(v)
    }
    <span>return</span> m
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    numbers := <span>map</span>[<span>string</span>]<span>int</span>{<span>"a"</span>: <span>1</span>, <span>"b"</span>: <span>2</span>, <span>"c"</span>: <span>3</span>}
    doubled := applyToMap(numbers, <span><span>func</span><span>(x <span>int</span>)</span></span> <span>int</span> { <span>return</span> x * <span>2</span> })
    fmt.Println(doubled) <span>// Вывод: map[a:2 b:4 c:6]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция фильтрации среза</strong></p><ul><li>Задача: Напишите функцию для фильтрации среза чисел по условию.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>filter</span><span>(arr []<span>int</span>, condition <span>func</span>(<span>int</span>)</span></span> <span>bool</span>) []<span>int</span> {
    result := []<span>int</span>{}
    <span>for</span> _, n := <span>range</span> arr {
        <span>if</span> condition(n) {
            result = <span>append</span>(result, n)
        }
    }
    <span>return</span> result
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    even := filter(nums, <span><span>func</span><span>(n <span>int</span>)</span></span> <span>bool</span> { <span>return</span> n%<span>2</span> == <span>0</span> })
    fmt.Println(even) <span>// Вывод: [2 4]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Кэширование результатов функции</strong></p><ul><li>Задача: Напишите функцию для кэширования результатов другой функции.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>memoize</span><span>(f <span>func</span>(<span>int</span>)</span></span> <span>int</span>) <span><span>func</span><span>(<span>int</span>)</span></span> <span>int</span> {
    cache := <span>make</span>(<span>map</span>[<span>int</span>]<span>int</span>)
    <span>return</span> <span><span>func</span><span>(x <span>int</span>)</span></span> <span>int</span> {
        <span>if</span> val, found := cache[x]; found {
            <span>return</span> val
        }
        result := f(x)
        cache[x] = result
        <span>return</span> result
    }
}

<span><span>func</span> <span>fib</span><span>(n <span>int</span>)</span></span> <span>int</span> {
    <span>if</span> n &lt;= <span>1</span> {
        <span>return</span> n
    }
    <span>return</span> fib(n<span>-1</span>) + fib(n<span>-2</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fibMemo := memoize(fib)
    fmt.Println(fibMemo(<span>5</span>)) <span>// Вывод: 5</span>
    fmt.Println(fibMemo(<span>6</span>)) <span>// Вывод: 8</span>
}
</code></div></div></pre></li></ul></li></ol><h3>4. <strong><h1 id="heading-13" class="numbered" data-id="13" style="--bg-color: pink;">АНОНИМНЫЕ ФУНКЦИИ</h1></strong></h3><h4>Базовые задачи</h4><ol><li><p><strong>Простая анонимная функция</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>main</span><span>()</span></span> {
    <span><span>func</span><span>()</span></span> {
        fmt.Println(<span>"Анонимная функция!"</span>)
    }()
}
</code></div></div></pre></li><li><p><strong>Анонимная функция с параметром</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>main</span><span>()</span></span> {
    <span><span>func</span><span>(name <span>string</span>)</span></span> {
        fmt.Println(<span>"Привет,"</span>, name)
    }(<span>"Алексей"</span>)
}
</code></div></div></pre></li></ol><h4>Сложные задачи</h4><ol><li><strong>Анонимная функция, возвращающая результат</strong><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>main</span><span>()</span></span> {
    result := <span><span>func</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
        <span>return</span> a + b
    }(<span>3</span>, <span>4</span>)
    fmt.Println(result) <span>// Вывод: 7</span>
}
</code></div></div></pre></li></ol><h3>5. <strong>Рекурсивные функции</strong></h3><h4>Базовые задачи</h4><ol><li><strong>Рекурсия для вычисления факториала</strong><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>factorial</span><span>(n <span>int</span>)</span></span> <span>int</span> {
    <span>if</span> n == <span>0</span> {
        <span>return</span> <span>1</span>
    }
    <span>return</span> n * factorial(n<span>-1</span>)
}
</code></div></div></pre></li></ol><h4>Сложные задачи</h4><ol><li><strong>Ханойские башни</strong><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>hanoi</span><span>(n <span>int</span>, from, to, aux <span>string</span>)</span></span> {
    <span>if</span> n == <span>1</span> {
        fmt.Println(<span>"Переместите диск 1 с"</span>, from, <span>"на"</span>, to)
        <span>return</span>
    }
    hanoi(n<span>-1</span>, from, aux, to)
    fmt.Println(<span>"Переместите диск"</span>, n, <span>"с"</span>, from, <span>"на"</span>, to)
    hanoi(n<span>-1</span>, aux, to, from)
}
</code></div></div></pre></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div><div><svg width="41" height="41" viewBox="0 0 41 41" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-md" role="img"><text x="-9999" y="-9999"></text></svg></div></div></div></div></div><div><div><div><div dir="auto"><div><div><h3>6.</h3><h1 id="heading-14" class="numbered" data-id="14" style="--bg-color: red;">
DEFER И PANIC</h1><strong></strong><p><code>defer</code> используется для отложенного выполнения функции, а <code>panic</code> для обработки ошибок. Эти конструкции позволяют управлять потоком выполнения и управлять ресурсами более эффективно.</p><h4>Базовые задачи</h4><ol><li><p><strong>Пример использования <code>defer</code></strong></p><ul><li>Задача: Создайте функцию, которая использует <code>defer</code> для вывода сообщения перед завершением.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>deferredMessage</span><span>()</span></span> {
    <span>defer</span> fmt.Println(<span>"Функция завершена!"</span>)
    fmt.Println(<span>"Выполняется функция..."</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    deferredMessage()
}
</code></div></div></pre></li><li>Вывод:<pre><div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>Выполняется функция...
Функция завершена!
</code></div></div></pre></li></ul></li><li><p><strong>Использование нескольких <code>defer</code></strong></p><ul><li>Задача: Напишите функцию с несколькими <code>defer</code>.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>multiDefer</span><span>()</span></span> {
    <span>defer</span> fmt.Println(<span>"Первый отложенный вызов"</span>)
    <span>defer</span> fmt.Println(<span>"Второй отложенный вызов"</span>)
    fmt.Println(<span>"Основной код функции"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    multiDefer()
}
</code></div></div></pre></li><li>Вывод:<pre><div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>Основной код функции
Второй отложенный вызов
Первый отложенный вызов
</code></div></div></pre></li></ul></li><li><p><strong>Пример использования <code>panic</code></strong></p><ul><li>Задача: Напишите функцию, которая вызывает <code>panic</code> в случае деления на ноль.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>divide</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>if</span> b == <span>0</span> {
        <span>panic</span>(<span>"Деление на ноль!"</span>)
    }
    <span>return</span> a / b
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>defer</span> <span><span>func</span><span>()</span></span> {
        <span>if</span> r := <span>recover</span>(); r != <span>nil</span> {
            fmt.Println(<span>"Восстановление:"</span>, r)
        }
    }()
    fmt.Println(divide(<span>10</span>, <span>0</span>)) <span>// Пытаемся выполнить деление на ноль</span>
}
</code></div></div></pre></li><li>Вывод:<pre><div><div>makefile</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>Восстановление: Деление на ноль!</span>
</code></div></div></pre></li></ul></li><li><p><strong>Отложенные вызовы для освобождения ресурсов</strong></p><ul><li>Задача: Используйте <code>defer</code> для закрытия файла после его открытия.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    file, err := os.Open(<span>"example.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        <span>panic</span>(err)
    }
    <span>defer</span> file.Close() <span>// Закрытие файла отложено до выхода из функции main</span>
    fmt.Println(<span>"Файл открыт:"</span>, file.Name())
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование <code>defer</code> в сочетании с <code>recover</code></strong></p><ul><li>Задача: Используйте <code>defer</code> и <code>recover</code> для безопасного завершения программы при возникновении <code>panic</code>.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>riskyFunction</span><span>()</span></span> {
    <span>defer</span> <span><span>func</span><span>()</span></span> {
        <span>if</span> r := <span>recover</span>(); r != <span>nil</span> {
            fmt.Println(<span>"Произошла ошибка:"</span>, r)
        }
    }()
    <span>panic</span>(<span>"Неожиданная ошибка!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    riskyFunction()
    fmt.Println(<span>"Программа продолжается..."</span>)
}
</code></div></div></pre></li><li>Вывод:<pre><div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>Произошла ошибка: Неожиданная ошибка!
Программа продолжается...
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Логирование с использованием <code>defer</code></strong></p><ul><li>Задача: Создайте функцию логирования с отложенным выводом.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>logExecutionTime</span><span>(start time.Time)</span></span> {
    elapsed := time.Since(start)
    fmt.Printf(<span>"Время выполнения: %s\n"</span>, elapsed)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    start := time.Now()
    <span>defer</span> logExecutionTime(start)

    <span>// Имитируем длительную операцию</span>
    time.Sleep(<span>2</span> * time.Second)
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование <code>panic</code> для обработки ошибок</strong></p><ul><li>Задача: Используйте <code>panic</code> для обработки ошибок в глубоко вложенных функциях.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>nestedFunction</span><span>()</span></span> {
    <span>panic</span>(<span>"Произошла ошибка в вложенной функции"</span>)
}

<span><span>func</span> <span>outerFunction</span><span>()</span></span> {
    <span>defer</span> <span><span>func</span><span>()</span></span> {
        <span>if</span> r := <span>recover</span>(); r != <span>nil</span> {
            fmt.Println(<span>"Восстановление из:"</span>, r)
        }
    }()
    nestedFunction()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    outerFunction()
    fmt.Println(<span>"Программа продолжает выполняться"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отложенное освобождение ресурсов в сетевом приложении</strong></p><ul><li>Задача: Используйте <code>defer</code> для закрытия соединения с сервером.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>fetchData</span><span>(url <span>string</span>)</span></span> {
    response, err := http.Get(url)
    <span>if</span> err != <span>nil</span> {
        <span>panic</span>(err)
    }
    <span>defer</span> response.Body.Close() <span>// Закрываем тело ответа</span>
    fmt.Println(<span>"Статус кода:"</span>, response.Status)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fetchData(<span>"https://example.com"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Восстановление после нескольких ошибок</strong></p><ul><li>Задача: Создайте функцию, которая вызывает несколько <code>panic</code>, и восстановитесь после каждой.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>causePanic</span><span>(num <span>int</span>)</span></span> {
    <span>if</span> num == <span>0</span> {
        <span>panic</span>(<span>"Паника: деление на ноль!"</span>)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>for</span> i := <span>0</span>; i &lt; <span>3</span>; i++ {
        <span>defer</span> <span><span>func</span><span>(n <span>int</span>)</span></span> {
            <span>if</span> r := <span>recover</span>(); r != <span>nil</span> {
                fmt.Printf(<span>"Восстановление из: %v для %d\n"</span>, r, n)
            }
        }(i)
        causePanic(i) <span>// i = 0 вызовет панику</span>
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Паттерн "finally" с использованием <code>defer</code></strong></p><ul><li>Задача: Реализуйте паттерн "finally", чтобы гарантировать выполнение кода.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>defer</span> <span><span>func</span><span>()</span></span> {
        fmt.Println(<span>"Этот код выполнится в любом случае!"</span>)
    }()
    fmt.Println(<span>"Основной код функции."</span>)
}
</code></div></div></pre></li></ul></li></ol><h3>7. <strong><h1 id="heading-15" class="numbered" data-id="15" style="--bg-color: blue;">СРЕЗЫ</h1></strong></h3><p>Срезы в Go представляют собой динамические массивы, которые могут изменять свой размер.</p><h4>Базовые задачи</h4><ol><li><p><strong>Создание и инициализация среза</strong></p><ul><li>Задача: Создайте срез чисел и выведите его.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    fmt.Println(nums) <span>// Вывод: [1 2 3 4 5]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Длина и емкость среза</strong></p><ul><li>Задача: Выведите длину и емкость среза.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    fmt.Println(<span>"Длина:"</span>, <span>len</span>(nums)) <span>// Вывод: Длина: 5</span>
    fmt.Println(<span>"Емкость:"</span>, <span>cap</span>(nums)) <span>// Вывод: Емкость: 5</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Изменение элементов среза</strong></p><ul><li>Задача: Измените элемент среза и выведите его.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    nums[<span>2</span>] = <span>10</span>
    fmt.Println(nums) <span>// Вывод: [1 2 10 4 5]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Добавление элементов в срез</strong></p><ul><li>Задача: Используйте <code>append</code> для добавления элементов в срез.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    nums = <span>append</span>(nums, <span>4</span>, <span>5</span>)
    fmt.Println(nums) <span>// Вывод: [1 2 3 4 5]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Срезы с использованием функции <code>copy</code></strong></p><ul><li>Задача: Скопируйте элементы одного среза в другой.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums1 := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    nums2 := <span>make</span>([]<span>int</span>, <span>len</span>(nums1))
    <span>copy</span>(nums2, nums1)
    fmt.Println(nums2) <span>// Вывод: [1 2 3]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Срези и срезы срезов</strong></p><ul><li>Задача: Создайте срез из другого среза.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    subSlice := nums[<span>1</span>:<span>4</span>]
    fmt.Println(subSlice) <span>// Вывод: [2 3 4]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Объединение срезов</strong></p><ul><li>Задача: Объедините два среза.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums1 := []<span>int</span>{<span>1</span>, <span>2</span>}
    nums2 := []<span>int</span>{<span>3</span>, <span>4</span>}
    combined := <span>append</span>(nums1, nums2...) <span>// Используйте `...` для распаковки</span>
    fmt.Println(combined) <span>// Вывод: [1 2 3 4]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Цикл по срезу</strong></p><ul><li>Задача: Пройдитесь по элементам среза с использованием цикла <code>for</code>.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    <span>for</span> i, v := <span>range</span> nums {
        fmt.Printf(<span>"Индекс: %d, Значение: %d\n"</span>, i, v)
    }
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Функция, принимающая срез как параметр</strong></p><ul><li>Задача: Напишите функцию, которая принимает срез и возвращает его сумму.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>sum</span><span>(nums []<span>int</span>)</span></span> <span>int</span> {
    total := <span>0</span>
    <span>for</span> _, n := <span>range</span> nums {
        total += n
    }
    <span>return</span> total
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    fmt.Println(<span>"Сумма:"</span>, sum(nums)) <span>// Вывод: Сумма: 15</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция для фильтрации среза</strong></p><ul><li>Задача: Напишите функцию, которая фильтрует срез по условию.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>filter</span><span>(nums []<span>int</span>, condition <span>func</span>(<span>int</span>)</span></span> <span>bool</span>) []<span>int</span> {
    <span>var</span> result []<span>int</span>
    <span>for</span> _, n := <span>range</span> nums {
        <span>if</span> condition(n) {
            result = <span>append</span>(result, n)
        }
    }
    <span>return</span> result
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    evenNumbers := filter(nums, <span><span>func</span><span>(n <span>int</span>)</span></span> <span>bool</span> { <span>return</span> n%<span>2</span> == <span>0</span> })
    fmt.Println(<span>"Чётные числа:"</span>, evenNumbers) <span>// Вывод: Чётные числа: [2 4]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Сортировка среза</strong></p><ul><li>Задача: Используйте <code>sort</code> для сортировки среза.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sort"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>5</span>, <span>3</span>, <span>4</span>, <span>1</span>, <span>2</span>}
    sort.Ints(nums)
    fmt.Println(nums) <span>// Вывод: [1 2 3 4 5]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание среза из других срезов</strong></p><ul><li>Задача: Создайте срез, содержащий элементы двух других срезов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums1 := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    nums2 := []<span>int</span>{<span>4</span>, <span>5</span>, <span>6</span>}
    combined := <span>append</span>(nums1, nums2...)
    fmt.Println(combined) <span>// Вывод: [1 2 3 4 5 6]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция, возвращающая срез</strong></p><ul><li>Задача: Напишите функцию, которая возвращает новый срез с заданным диапазоном.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>createSlice</span><span>(start, end <span>int</span>)</span></span> []<span>int</span> {
    result := <span>make</span>([]<span>int</span>, end-start)
    <span>for</span> i := start; i &lt; end; i++ {
        result[i-start] = i
    }
    <span>return</span> result
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    slice := createSlice(<span>3</span>, <span>8</span>)
    fmt.Println(slice) <span>// Вывод: [3 4 5 6 7]</span>
}
</code></div></div></pre></li></ul></li></ol><h3>8. <strong><h1 id="heading-16" class="numbered" data-id="16" style="--bg-color: green;">ОТОБРАЖЕНИЯ (КАРТЫ)</h1></strong></h3><p>Отображения — это неупорядоченные коллекции пар ключ-значение.</p><h4>Базовые задачи</h4><ol><li><p><strong>Создание и инициализация отображения</strong></p><ul><li>Задача: Создайте отображение и выведите его.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    myMap := <span>map</span>[<span>string</span>]<span>int</span>{<span>"a"</span>: <span>1</span>, <span>"b"</span>: <span>2</span>}
    fmt.Println(myMap) <span>// Вывод: map[a:1 b:2]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Добавление и изменение элементов в отображении</strong></p><ul><li>Задача: Измените значение ключа в отображении.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    myMap := <span>map</span>[<span>string</span>]<span>int</span>{<span>"a"</span>: <span>1</span>, <span>"b"</span>: <span>2</span>}
    myMap[<span>"a"</span>] = <span>3</span>
    fmt.Println(myMap) <span>// Вывод: map[a:3 b:2]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Удаление элемента из отображения</strong></p><ul><li>Задача: Удалите элемент из отображения.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    myMap := <span>map</span>[<span>string</span>]<span>int</span>{<span>"a"</span>: <span>1</span>, <span>"b"</span>: <span>2</span>}
    <span>delete</span>(myMap, <span>"b"</span>)
    fmt.Println(myMap) <span>// Вывод: map[a:1]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Проверка наличия ключа в отображении</strong></p><ul><li>Задача: Проверьте, существует ли ключ в отображении.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    myMap := <span>map</span>[<span>string</span>]<span>int</span>{<span>"a"</span>: <span>1</span>, <span>"b"</span>: <span>2</span>}
    value, exists := myMap[<span>"c"</span>]
    fmt.Println(value, exists) <span>// Вывод: 0 false</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Итерация по элементам отображения</strong></p><ul><li>Задача: Пройдитесь по всем элементам отображения.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    myMap := <span>map</span>[<span>string</span>]<span>int</span>{<span>"a"</span>: <span>1</span>, <span>"b"</span>: <span>2</span>}
    <span>for</span> key, value := <span>range</span> myMap {
        fmt.Printf(<span>"Ключ: %s, Значение: %d\n"</span>, key, value)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Инициализация пустого отображения</strong></p><ul><li>Задача: Создайте пустое отображение и добавьте элементы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    myMap := <span>make</span>(<span>map</span>[<span>string</span>]<span>int</span>)
    myMap[<span>"a"</span>] = <span>1</span>
    myMap[<span>"b"</span>] = <span>2</span>
    fmt.Println(myMap) <span>// Вывод: map[a:1 b:2]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Копирование отображения</strong></p><ul><li>Задача: Напишите функцию для копирования отображения.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>copyMap</span><span>(original <span>map</span>[<span>string</span>]<span>int</span>)</span></span> <span>map</span>[<span>string</span>]<span>int</span> {
    newMap := <span>make</span>(<span>map</span>[<span>string</span>]<span>int</span>)
    <span>for</span> k, v := <span>range</span> original {
        newMap[k] = v
    }
    <span>return</span> newMap
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    myMap := <span>map</span>[<span>string</span>]<span>int</span>{<span>"a"</span>: <span>1</span>, <span>"b"</span>: <span>2</span>}
    newMap := copyMap(myMap)
    fmt.Println(newMap) <span>// Вывод: map[a:1 b:2]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Объединение двух отображений</strong></p><ul><li>Задача: Объедините два отображения.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    map1 := <span>map</span>[<span>string</span>]<span>int</span>{<span>"a"</span>: <span>1</span>, <span>"b"</span>: <span>2</span>}
    map2 := <span>map</span>[<span>string</span>]<span>int</span>{<span>"b"</span>: <span>3</span>, <span>"c"</span>: <span>4</span>}
    <span>for</span> k, v := <span>range</span> map2 {
        map1[k] = v <span>// Если ключ существует, обновит значение</span>
    }
    fmt.Println(map1) <span>// Вывод: map[a:1 b:3 c:4]</span>
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Функция для подсчета частоты элементов</strong></p><ul><li>Задача: Напишите функцию, которая подсчитывает частоту появления элементов в срезе.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>countFrequencies</span><span>(arr []<span>string</span>)</span></span> <span>map</span>[<span>string</span>]<span>int</span> {
    frequency := <span>make</span>(<span>map</span>[<span>string</span>]<span>int</span>)
    <span>for</span> _, v := <span>range</span> arr {
        frequency[v]++
    }
    <span>return</span> frequency
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := []<span>string</span>{<span>"apple"</span>, <span>"banana"</span>, <span>"apple"</span>, <span>"orange"</span>, <span>"banana"</span>, <span>"apple"</span>}
    freq := countFrequencies(arr)
    fmt.Println(freq) <span>// Вывод: map[apple:3 banana:2 orange:1]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Группировка элементов по значению</strong></p><ul><li>Задача: Группируйте элементы по значению в отображении.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>groupByValue</span><span>(items <span>map</span>[<span>string</span>]<span>int</span>)</span></span> <span>map</span>[<span>int</span>][]<span>string</span> {
    grouped := <span>make</span>(<span>map</span>[<span>int</span>][]<span>string</span>)
    <span>for</span> k, v := <span>range</span> items {
        grouped[v] = <span>append</span>(grouped[v], k)
    }
    <span>return</span> grouped
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    items := <span>map</span>[<span>string</span>]<span>int</span>{<span>"apple"</span>: <span>1</span>, <span>"banana"</span>: <span>2</span>, <span>"orange"</span>: <span>1</span>}
    grouped := groupByValue(items)
    fmt.Println(grouped) <span>// Вывод: map[1:[apple orange] 2:[banana]]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Поиск максимального значения в отображении</strong></p><ul><li>Задача: Найдите элемент с максимальным значением в отображении.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>findMaxValue</span><span>(m <span>map</span>[<span>string</span>]<span>int</span>)</span></span> (<span>string</span>, <span>int</span>) {
    maxKey := <span>""</span>
    maxValue := <span>0</span>
    <span>for</span> k, v := <span>range</span> m {
        <span>if</span> v &gt; maxValue {
            maxValue = v
            maxKey = k
        }
    }
    <span>return</span> maxKey, maxValue
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    myMap := <span>map</span>[<span>string</span>]<span>int</span>{<span>"a"</span>: <span>5</span>, <span>"b"</span>: <span>3</span>, <span>"c"</span>: <span>8</span>}
    key, value := findMaxValue(myMap)
    fmt.Printf(<span>"Ключ с максимальным значением: %s, Значение: %d\n"</span>, key, value) <span>// Вывод: Ключ с максимальным значением: c, Значение: 8</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание отображения из двух срезов</strong></p><ul><li>Задача: Создайте отображение из двух срезов — ключей и значений.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>createMap</span><span>(keys []<span>string</span>, values []<span>int</span>)</span></span> <span>map</span>[<span>string</span>]<span>int</span> {
    result := <span>make</span>(<span>map</span>[<span>string</span>]<span>int</span>)
    <span>for</span> i := <span>0</span>; i &lt; <span>len</span>(keys); i++ {
        result[keys[i]] = values[i]
    }
    <span>return</span> result
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    keys := []<span>string</span>{<span>"a"</span>, <span>"b"</span>, <span>"c"</span>}
    values := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    myMap := createMap(keys, values)
    fmt.Println(myMap) <span>// Вывод: map[a:1 b:2 c:3]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Сортировка ключей отображения</strong></p><ul><li>Задача: Отсортируйте ключи отображения и выведите их.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sort"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    myMap := <span>map</span>[<span>string</span>]<span>int</span>{<span>"b"</span>: <span>2</span>, <span>"a"</span>: <span>1</span>, <span>"c"</span>: <span>3</span>}
    keys := <span>make</span>([]<span>string</span>, <span>0</span>, <span>len</span>(myMap))
    <span>for</span> k := <span>range</span> myMap {
        keys = <span>append</span>(keys, k)
    }
    sort.Strings(keys)
    <span>for</span> _, k := <span>range</span> keys {
        fmt.Printf(<span>"Ключ: %s, Значение: %d\n"</span>, k, myMap[k])
    }
}
</code></div></div></pre></li></ul></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h3> </h3><h1 id="heading-17" class="numbered" data-id="17" style="--bg-color: orange;">
УКАЗАТЕЛИ</h1><p>Указатели в Go позволяют хранить адреса других переменных, а не их значения. Это может быть полезно для оптимизации использования памяти и для изменения значений переменных в функциях.</p><h4>Базовые задачи</h4><ol><li><p><strong>Создание указателя</strong></p><ul><li>Задача: Создайте указатель на переменную и выведите его значение.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> x <span>int</span> = <span>42</span>
    <span>var</span> p *<span>int</span> = &amp;x <span>// Указатель p указывает на адрес переменной x</span>
    fmt.Println(*p)  <span>// Вывод: 42 (разыменование указателя)</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Изменение значения через указатель</strong></p><ul><li>Задача: Измените значение переменной через указатель.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> x <span>int</span> = <span>10</span>
    <span>var</span> p *<span>int</span> = &amp;x
    *p = <span>20</span> <span>// Изменяем значение переменной x через указатель p</span>
    fmt.Println(x) <span>// Вывод: 20</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Нулевой указатель</strong></p><ul><li>Задача: Проверьте, является ли указатель нулевым.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> p *<span>int</span>
    <span>if</span> p == <span>nil</span> {
        fmt.Println(<span>"Указатель нулевой"</span>) <span>// Вывод: Указатель нулевой</span>
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Передача указателя в функцию</strong></p><ul><li>Задача: Передайте указатель в функцию и измените значение переменной.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>modifyValue</span><span>(p *<span>int</span>)</span></span> {
    *p = <span>100</span> <span>// Изменяем значение переменной через указатель</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    x := <span>50</span>
    modifyValue(&amp;x) <span>// Передаем адрес переменной x</span>
    fmt.Println(x)  <span>// Вывод: 100</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Указатель на массив</strong></p><ul><li>Задача: Создайте указатель на массив и измените его элементы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>modifyArray</span><span>(arr *[3]<span>int</span>)</span></span> {
    (*arr)[<span>0</span>] = <span>10</span> <span>// Изменяем первый элемент массива</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := [<span>3</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    modifyArray(&amp;arr) <span>// Передаем указатель на массив</span>
    fmt.Println(arr)  <span>// Вывод: [10 2 3]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Указатель на структуру</strong></p><ul><li>Задача: Используйте указатель на структуру и измените одно из её полей.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>updateAge</span><span>(p *Person)</span></span> {
    p.Age = <span>30</span> <span>// Изменяем возраст человека</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    person := Person{Name: <span>"Alice"</span>, Age: <span>25</span>}
    updateAge(&amp;person) <span>// Передаем указатель на структуру</span>
    fmt.Println(person) <span>// Вывод: {Alice 30}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Сравнение указателей</strong></p><ul><li>Задача: Сравните два указателя.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    a := <span>1</span>
    b := <span>1</span>
    p1 := &amp;a
    p2 := &amp;b
    fmt.Println(p1 == p2) <span>// Вывод: false (разные адреса в памяти)</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Указатели на срезы</strong></p><ul><li>Задача: Передайте указатель на срез в функцию и измените его элементы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>modifySlice</span><span>(s *[]<span>int</span>)</span></span> {
    (*s)[<span>0</span>] = <span>42</span> <span>// Изменяем первый элемент среза</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    modifySlice(&amp;nums) <span>// Передаем указатель на срез</span>
    fmt.Println(nums)  <span>// Вывод: [42 2 3]</span>
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Указатель на указатель</strong></p><ul><li>Задача: Используйте указатель на указатель для изменения значения переменной.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>modifyValue</span><span>(p **<span>int</span>)</span></span> {
    **p = <span>200</span> <span>// Изменяем значение через указатель на указатель</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    x := <span>100</span>
    p1 := &amp;x
    p2 := &amp;p1
    modifyValue(p2) <span>// Передаем указатель на указатель</span>
    fmt.Println(x)  <span>// Вывод: 200</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Функция, возвращающая указатель</strong></p><ul><li>Задача: Напишите функцию, которая создает и возвращает указатель на переменную.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>createPointer</span><span>()</span></span> *<span>int</span> {
    x := <span>42</span>
    <span>return</span> &amp;x <span>// Возвращаем адрес локальной переменной (это небезопасно)</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := createPointer()
    fmt.Println(*p) <span>// Это может вызвать неопределённое поведение!</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Указатели в рекурсивной функции</strong></p><ul><li>Задача: Используйте указатели в рекурсивной функции для вычисления факториала.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>factorial</span><span>(n <span>int</span>, result *<span>int</span>)</span></span> {
    <span>if</span> n == <span>0</span> {
        *result = <span>1</span>
        <span>return</span>
    }
    factorial(n<span>-1</span>, result)
    *result *= n
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> result <span>int</span>
    factorial(<span>5</span>, &amp;result)
    fmt.Println(result) <span>// Вывод: 120</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Сравнение двух массивов с использованием указателей</strong></p><ul><li>Задача: Напишите функцию, которая сравнивает два массива по адресу.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>compareArrays</span><span>(arr1 *[3]<span>int</span>, arr2 *[3]<span>int</span>)</span></span> <span>bool</span> {
    <span>for</span> i := <span>0</span>; i &lt; <span>len</span>(arr1); i++ {
        <span>if</span> (*arr1)[i] != (*arr2)[i] {
            <span>return</span> <span>false</span>
        }
    }
    <span>return</span> <span>true</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    a := [<span>3</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    b := [<span>3</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    fmt.Println(compareArrays(&amp;a, &amp;b)) <span>// Вывод: true</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание динамического массива с использованием указателей</strong></p><ul><li>Задача: Реализуйте динамический массив с использованием указателей.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> DynamicArray <span>struct</span> {
    data  []<span>int</span>
    count <span>int</span>
}

<span><span>func</span> <span>(da *DynamicArray)</span></span> <span>append</span>(value <span>int</span>) {
    da.data = <span>append</span>(da.data, value)
    da.count++
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    arr := DynamicArray{}
    arr.<span>append</span>(<span>1</span>)
    arr.<span>append</span>(<span>2</span>)
    arr.<span>append</span>(<span>3</span>)
    fmt.Println(arr.data) <span>// Вывод: [1 2 3]</span>
}
</code></div></div></pre></li></ul></li></ol><h3></h3><h1 id="heading-18" class="numbered" data-id="18" style="--bg-color: purple;">УКАЗАТЕЛИ И ФУНКЦИИ</h1><p>Указатели в функциях позволяют изменять значения переменных, переданных в функцию, не создавая их копий.</p><h4>Базовые задачи</h4><ol><li><p><strong>Передача указателя в функцию для изменения значения</strong></p><ul><li>Задача: Напишите функцию, которая увеличивает значение переменной на 10.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>increment</span><span>(n *<span>int</span>)</span></span> {
    *n += <span>10</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    x := <span>5</span>
    increment(&amp;x) <span>// Передаем адрес переменной x</span>
    fmt.Println(x) <span>// Вывод: 15</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Указатели и массивы в функциях</strong></p><ul><li>Задача: Передайте массив в функцию и измените его элементы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>modifyArray</span><span>(arr *[3]<span>int</span>)</span></span> {
    (*arr)[<span>0</span>] = <span>100</span> <span>// Изменяем первый элемент массива</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    nums := [<span>3</span>]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}
    modifyArray(&amp;nums) <span>// Передаем указатель на массив</span>
    fmt.Println(nums)  <span>// Вывод: [100 2 3]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Указатели и структуры в функциях</strong></p><ul><li>Задача: Передайте указатель на структуру и измените одно из её полей.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Rectangle <span>struct</span> {
    Width, Height <span>int</span>
}

<span><span>func</span> <span>resize</span><span>(r *Rectangle, newWidth <span>int</span>, newHeight <span>int</span>)</span></span> {
    r.Width = newWidth
    r.Height = newHeight
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rect := Rectangle{Width: <span>5</span>, Height: <span>10</span>}
    resize(&amp;rect, <span>20</span>, <span>30</span>) <span>// Передаем указатель на структуру</span>
    fmt.Println(rect)     <span>// Вывод: {20 30}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Передача указателя на функцию</strong></p><ul><li>Задача: Напишите функцию, которая принимает указатель на функцию и вызывает её.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>greet</span><span>()</span></span> {
    fmt.Println(<span>"Hello!"</span>)
}

<span><span>func</span> <span>callFunction</span><span>(fn *<span>func</span>()</span></span>) {
    (*fn)() <span>// Вызываем функцию по указателю</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    callFunction(&amp;greet) <span>// Передаем указатель на функцию greet</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Указатели в возврате из функции</strong></p><ul><li>Задача: Напишите функцию, которая возвращает указатель на переменную.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>newInt</span><span>(value <span>int</span>)</span></span> *<span>int</span> {
    <span>return</span> &amp;value <span>// Возвращаем указатель на локальную переменную (небезопасно)</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := newInt(<span>42</span>)
    fmt.Println(*p) <span>// Это может вызвать неопределённое поведение!</span>
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Функция, работающая с указателями и возвратом значений</strong></p><ul><li>Задача: Напишите функцию, которая принимает два указателя и меняет их значения.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>swap</span><span>(a *<span>int</span>, b *<span>int</span>)</span></span> {
    temp := *a
    *a = *b
    *b = temp
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    x, y := <span>1</span>, <span>2</span>
    swap(&amp;x, &amp;y) <span>// Передаем указатели на x и y</span>
    fmt.Println(x, y) <span>// Вывод: 2 1</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание структуры с указателями</strong></p><ul><li>Задача: Создайте структуру, содержащую указатели на другие структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Address <span>struct</span> {
    City  <span>string</span>
    State <span>string</span>
}

<span>type</span> Person <span>struct</span> {
    Name    <span>string</span>
    Address *Address <span>// Указатель на структуру Address</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    addr := &amp;Address{City: <span>"New York"</span>, State: <span>"NY"</span>}
    person := Person{Name: <span>"John"</span>, Address: addr}
    fmt.Println(person) <span>// Вывод: {John 0xc00000c0b0}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Указатели и интерфейсы</strong></p><ul><li>Задача: Используйте указатели для реализации интерфейса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Speaker <span>interface</span> {
    Speak() <span>string</span>
}

<span>type</span> Dog <span>struct</span> {
    Name <span>string</span>
}

<span><span>func</span> <span>(d *Dog)</span></span> Speak() <span>string</span> {
    <span>return</span> <span>"Woof!"</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    dog := &amp;Dog{Name: <span>"Buddy"</span>}
    <span>var</span> speaker Speaker = dog <span>// Указатель на Dog реализует интерфейс Speaker</span>
    fmt.Println(speaker.Speak()) <span>// Вывод: Woof!</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Генерация уникальных идентификаторов с помощью указателей</strong></p><ul><li>Задача: Реализуйте функцию, которая генерирует уникальные идентификаторы и возвращает указатель на последний созданный.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>var</span> currentID <span>int</span>

<span><span>func</span> <span>newID</span><span>()</span></span> *<span>int</span> {
    currentID++
    <span>return</span> &amp;currentID <span>// Возвращаем указатель на текущий ID</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    id1 := newID()
    id2 := newID()
    fmt.Println(*id1, *id2) <span>// Вывод: 1 2</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Структуры и указатели в вложенных функциях</strong></p><ul><li>Задача: Напишите структуру с методом, который использует указатель на структуру.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Counter <span>struct</span> {
    Count <span>int</span>
}

<span><span>func</span> <span>(c *Counter)</span></span> Increment() {
    c.Count++
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    counter := Counter{}
    counter.Increment() <span>// Увеличиваем счетчик</span>
    fmt.Println(counter.Count) <span>// Вывод: 1</span>
}
</code></div></div></pre></li></ul></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><h2></h2><h1 id="heading-19" class="numbered" data-id="19" style="--bg-color: pink;">ИМЕНОВАННЫЕ ТИПЫ И ПСЕВДОНИМЫ</h1><p>Именованные типы позволяют создавать новые типы данных, основанные на существующих. Псевдонимы же позволяют создавать более удобные названия для существующих типов.</p><h3>Базовые задачи</h3><ol><li><p><strong>Создание именованного типа</strong></p><ul><li>Задача: Создайте именованный тип для представления расстояния в километрах.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Kilometers <span>float64</span> <span>// Именованный тип для расстояния</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> distance Kilometers = <span>5.0</span>
    fmt.Println(distance) <span>// Вывод: 5</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание псевдонима типа</strong></p><ul><li>Задача: Создайте псевдоним для типа <code>string</code> для представления имен пользователей.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> UserName <span>string</span> <span>// Псевдоним для типа string</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> user UserName = <span>"Alice"</span>
    fmt.Println(user) <span>// Вывод: Alice</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование именованного типа в функции</strong></p><ul><li>Задача: Напишите функцию, принимающую именованный тип в качестве параметра.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Meters <span>float64</span>

<span><span>func</span> <span>printDistance</span><span>(d Meters)</span></span> {
    fmt.Println(<span>"Расстояние:"</span>, d)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> distance Meters = <span>100.5</span>
    printDistance(distance) <span>// Вывод: Расстояние: 100.5</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Сравнение именованных типов</strong></p><ul><li>Задача: Сравните два именованных типа.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Celsius <span>float64</span>
<span>type</span> Fahrenheit <span>float64</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> temp1 Celsius = <span>25.0</span>
    <span>var</span> temp2 Celsius = <span>30.0</span>
    fmt.Println(temp1 &lt; temp2) <span>// Вывод: true</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Преобразование между типами</strong></p><ul><li>Задача: Преобразуйте именованный тип в другой тип.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Grams <span>float64</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> weight Grams = <span>500.0</span>
    <span>var</span> weightInKilograms <span>float64</span> = <span>float64</span>(weight) / <span>1000.0</span>
    fmt.Println(weightInKilograms) <span>// Вывод: 0.5</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание именованного типа для структуры</strong></p><ul><li>Задача: Создайте именованный тип для структуры, представляющей точку на 2D-плоскости.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Point <span>struct</span> {
    X, Y <span>float64</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := Point{X: <span>3.5</span>, Y: <span>4.2</span>}
    fmt.Println(p) <span>// Вывод: {3.5 4.2}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Определение метода для именованного типа</strong></p><ul><li>Задача: Создайте метод для именованного типа, который вычисляет длину окружности.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Radius <span>float64</span>

<span><span>func</span> <span>(r Radius)</span></span> Circumference() <span>float64</span> {
    <span>return</span> <span>2</span> * <span>3.14</span> * <span>float64</span>(r)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := Radius(<span>5</span>)
    fmt.Println(r.Circumference()) <span>// Вывод: 31.400000000000002</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование псевдонима типа в структурных полях</strong></p><ul><li>Задача: Используйте псевдоним типа в качестве поля структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Price <span>float64</span>
<span>type</span> Product <span>struct</span> {
    Name  <span>string</span>
    Cost  Price
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := Product{Name: <span>"Laptop"</span>, Cost: <span>999.99</span>}
    fmt.Println(p) <span>// Вывод: {Laptop 999.99}</span>
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Пользовательские методы для именованного типа</strong></p><ul><li>Задача: Реализуйте метод, который возвращает строку в формате "Градусы Цельсия".</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Celsius <span>float64</span>

<span><span>func</span> <span>(c Celsius)</span></span> String() <span>string</span> {
    <span>return</span> fmt.Sprintf(<span>"%.2f °C"</span>, c)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    temp := Celsius(<span>25.0</span>)
    fmt.Println(temp) <span>// Вывод: 25.00 °C</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование именованного типа в сложных структурах</strong></p><ul><li>Задача: Создайте структуру для представления информации о книге.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> ISBN <span>string</span>

<span>type</span> Book <span>struct</span> {
    Title  <span>string</span>
    Author <span>string</span>
    ISBN   ISBN
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    book := Book{Title: <span>"Go Programming"</span>, Author: <span>"John Doe"</span>, ISBN: <span>"123-456-789"</span>}
    fmt.Println(book) <span>// Вывод: {Go Programming John Doe 123-456-789}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Псевдонимы для интерфейсов</strong></p><ul><li>Задача: Создайте псевдоним для интерфейса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}

<span>type</span> Circle <span>struct</span> {
    Radius <span>float64</span>
}

<span><span>func</span> <span>(c Circle)</span></span> Area() <span>float64</span> {
    <span>return</span> <span>3.14</span> * c.Radius * c.Radius
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> s Shape = Circle{Radius: <span>5</span>}
    fmt.Println(<span>"Площадь круга:"</span>, s.Area()) <span>// Вывод: Площадь круга: 78.5</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование именованных типов в коллекциях</strong></p><ul><li>Задача: Создайте коллекцию книг и напишите функцию для её обработки.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Book <span>struct</span> {
    Title  <span>string</span>
    Author <span>string</span>
}

<span><span>func</span> <span>printBooks</span><span>(books []Book)</span></span> {
    <span>for</span> _, book := <span>range</span> books {
        fmt.Printf(<span>"Title: %s, Author: %s\n"</span>, book.Title, book.Author)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    books := []Book{
        {<span>"Go Programming"</span>, <span>"John Doe"</span>},
        {<span>"Learn Python"</span>, <span>"Jane Doe"</span>},
    }
    printBooks(books)
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы для псевдонимов</strong></p><ul><li>Задача: Реализуйте метод для псевдонима, который возвращает процентное соотношение.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Percentage <span>float64</span>

<span><span>func</span> <span>(p Percentage)</span></span> ToFraction() <span>float64</span> {
    <span>return</span> <span>float64</span>(p) / <span>100</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := Percentage(<span>75</span>)
    fmt.Println(<span>"В долях:"</span>, p.ToFraction()) <span>// Вывод: В долях: 0.75</span>
}
</code></div></div></pre></li></ul></li></ol><h2></h2><h1 id="heading-20" class="numbered" data-id="20" style="--bg-color: red;">СТРУКТУРЫ</h1><p>Структуры — это составные типы данных, которые позволяют группировать переменные (поля) под одним именем.</p><h3>Базовые задачи</h3><ol><li><p><strong>Создание структуры</strong></p><ul><li>Задача: Создайте структуру для представления человека.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    person := Person{Name: <span>"Alice"</span>, Age: <span>30</span>}
    fmt.Println(person) <span>// Вывод: {Alice 30}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Инициализация структуры</strong></p><ul><li>Задача: Инициализируйте структуру с использованием литералов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Car <span>struct</span> {
    Brand <span>string</span>
    Year  <span>int</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    car := Car{<span>"Toyota"</span>, <span>2020</span>}
    fmt.Println(car) <span>// Вывод: {Toyota 2020}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Обновление полей структуры</strong></p><ul><li>Задача: Измените поле структуры после её создания.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Book <span>struct</span> {
    Title  <span>string</span>
    Author <span>string</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    book := Book{Title: <span>"1984"</span>, Author: <span>"George Orwell"</span>}
    book.Author = <span>"Orwell"</span>
    fmt.Println(book) <span>// Вывод: {1984 Orwell}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание массива структур</strong></p><ul><li>Задача: Создайте массив структур и итерируйтесь по нему.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Student <span>struct</span> {
    Name  <span>string</span>
    Grade <span>int</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    students := []Student{
        {<span>"Alice"</span>, <span>90</span>},
        {<span>"Bob"</span>, <span>85</span>},
    }
    <span>for</span> _, student := <span>range</span> students {
        fmt.Println(student.Name, <span>":"</span>, student.Grade)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы структуры</strong></p><ul><li>Задача: Реализуйте метод для структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Rectangle <span>struct</span> {
    Width, Height <span>float64</span>
}

<span><span>func</span> <span>(r Rectangle)</span></span> Area() <span>float64</span> {
    <span>return</span> r.Width * r.Height
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rect := Rectangle{Width: <span>5</span>, Height: <span>3</span>}
    fmt.Println(<span>"Area:"</span>, rect.Area()) <span>// Вывод: Area: 15</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Передача структуры в функцию</strong></p><ul><li>Задача: Передайте структуру в функцию и измените её поля.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Circle <span>struct</span> {
    Radius <span>float64</span>
}

<span><span>func</span> <span>changeRadius</span><span>(c Circle)</span></span> {
    c.Radius = <span>10</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    circle := Circle{Radius: <span>5</span>}
    changeRadius(circle)
    fmt.Println(circle.Radius) <span>// Вывод: 5 (не изменилось)</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Передача указателя на структуру</strong></p><ul><li>Задача: Передайте указатель на структуру в функцию для изменения её полей.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Circle <span>struct</span> {
    Radius <span>float64</span>
}

<span><span>func</span> <span>changeRadius</span><span>(c *Circle)</span></span> {
    c.Radius = <span>10</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    circle := Circle{Radius: <span>5</span>}
    changeRadius(&amp;circle) <span>// Передаем указатель</span>
    fmt.Println(circle.Radius) <span>// Вывод: 10</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Вложенная структура</strong></p><ul><li>Задача: Создайте структуру, содержащую другую структуру.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Address <span>struct</span> {
    City, Country <span>string</span>
}

<span>type</span> Person <span>struct</span> {
    Name    <span>string</span>
    Age     <span>int</span>
    Address Address
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    person := Person{Name: <span>"Alice"</span>, Age: <span>30</span>, Address: Address{<span>"New York"</span>, <span>"USA"</span>}}
    fmt.Println(person) <span>// Вывод: {Alice 30 {New York USA}}</span>
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Структура с методами и вложенными структурами</strong></p><ul><li>Задача: Создайте структуру для представления автомобиля с вложенной структурой для двигателя.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Engine <span>struct</span> {
    Power <span>int</span>
}

<span>type</span> Car <span>struct</span> {
    Brand  <span>string</span>
    Engine Engine
}

<span><span>func</span> <span>(c Car)</span></span> Info() <span>string</span> {
    <span>return</span> fmt.Sprintf(<span>"Car: %s, Engine Power: %d"</span>, c.Brand, c.Engine.Power)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    car := Car{Brand: <span>"Toyota"</span>, Engine: Engine{Power: <span>150</span>}}
    fmt.Println(car.Info()) <span>// Вывод: Car: Toyota, Engine Power: 150</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы с возвратом значений</strong></p><ul><li>Задача: Реализуйте метод, который возвращает площадь прямоугольника.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Rectangle <span>struct</span> {
    Width, Height <span>float64</span>
}

<span><span>func</span> <span>(r Rectangle)</span></span> Area() <span>float64</span> {
    <span>return</span> r.Width * r.Height
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rect := Rectangle{Width: <span>4</span>, Height: <span>5</span>}
    fmt.Println(<span>"Area:"</span>, rect.Area()) <span>// Вывод: Area: 20</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Итерация по полям структуры</strong></p><ul><li>Задача: Напишите функцию, которая принимает структуру и итерируется по её полям с использованием рефлексии.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>printFields</span><span>(v <span>interface</span>{})</span></span> {
    value := reflect.ValueOf(v)
    <span>for</span> i := <span>0</span>; i &lt; value.NumField(); i++ {
        fmt.Println(value.Type().Field(i).Name, <span>":"</span>, value.Field(i))
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    person := Person{Name: <span>"Alice"</span>, Age: <span>30</span>}
    printFields(person)
    <span>// Вывод:</span>
    <span>// Name : Alice</span>
    <span>// Age : 30</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Сериализация структуры</strong></p><ul><li>Задача: Напишите функцию, которая сериализует структуру в JSON.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"encoding/json"</span>
    <span>"fmt"</span>
)

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    person := Person{Name: <span>"Alice"</span>, Age: <span>30</span>}
    data, _ := json.Marshal(person)
    fmt.Println(<span>string</span>(data)) <span>// Вывод: {"Name":"Alice","Age":30}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Сравнение двух структур</strong></p><ul><li>Задача: Напишите функцию, которая сравнивает два объекта структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>areEqual</span><span>(p1, p2 Person)</span></span> <span>bool</span> {
    <span>return</span> p1 == p2
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    person1 := Person{Name: <span>"Alice"</span>, Age: <span>30</span>}
    person2 := Person{Name: <span>"Alice"</span>, Age: <span>30</span>}
    fmt.Println(areEqual(person1, person2)) <span>// Вывод: true</span>
}
</code></div></div></pre></li></ul></li></ol><h2></h2><h1 id="heading-21" class="numbered" data-id="21" style="--bg-color: blue;">ВЛОЖЕННЫЕ СТРУКТУРЫ</h1><p>Вложенные структуры позволяют создать иерархию данных, что может быть полезно для моделирования сложных объектов.</p><h3>Базовые задачи</h3><ol><li><p><strong>Создание вложенной структуры</strong></p><ul><li>Задача: Создайте структуру для представления заказа с вложенной структурой для деталей заказа.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Item <span>struct</span> {
    Name  <span>string</span>
    Price <span>float64</span>
}

<span>type</span> Order <span>struct</span> {
    ID    <span>int</span>
    Items []Item
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    order := Order{ID: <span>1</span>, Items: []Item{{Name: <span>"Laptop"</span>, Price: <span>999.99</span>}}}
    fmt.Println(order) <span>// Вывод: {1 [{Laptop 999.99}]}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Инициализация вложенных структур</strong></p><ul><li>Задача: Инициализируйте вложенные структуры с использованием литералов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Address <span>struct</span> {
    City, Country <span>string</span>
}

<span>type</span> Person <span>struct</span> {
    Name    <span>string</span>
    Age     <span>int</span>
    Address Address
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    person := Person{Name: <span>"Alice"</span>, Age: <span>30</span>, Address: Address{<span>"New York"</span>, <span>"USA"</span>}}
    fmt.Println(person) <span>// Вывод: {Alice 30 {New York USA}}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Доступ к полям вложенной структуры</strong></p><ul><li>Задача: Измените поле вложенной структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Address <span>struct</span> {
    City, Country <span>string</span>
}

<span>type</span> Person <span>struct</span> {
    Name    <span>string</span>
    Age     <span>int</span>
    Address Address
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    person := Person{Name: <span>"Alice"</span>, Age: <span>30</span>, Address: Address{<span>"New York"</span>, <span>"USA"</span>}}
    person.Address.City = <span>"Los Angeles"</span>
    fmt.Println(person) <span>// Вывод: {Alice 30 {Los Angeles USA}}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы вложенной структуры</strong></p><ul><li>Задача: Реализуйте метод для вложенной структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Address <span>struct</span> {
    City, Country <span>string</span>
}

<span><span>func</span> <span>(a Address)</span></span> FullAddress() <span>string</span> {
    <span>return</span> fmt.Sprintf(<span>"%s, %s"</span>, a.City, a.Country)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    addr := Address{<span>"New York"</span>, <span>"USA"</span>}
    fmt.Println(addr.FullAddress()) <span>// Вывод: New York, USA</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Итерация по вложенным структурам</strong></p><ul><li>Задача: Напишите функцию, которая принимает структуру с вложенными структурами и итерируется по ней.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Item <span>struct</span> {
    Name  <span>string</span>
    Price <span>float64</span>
}

<span>type</span> Order <span>struct</span> {
    ID    <span>int</span>
    Items []Item
}

<span><span>func</span> <span>printOrder</span><span>(o Order)</span></span> {
    fmt.Println(<span>"Order ID:"</span>, o.ID)
    <span>for</span> _, item := <span>range</span> o.Items {
        fmt.Printf(<span>"Item: %s, Price: %.2f\n"</span>, item.Name, item.Price)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    order := Order{ID: <span>1</span>, Items: []Item{{Name: <span>"Laptop"</span>, Price: <span>999.99</span>}}}
    printOrder(order)
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование вложенных структур в массиве</strong></p><ul><li>Задача: Создайте массив заказов, каждый из которых содержит список товаров.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Item <span>struct</span> {
    Name  <span>string</span>
    Price <span>float64</span>
}

<span>type</span> Order <span>struct</span> {
    ID    <span>int</span>
    Items []Item
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    orders := []Order{
        {ID: <span>1</span>, Items: []Item{{Name: <span>"Laptop"</span>, Price: <span>999.99</span>}}},
        {ID: <span>2</span>, Items: []Item{{Name: <span>"Phone"</span>, Price: <span>499.99</span>}}},
    }
    <span>for</span> _, order := <span>range</span> orders {
        fmt.Println(<span>"Order ID:"</span>, order.ID)
        <span>for</span> _, item := <span>range</span> order.Items {
            fmt.Printf(<span>"Item: %s, Price: %.2f\n"</span>, item.Name, item.Price)
        }
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Сравнение вложенных структур</strong></p><ul><li>Задача: Напишите функцию, которая сравнивает два заказа с вложенными структурами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Item <span>struct</span> {
    Name  <span>string</span>
    Price <span>float64</span>
}

<span>type</span> Order <span>struct</span> {
    ID    <span>int</span>
    Items []Item
}

<span><span>func</span> <span>areOrdersEqual</span><span>(o1, o2 Order)</span></span> <span>bool</span> {
    <span>return</span> o1.ID == o2.ID &amp;&amp; <span>len</span>(o1.Items) == <span>len</span>(o2.Items)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    order1 := Order{ID: <span>1</span>, Items: []Item{{Name: <span>"Laptop"</span>, Price: <span>999.99</span>}}}
    order2 := Order{ID: <span>1</span>, Items: []Item{{Name: <span>"Laptop"</span>, Price: <span>999.99</span>}}}
    fmt.Println(areOrdersEqual(order1, order2)) <span>// Вывод: true</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Сериализация вложенной структуры</strong></p><ul><li>Задача: Напишите функцию, которая сериализует заказ в JSON.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"encoding/json"</span>
    <span>"fmt"</span>
)

<span>type</span> Item <span>struct</span> {
    Name  <span>string</span>  <span>`json:"name"`</span>
    Price <span>float64</span> <span>`json:"price"`</span>
}

<span>type</span> Order <span>struct</span> {
    ID    <span>int</span>    <span>`json:"id"`</span>
    Items []Item <span>`json:"items"`</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    order := Order{ID: <span>1</span>, Items: []Item{{Name: <span>"Laptop"</span>, Price: <span>999.99</span>}}}
    data, _ := json.Marshal(order)
    fmt.Println(<span>string</span>(data)) <span>// Вывод: {"id":1,"items":[{"name":"Laptop","price":999.99}]}</span>
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Методы для вложенных структур с возвратом значений</strong></p><ul><li>Задача: Реализуйте метод, который возвращает общий стоимость всех товаров в заказе.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Item <span>struct</span> {
    Name  <span>string</span>
    Price <span>float64</span>
}

<span>type</span> Order <span>struct</span> {
    ID    <span>int</span>
    Items []Item
}

<span><span>func</span> <span>(o Order)</span></span> TotalPrice() <span>float64</span> {
    total := <span>0.0</span>
    <span>for</span> _, item := <span>range</span> o.Items {
        total += item.Price
    }
    <span>return</span> total
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    order := Order{ID: <span>1</span>, Items: []Item{{Name: <span>"Laptop"</span>, Price: <span>999.99</span>}, {Name: <span>"Mouse"</span>, Price: <span>49.99</span>}}}
    fmt.Println(<span>"Total Price:"</span>, order.TotalPrice()) <span>// Вывод: Total Price: 1049.98</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание вложенной структуры с методами</strong></p><ul><li>Задача: Создайте структуру для представления пользователя с вложенной структурой для адреса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Address <span>struct</span> {
    City, Country <span>string</span>
}

<span>type</span> User <span>struct</span> {
    Name    <span>string</span>
    Age     <span>int</span>
    Address Address
}

<span><span>func</span> <span>(u User)</span></span> FullAddress() <span>string</span> {
    <span>return</span> fmt.Sprintf(<span>"%s, %s"</span>, u.Address.City, u.Address.Country)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    user := User{Name: <span>"Alice"</span>, Age: <span>30</span>, Address: Address{<span>"New York"</span>, <span>"USA"</span>}}
    fmt.Println(<span>"Full Address:"</span>, user.FullAddress()) <span>// Вывод: Full Address: New York, USA</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Рефлексия для работы с вложенными структурами</strong></p><ul><li>Задача: Напишите функцию, которая принимает вложенную структуру и использует рефлексию для получения информации о ней.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Item <span>struct</span> {
    Name  <span>string</span>
    Price <span>float64</span>
}

<span>type</span> Order <span>struct</span> {
    ID    <span>int</span>
    Items []Item
}

<span><span>func</span> <span>printOrderFields</span><span>(o <span>interface</span>{})</span></span> {
    value := reflect.ValueOf(o)
    <span>for</span> i := <span>0</span>; i &lt; value.NumField(); i++ {
        fmt.Println(value.Type().Field(i).Name, <span>":"</span>, value.Field(i))
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    order := Order{ID: <span>1</span>, Items: []Item{{Name: <span>"Laptop"</span>, Price: <span>999.99</span>}}}
    printOrderFields(order)
    <span>// Вывод:</span>
    <span>// ID : 1</span>
    <span>// Items : [{Laptop 999.99}]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Сравнение и объединение вложенных структур</strong></p><ul><li>Задача: Напишите функцию, которая объединяет два заказа.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Item <span>struct</span> {
    Name  <span>string</span>
    Price <span>float64</span>
}

<span>type</span> Order <span>struct</span> {
    ID    <span>int</span>
    Items []Item
}

<span><span>func</span> <span>mergeOrders</span><span>(o1, o2 Order)</span></span> Order {
    <span>return</span> Order{ID: o1.ID, Items: <span>append</span>(o1.Items, o2.Items...)}
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    order1 := Order{ID: <span>1</span>, Items: []Item{{Name: <span>"Laptop"</span>, Price: <span>999.99</span>}}}
    order2 := Order{ID: <span>1</span>, Items: []Item{{Name: <span>"Mouse"</span>, Price: <span>49.99</span>}}}
    merged := mergeOrders(order1, order2)
    fmt.Println(<span>"Merged Order:"</span>, merged) <span>// Вывод: Merged Order: {1 [{Laptop 999.99} {Mouse 49.99}]}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Вложенные структуры с интерфейсами</strong></p><ul><li>Задача: Создайте структуру для представления формы с методом для расчета площади.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}

<span>type</span> Rectangle <span>struct</span> {
    Width, Height <span>float64</span>
}

<span><span>func</span> <span>(r Rectangle)</span></span> Area() <span>float64</span> {
    <span>return</span> r.Width * r.Height
}

<span>type</span> Circle <span>struct</span> {
    Radius <span>float64</span>
}

<span><span>func</span> <span>(c Circle)</span></span> Area() <span>float64</span> {
    <span>return</span> <span>3.14</span> * c.Radius * c.Radius
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    shapes := []Shape{Rectangle{Width: <span>5</span>, Height: <span>3</span>}, Circle{Radius: <span>4</span>}}
    <span>for</span> _, shape := <span>range</span> shapes {
        fmt.Println(<span>"Area:"</span>, shape.Area())
    }
    <span>// Вывод:</span>
    <span>// Area: 15</span>
    <span>// Area: 50.24</span>
}
</code></div></div></pre></li></ul></li></ol><h2></h2><h1 id="heading-22" class="numbered" data-id="22" style="--bg-color: green;">МЕТОДЫ</h1><p>Методы в Go — это функции, привязанные к типам, которые позволяют инкапсулировать логику и данные.</p><h3>Базовые задачи</h3><ol><li><p><strong>Создание метода для структуры</strong></p><ul><li>Задача: Создайте метод для структуры, который выводит информацию о ней.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>(p Person)</span></span> Info() {
    fmt.Printf(<span>"Name: %s, Age: %d\n"</span>, p.Name, p.Age)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    person := Person{Name: <span>"Alice"</span>, Age: <span>30</span>}
    person.Info() <span>// Вывод: Name: Alice, Age: 30</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы с параметрами</strong></p><ul><li>Задача: Создайте метод, принимающий параметр и изменяющий поле структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Counter <span>struct</span> {
    Count <span>int</span>
}

<span><span>func</span> <span>(c *Counter)</span></span> Increment() {
    c.Count++
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    counter := Counter{Count: <span>0</span>}
    counter.Increment()
    fmt.Println(counter.Count) <span>// Вывод: 1</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы с возвращаемыми значениями</strong></p><ul><li>Задача: Создайте метод, который возвращает результат вычислений.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Rectangle <span>struct</span> {
    Width, Height <span>float64</span>
}

<span><span>func</span> <span>(r Rectangle)</span></span> Area() <span>float64</span> {
    <span>return</span> r.Width * r.Height
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rect := Rectangle{Width: <span>4</span>, Height: <span>5</span>}
    fmt.Println(<span>"Area:"</span>, rect.Area()) <span>// Вывод: Area: 20</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы с использованием указателей</strong></p><ul><li>Задача: Используйте указатели в методах для изменения поля структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Circle <span>struct</span> {
    Radius <span>float64</span>
}

<span><span>func</span> <span>(c *Circle)</span></span> SetRadius(r <span>float64</span>) {
    c.Radius = r
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    circle := Circle{Radius: <span>5</span>}
    circle.SetRadius(<span>10</span>)
    fmt.Println(circle.Radius) <span>// Вывод: 10</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы для вложенных структур</strong></p><ul><li>Задача: Создайте метод для структуры, который использует поля вложенной структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Address <span>struct</span> {
    City, Country <span>string</span>
}

<span>type</span> Person <span>struct</span> {
    Name    <span>string</span>
    Age     <span>int</span>
    Address Address
}

<span><span>func</span> <span>(p Person)</span></span> FullAddress() <span>string</span> {
    <span>return</span> fmt.Sprintf(<span>"%s, %s"</span>, p.Address.City, p.Address.Country)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    person := Person{Name: <span>"Alice"</span>, Age: <span>30</span>, Address: Address{<span>"New York"</span>, <span>"USA"</span>}}
    fmt.Println(<span>"Full Address:"</span>, person.FullAddress()) <span>// Вывод: Full Address: New York, USA</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы с интерфейсами</strong></p><ul><li>Задача: Создайте интерфейс и реализуйте его для различных структур.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}

<span>type</span> Rectangle <span>struct</span> {
    Width, Height <span>float64</span>
}

<span><span>func</span> <span>(r Rectangle)</span></span> Area() <span>float64</span> {
    <span>return</span> r.Width * r.Height
}

<span>type</span> Circle <span>struct</span> {
    Radius <span>float64</span>
}

<span><span>func</span> <span>(c Circle)</span></span> Area() <span>float64</span> {
    <span>return</span> <span>3.14</span> * c.Radius * c.Radius
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    shapes := []Shape{Rectangle{Width: <span>4</span>, Height: <span>5</span>}, Circle{Radius: <span>3</span>}}
    <span>for</span> _, shape := <span>range</span> shapes {
        fmt.Println(<span>"Area:"</span>, shape.Area())
    }
    <span>// Вывод:</span>
    <span>// Area: 20</span>
    <span>// Area: 28.26</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы с переменной длины аргументов</strong></p><ul><li>Задача: Реализуйте метод с переменной длиной аргументов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Calculator <span>struct</span>{}

<span><span>func</span> <span>(c Calculator)</span></span> Sum(numbers ...<span>int</span>) <span>int</span> {
    total := <span>0</span>
    <span>for</span> _, number := <span>range</span> numbers {
        total += number
    }
    <span>return</span> total
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    calc := Calculator{}
    fmt.Println(<span>"Sum:"</span>, calc.Sum(<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>)) <span>// Вывод: Sum: 15</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы с возвратом нескольких значений</strong></p><ul><li>Задача: Реализуйте метод, который возвращает несколько значений.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Rectangle <span>struct</span> {
    Width, Height <span>float64</span>
}

<span><span>func</span> <span>(r Rectangle)</span></span> Area() <span>float64</span> {
    <span>return</span> r.Width * r.Height
}

<span><span>func</span> <span>(r Rectangle)</span></span> Perimeter() <span>float64</span> {
    <span>return</span> <span>2</span> * (r.Width + r.Height)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rect := Rectangle{Width: <span>4</span>, Height: <span>5</span>}
    area := rect.Area()
    perimeter := rect.Perimeter()
    fmt.Printf(<span>"Area: %.2f, Perimeter: %.2f\n"</span>, area, perimeter) <span>// Вывод: Area: 20.00, Perimeter: 18.00</span>
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Методы для обработки ошибок</strong></p><ul><li>Задача: Создайте метод, который обрабатывает ошибки.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"errors"</span>
    <span>"fmt"</span>
)

<span>type</span> Person <span>struct</span> {
    Age <span>int</span>
}

<span><span>func</span> <span>(p Person)</span></span> Validate() <span>error</span> {
    <span>if</span> p.Age &lt; <span>0</span> {
        <span>return</span> errors.New(<span>"age cannot be negative"</span>)
    }
    <span>return</span> <span>nil</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    person := Person{Age: <span>-1</span>}
    <span>if</span> err := person.Validate(); err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err) <span>// Вывод: Error: age cannot be negative</span>
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы для управления состоянием</strong></p><ul><li>Задача: Реализуйте методы для управления состоянием структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> LightBulb <span>struct</span> {
    On <span>bool</span>
}

<span><span>func</span> <span>(l *LightBulb)</span></span> TurnOn() {
    l.On = <span>true</span>
}

<span><span>func</span> <span>(l *LightBulb)</span></span> TurnOff() {
    l.On = <span>false</span>
}

<span><span>func</span> <span>(l LightBulb)</span></span> Status() <span>string</span> {
    <span>if</span> l.On {
        <span>return</span> <span>"On"</span>
    }
    <span>return</span> <span>"Off"</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    bulb := LightBulb{}
    bulb.TurnOn()
    fmt.Println(<span>"Bulb Status:"</span>, bulb.Status()) <span>// Вывод: Bulb Status: On</span>
    bulb.TurnOff()
    fmt.Println(<span>"Bulb Status:"</span>, bulb.Status()) <span>// Вывод: Bulb Status: Off</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы для фильтрации данных</strong></p><ul><li>Задача: Реализуйте метод для фильтрации данных в структуре.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Item <span>struct</span> {
    Name  <span>string</span>
    Price <span>float64</span>
}

<span>type</span> Store <span>struct</span> {
    Items []Item
}

<span><span>func</span> <span>(s Store)</span></span> FilterByPrice(minPrice <span>float64</span>) []Item {
    <span>var</span> filteredItems []Item
    <span>for</span> _, item := <span>range</span> s.Items {
        <span>if</span> item.Price &gt;= minPrice {
            filteredItems = <span>append</span>(filteredItems, item)
        }
    }
    <span>return</span> filteredItems
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    store := Store{Items: []Item{{Name: <span>"Laptop"</span>, Price: <span>999.99</span>}, {Name: <span>"Mouse"</span>, Price: <span>49.99</span>}}}
    filtered := store.FilterByPrice(<span>100</span>)
    fmt.Println(<span>"Filtered Items:"</span>)
    <span>for</span> _, item := <span>range</span> filtered {
        fmt.Println(item.Name)
    }
    <span>// Вывод: Filtered Items: Laptop</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы для управления коллекциями</strong></p><ul><li>Задача: Создайте метод для добавления элемента в коллекцию.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> StringCollection <span>struct</span> {
    Items []<span>string</span>
}

<span><span>func</span> <span>(sc *StringCollection)</span></span> Add(item <span>string</span>) {
    sc.Items = <span>append</span>(sc.Items, item)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    collection := StringCollection{}
    collection.Add(<span>"Hello"</span>)
    collection.Add(<span>"World"</span>)
    fmt.Println(<span>"Collection:"</span>, collection.Items) <span>// Вывод: Collection: [Hello World]</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Методы с многопоточностью</strong></p><ul><li>Задача: Реализуйте методы, использующие горутины для параллельной обработки.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>type</span> Counter <span>struct</span> {
    Count <span>int</span>
    sync.Mutex
}

<span><span>func</span> <span>(c *Counter)</span></span> Increment() {
    c.Lock()
    c.Count++
    c.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    counter := Counter{}
    <span>var</span> wg sync.WaitGroup

    <span>for</span> i := <span>0</span>; i &lt; <span>1000</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> <span><span>func</span><span>()</span></span> {
            <span>defer</span> wg.Done()
            counter.Increment()
        }()
    }
    wg.Wait()
    fmt.Println(<span>"Final Count:"</span>, counter.Count) <span>// Вывод: Final Count: 1000</span>
}
</code></div></div></pre></li></ul></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h2></h2><h1 id="heading-23" class="numbered" data-id="23" style="--bg-color: orange;">ПАКЕТЫ И ИХ ИМПОРТ</h1><h3>Базовые задачи</h3><ol><li><p><strong>Создание простого пакета</strong></p><ul><li>Задача: Создайте пакет для математических операций.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// mathutils.go</span>
<span>package</span> mathutils

<span>// Sum возвращает сумму двух чисел.</span>
<span><span>func</span> <span>Sum</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> a + b
}
</code></div></div></pre></li></ul></li><li><p><strong>Импорт пакета в основную программу</strong></p><ul><li>Задача: Импортируйте пакет <code>mathutils</code> и используйте функцию <code>Sum</code>.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// main.go</span>
<span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"yourmodule/mathutils"</span> <span>// Замените на свой путь к пакету</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    result := mathutils.Sum(<span>5</span>, <span>7</span>)
    fmt.Println(<span>"Sum:"</span>, result) <span>// Вывод: Sum: 12</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание пакета с несколькими функциями</strong></p><ul><li>Задача: Добавьте функции для вычитания и умножения в пакет <code>mathutils</code>.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// mathutils.go</span>
<span>package</span> mathutils

<span><span>func</span> <span>Subtract</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> a - b
}

<span><span>func</span> <span>Multiply</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> a * b
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание подпакета</strong></p><ul><li>Задача: Создайте подпакет <code>geometry</code> внутри пакета <code>mathutils</code> с функцией для вычисления площади круга.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// geometry/geometry.go</span>
<span>package</span> geometry

<span>import</span> <span>"math"</span>

<span>// CircleArea вычисляет площадь круга по радиусу.</span>
<span><span>func</span> <span>CircleArea</span><span>(radius <span>float64</span>)</span></span> <span>float64</span> {
    <span>return</span> math.Pi * radius * radius
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование пакета с переменным именем</strong></p><ul><li>Задача: Импортируйте пакет с алиасом.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// main.go</span>
<span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    geo <span>"yourmodule/mathutils/geometry"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    area := geo.CircleArea(<span>5</span>)
    fmt.Println(<span>"Circle Area:"</span>, area) <span>// Вывод: Circle Area: 78.53981633974483</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание пакета с переменными и константами</strong></p><ul><li>Задача: Создайте пакет с константами и переменными.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// constants.go</span>
<span>package</span> constants

<span>const</span> Pi = <span>3.14</span>
<span>var</span> Name = <span>"Math Utilities"</span>
</code></div></div></pre></li></ul></li><li><p><strong>Использование встроенных пакетов</strong></p><ul><li>Задача: Импортируйте пакет <code>math</code> и используйте его функцию.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// main.go</span>
<span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"math"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    squareRoot := math.Sqrt(<span>16</span>)
    fmt.Println(<span>"Square Root:"</span>, squareRoot) <span>// Вывод: Square Root: 4</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание пакета для работы со строками</strong></p><ul><li>Задача: Создайте пакет для манипуляции строками.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// stringutils.go</span>
<span>package</span> stringutils

<span>// Reverse возвращает перевернутую строку.</span>
<span><span>func</span> <span>Reverse</span><span>(s <span>string</span>)</span></span> <span>string</span> {
    runes := []<span>rune</span>(s)
    <span>for</span> i, j := <span>0</span>, <span>len</span>(runes)<span>-1</span>; i &lt; j; i, j = i+<span>1</span>, j<span>-1</span> {
        runes[i], runes[j] = runes[j], runes[i]
    }
    <span>return</span> <span>string</span>(runes)
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Импорт нескольких пакетов</strong></p><ul><li>Задача: Импортируйте несколько пакетов и используйте их.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// main.go</span>
<span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"math"</span>
    <span>"yourmodule/stringutils"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(<span>"Square of 3:"</span>, math.Pow(<span>3</span>, <span>2</span>))
    fmt.Println(<span>"Reversed String:"</span>, stringutils.Reverse(<span>"Hello"</span>))
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание пакета с интерфейсами</strong></p><ul><li>Задача: Создайте пакет с интерфейсами для работы с фигурами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// shapes.go</span>
<span>package</span> shapes

<span>// Shape интерфейс для фигур.</span>
<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Реализация интерфейсов в пакетах</strong></p><ul><li>Задача: Реализуйте интерфейс <code>Shape</code> для структуры <code>Rectangle</code>.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// rectangle.go</span>
<span>package</span> shapes

<span>type</span> Rectangle <span>struct</span> {
    Width, Height <span>float64</span>
}

<span><span>func</span> <span>(r Rectangle)</span></span> Area() <span>float64</span> {
    <span>return</span> r.Width * r.Height
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание пакета с тестами</strong></p><ul><li>Задача: Создайте тесты для функций в пакете.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// mathutils_test.go</span>
<span>package</span> mathutils

<span>import</span> <span>"testing"</span>

<span><span>func</span> <span>TestSum</span><span>(t *testing.T)</span></span> {
    <span>if</span> got := Sum(<span>1</span>, <span>2</span>); got != <span>3</span> {
        t.Errorf(<span>"Sum(1, 2) = %d; want 3"</span>, got)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование внешних пакетов</strong></p><ul><li>Задача: Используйте внешний пакет, например, <code>github.com/stretchr/testify</code> для тестирования.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// main.go</span>
<span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"github.com/stretchr/testify/assert"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    result := assert.True(<span>nil</span>, <span>true</span>)
    fmt.Println(<span>"Assertion Result:"</span>, result) <span>// Вывод: Assertion Result: true</span>
}
</code></div></div></pre></li></ul></li></ol><h2></h2><h1 id="heading-24" class="numbered" data-id="24" style="--bg-color: purple;">ВВЕДЕНИЕ В МОДУЛИ</h1><h3>Базовые задачи</h3><ol><li><p><strong>Создание нового модуля</strong></p><ul><li>Задача: Инициализируйте новый модуль.</li><li>Решение:<pre><div><div>bash</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>go mod init mymodule
</code></div></div></pre></li></ul></li><li><p><strong>Добавление зависимостей в модуль</strong></p><ul><li>Задача: Добавьте зависимость в модуль.</li><li>Решение:<pre><div><div>bash</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>go get github.com/gorilla/mux
</code></div></div></pre></li></ul></li><li><p><strong>Обновление зависимостей</strong></p><ul><li>Задача: Обновите все зависимости до последних версий.</li><li>Решение:<pre><div><div>bash</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>go get -u
</code></div></div></pre></li></ul></li><li><p><strong>Удаление неиспользуемых зависимостей</strong></p><ul><li>Задача: Удалите неиспользуемые зависимости из модуля.</li><li>Решение:<pre><div><div>bash</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>go mod tidy
</code></div></div></pre></li></ul></li><li><p><strong>Создание модульного файла</strong></p><ul><li>Задача: Проверьте файл <code>go.mod</code> после инициализации модуля.</li><li>Решение:<pre><div><div>plaintext</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>module mymodule

go 1.18
</code></div></div></pre></li></ul></li><li><p><strong>Использование локальных модулей</strong></p><ul><li>Задача: Импортируйте локальный модуль.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> <span>"yourmodule/mathutils"</span>
</code></div></div></pre></li></ul></li><li><p><strong>Проверка зависимостей</strong></p><ul><li>Задача: Проверьте зависимости с помощью команды <code>go list</code>.</li><li>Решение:<pre><div><div>bash</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>go list -m all
</code></div></div></pre></li></ul></li><li><p><strong>Создание модуля с несколькими пакетами</strong></p><ul><li>Задача: Создайте модуль с несколькими пакетами и используйте их.</li><li>Решение:<pre><div><div>plaintext</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>mymodule/
├── go.mod
├── mathutils/
│   └── mathutils.go
└── main.go
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Создание версии модуля</strong></p><ul><li>Задача: Создайте тег для версии модуля.</li><li>Решение:<pre><div><div>bash</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>git tag v1.0.0
</code></div></div></pre></li></ul></li><li><p><strong>Использование версии модуля в <code>go.mod</code></strong></p><ul><li>Задача: Укажите конкретную версию зависимости в <code>go.mod</code>.</li><li>Решение:<pre><div><div>plaintext</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>require github.com/gorilla/mux v1.8.0
</code></div></div></pre></li></ul></li><li><p><strong>Публикация модуля в репозитории</strong></p><ul><li>Задача: Опубликуйте модуль в удаленном репозитории.</li><li>Решение:<pre><div><div>bash</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>git push origin master --tags
</code></div></div></pre></li></ul></li><li><p><strong>Создание документации для модуля</strong></p><ul><li>Задача: Создайте документацию для вашего модуля.</li><li>Решение:<pre><div><div>bash</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>go doc
</code></div></div></pre></li></ul></li><li><p><strong>Проверка совместимости модулей</strong></p><ul><li>Задача: Проверьте совместимость ваших модулей с помощью <code>go test</code>.</li><li>Решение:<pre><div><div>bash</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>go <span>test</span> ./...
</code></div></div></pre></li></ul></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h2></h2><h1 id="heading-25" class="numbered" data-id="25" style="--bg-color: pink;">ВВЕДЕНИЕ В ИНТЕРФЕЙСЫ</h1><h3>Базовые задачи</h3><ol><li><p><strong>Создание простого интерфейса</strong></p><ul><li>Задача: Создайте интерфейс для фигур.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>// Shape интерфейс для фигур.</span>
<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    fmt.Println(<span>"Interface Shape created!"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Реализация интерфейса в структуре</strong></p><ul><li>Задача: Реализуйте интерфейс <code>Shape</code> для структуры <code>Rectangle</code>.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}

<span>type</span> Rectangle <span>struct</span> {
    Width, Height <span>float64</span>
}

<span>// Area вычисляет площадь прямоугольника.</span>
<span><span>func</span> <span>(r Rectangle)</span></span> Area() <span>float64</span> {
    <span>return</span> r.Width * r.Height
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rect := Rectangle{Width: <span>4</span>, Height: <span>5</span>}
    fmt.Println(<span>"Area of Rectangle:"</span>, rect.Area()) <span>// Вывод: Area of Rectangle: 20</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание другого типа, реализующего тот же интерфейс</strong></p><ul><li>Задача: Реализуйте интерфейс <code>Shape</code> для структуры <code>Circle</code>.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Circle <span>struct</span> {
    Radius <span>float64</span>
}

<span>// Area вычисляет площадь круга.</span>
<span><span>func</span> <span>(c Circle)</span></span> Area() <span>float64</span> {
    <span>return</span> <span>3.14</span> * c.Radius * c.Radius
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    circle := Circle{Radius: <span>3</span>}
    fmt.Println(<span>"Area of Circle:"</span>, circle.Area()) <span>// Вывод: Area of Circle: 28.26</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование интерфейса в функции</strong></p><ul><li>Задача: Создайте функцию, которая принимает интерфейс <code>Shape</code> и выводит площадь.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>PrintArea</span><span>(s Shape)</span></span> {
    fmt.Println(<span>"Area:"</span>, s.Area())
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rect := Rectangle{Width: <span>4</span>, Height: <span>5</span>}
    circle := Circle{Radius: <span>3</span>}
    PrintArea(rect)   <span>// Вывод: Area: 20</span>
    PrintArea(circle) <span>// Вывод: Area: 28.26</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование интерфейса для разных типов</strong></p><ul><li>Задача: Создайте массив фигур и выведите площади всех фигур.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    shapes := []Shape{Rectangle{Width: <span>4</span>, Height: <span>5</span>}, Circle{Radius: <span>3</span>}}
    <span>for</span> _, shape := <span>range</span> shapes {
        fmt.Println(<span>"Area:"</span>, shape.Area())
    }
    <span>// Вывод:</span>
    <span>// Area: 20</span>
    <span>// Area: 28.26</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Интерфейсы с методами, возвращающими значения</strong></p><ul><li>Задача: Создайте интерфейс с методом, возвращающим дополнительное значение.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> DetailedShape <span>interface</span> {
    Shape
    Description() <span>string</span>
}

<span><span>func</span> <span>(r Rectangle)</span></span> Description() <span>string</span> {
    <span>return</span> <span>"Rectangle"</span>
}

<span><span>func</span> <span>(c Circle)</span></span> Description() <span>string</span> {
    <span>return</span> <span>"Circle"</span>
}

<span><span>func</span> <span>PrintDetails</span><span>(s DetailedShape)</span></span> {
    fmt.Println(s.Description(), <span>"Area:"</span>, s.Area())
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rect := Rectangle{Width: <span>4</span>, Height: <span>5</span>}
    circle := Circle{Radius: <span>3</span>}
    PrintDetails(rect)   <span>// Вывод: Rectangle Area: 20</span>
    PrintDetails(circle) <span>// Вывод: Circle Area: 28.26</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Проверка соответствия интерфейсу</strong></p><ul><li>Задача: Проверьте, соответствует ли тип интерфейсу.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>isShape</span><span>(s <span>interface</span>{})</span></span> <span>bool</span> {
    _, ok := s.(Shape)
    <span>return</span> ok
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rect := Rectangle{Width: <span>4</span>, Height: <span>5</span>}
    fmt.Println(<span>"Is Rectangle a Shape?"</span>, isShape(rect)) <span>// Вывод: Is Rectangle a Shape? true</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Интерфейс как возвращаемый тип</strong></p><ul><li>Задача: Создайте функцию, которая возвращает интерфейс.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>GetShape</span><span>(shapeType <span>string</span>)</span></span> Shape {
    <span>if</span> shapeType == <span>"rectangle"</span> {
        <span>return</span> Rectangle{Width: <span>4</span>, Height: <span>5</span>}
    }
    <span>return</span> Circle{Radius: <span>3</span>}
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    shape := GetShape(<span>"rectangle"</span>)
    fmt.Println(<span>"Area of Shape:"</span>, shape.Area()) <span>// Вывод: Area of Shape: 20</span>
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Создание интерфейса с несколькими методами</strong></p><ul><li>Задача: Создайте интерфейс, который требует нескольких методов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Shape3D <span>interface</span> {
    Shape
    Volume() <span>float64</span>
}

<span>type</span> Cylinder <span>struct</span> {
    Radius, Height <span>float64</span>
}

<span><span>func</span> <span>(c Cylinder)</span></span> Area() <span>float64</span> {
    <span>return</span> <span>2</span> * <span>3.14</span> * c.Radius * c.Height
}

<span><span>func</span> <span>(c Cylinder)</span></span> Volume() <span>float64</span> {
    <span>return</span> <span>3.14</span> * c.Radius * c.Radius * c.Height
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    cyl := Cylinder{Radius: <span>3</span>, Height: <span>5</span>}
    fmt.Println(<span>"Cylinder Area:"</span>, cyl.Area())   <span>// Вывод: Cylinder Area: 56.52</span>
    fmt.Println(<span>"Cylinder Volume:"</span>, cyl.Volume()) <span>// Вывод: Cylinder Volume: 28.26</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание коллекции объектов, реализующих интерфейс</strong></p><ul><li>Задача: Реализуйте коллекцию объектов, которые реализуют интерфейс.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> ShapeCollection <span>struct</span> {
    shapes []Shape
}

<span><span>func</span> <span>(sc *ShapeCollection)</span></span> Add(s Shape) {
    sc.shapes = <span>append</span>(sc.shapes, s)
}

<span><span>func</span> <span>(sc ShapeCollection)</span></span> TotalArea() <span>float64</span> {
    total := <span>0.0</span>
    <span>for</span> _, s := <span>range</span> sc.shapes {
        total += s.Area()
    }
    <span>return</span> total
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    sc := ShapeCollection{}
    sc.Add(Rectangle{Width: <span>4</span>, Height: <span>5</span>})
    sc.Add(Circle{Radius: <span>3</span>})
    fmt.Println(<span>"Total Area:"</span>, sc.TotalArea()) <span>// Вывод: Total Area: 48.26</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование пустого интерфейса</strong></p><ul><li>Задача: Используйте пустой интерфейс для хранения различных типов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>PrintAny</span><span>(v <span>interface</span>{})</span></span> {
    fmt.Println(<span>"Value:"</span>, v)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    PrintAny(<span>"Hello"</span>)
    PrintAny(<span>123</span>)
    PrintAny(<span>3.14</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Пользовательские ошибки через интерфейсы</strong></p><ul><li>Задача: Создайте интерфейс для ошибок.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"errors"</span>
    <span>"fmt"</span>
)

<span>type</span> CustomError <span>interface</span> {
    Error() <span>string</span>
    Code() <span>int</span>
}

<span>type</span> MyError <span>struct</span> {
    msg  <span>string</span>
    code <span>int</span>
}

<span><span>func</span> <span>(e MyError)</span></span> Error() <span>string</span> {
    <span>return</span> e.msg
}

<span><span>func</span> <span>(e MyError)</span></span> Code() <span>int</span> {
    <span>return</span> e.code
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    err := MyError{msg: <span>"Something went wrong"</span>, code: <span>500</span>}
    fmt.Println(<span>"Error:"</span>, err.Error(), <span>"Code:"</span>, err.Code()) <span>// Вывод: Error: Something went wrong Code: 500</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование интерфейсов для реализации паттерна "Стратегия"</strong></p><ul><li>Задача: Реализуйте паттерн "Стратегия" с помощью интерфейсов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> SortStrategy <span>interface</span> {
    Sort(data []<span>int</span>) []<span>int</span>
}

<span>type</span> BubbleSort <span>struct</span>{}

<span><span>func</span> <span>(b BubbleSort)</span></span> Sort(data []<span>int</span>) []<span>int</span> {
    <span>// Простой алгоритм пузырьковой сортировки</span>
    n := <span>len</span>(data)
    <span>for</span> i := <span>0</span>; i &lt; n<span>-1</span>; i++ {
        <span>for</span> j := <span>0</span>; j &lt; n-i<span>-1</span>; j++ {
            <span>if</span> data[j] &gt; data[j+<span>1</span>] {
                data[j], data[j+<span>1</span>] = data[j+<span>1</span>], data[j]
            }
        }
    }
    <span>return</span> data
}

<span>type</span> QuickSort <span>struct</span>{}

<span><span>func</span> <span>(q QuickSort)</span></span> Sort(data []<span>int</span>) []<span>int</span> {
    <span>// Простой алгоритм быстрой сортировки</span>
    <span>if</span> <span>len</span>(data) &lt; <span>2</span> {
        <span>return</span> data
    }
    pivot := data[<span>0</span>]
    left := []<span>int</span>{}
    right := []<span>int</span>{}
    <span>for</span> _, v := <span>range</span> data[<span>1</span>:] {
        <span>if</span> v &lt;= pivot {
            left = <span>append</span>(left, v)
        } <span>else</span> {
            right = <span>append</span>(right, v)
        }
    }
    <span>return</span> <span>append</span>(<span>append</span>(left, pivot), right...)
}

<span>type</span> Context <span>struct</span> {
    strategy SortStrategy
}

<span><span>func</span> <span>(c *Context)</span></span> SetStrategy(s SortStrategy) {
    c.strategy = s
}

<span><span>func</span> <span>(c *Context)</span></span> Sort(data []<span>int</span>) []<span>int</span> {
    <span>return</span> c.strategy.Sort(data)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    data := []<span>int</span>{<span>5</span>, <span>3</span>, <span>8</span>, <span>1</span>, <span>2</span>}

    context := Context{}

    context.SetStrategy(BubbleSort{})
    fmt.Println(<span>"Bubble Sort:"</span>, context.Sort(data))

    context.SetStrategy(QuickSort{})
    fmt.Println(<span>"Quick Sort:"</span>, context.Sort(data))
}
</code></div></div></pre></li></ul></li></ol><h2></h2><h1 id="heading-26" class="numbered" data-id="26" style="--bg-color: red;">СООТВЕТСТВИЕ ИНТЕРФЕЙСУ</h1><h3>Базовые задачи</h3><ol><li><p><strong>Проверка соответствия типа интерфейсу</strong></p><ul><li>Задача: Проверьте, соответствует ли тип интерфейсу.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}

<span><span>func</span> <span>CheckShape</span><span>(s <span>interface</span>{})</span></span> {
    <span>if</span> _, ok := s.(Shape); ok {
        fmt.Println(<span>"Type is a Shape"</span>)
    } <span>else</span> {
        fmt.Println(<span>"Type is NOT a Shape"</span>)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    CheckShape(Rectangle{Width: <span>4</span>, Height: <span>5</span>}) <span>// Вывод: Type is a Shape</span>
    CheckShape(<span>123</span>)                             <span>// Вывод: Type is NOT a Shape</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование <code>type assertions</code></strong></p><ul><li>Задача: Используйте <code>type assertions</code> для получения значения типа интерфейса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>PrintShape</span><span>(s Shape)</span></span> {
    <span>if</span> rect, ok := s.(Rectangle); ok {
        fmt.Println(<span>"Rectangle Width:"</span>, rect.Width)
    } <span>else</span> {
        fmt.Println(<span>"Not a Rectangle"</span>)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rect := Rectangle{Width: <span>4</span>, Height: <span>5</span>}
    PrintShape(rect) <span>// Вывод: Rectangle Width: 4</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование <code>type switches</code></strong></p><ul><li>Задача: Используйте <code>type switches</code> для обработки различных типов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>DescribeShape</span><span>(s <span>interface</span>{})</span></span> {
    <span>switch</span> shape := s.(<span>type</span>) {
    <span>case</span> Rectangle:
        fmt.Println(<span>"Rectangle with Width:"</span>, shape.Width)
    <span>case</span> Circle:
        fmt.Println(<span>"Circle with Radius:"</span>, shape.Radius)
    <span>default</span>:
        fmt.Println(<span>"Unknown shape"</span>)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    DescribeShape(Rectangle{Width: <span>4</span>, Height: <span>5</span>}) <span>// Вывод: Rectangle with Width: 4</span>
    DescribeShape(Circle{Radius: <span>3</span>})              <span>// Вывод: Circle with Radius: 3</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Определение интерфейса на основе существующего типа</strong></p><ul><li>Задача: Определите интерфейс на основе существующего типа.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Vehicle <span>interface</span> {
    Move()
}

<span>type</span> Car <span>struct</span>{}

<span><span>func</span> <span>(c Car)</span></span> Move() {
    fmt.Println(<span>"Car is moving"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> v Vehicle = Car{}
    v.Move() <span>// Вывод: Car is moving</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание интерфейса для работы с разными типами данных</strong></p><ul><li>Задача: Создайте интерфейс для обработки строк и чисел.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Stringer <span>interface</span> {
    String() <span>string</span>
}

<span>type</span> IntWrapper <span>struct</span> {
    Value <span>int</span>
}

<span><span>func</span> <span>(i IntWrapper)</span></span> String() <span>string</span> {
    <span>return</span> fmt.Sprintf(<span>"Int: %d"</span>, i.Value)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    i := IntWrapper{Value: <span>10</span>}
    fmt.Println(i.String()) <span>// Вывод: Int: 10</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание интерфейса с параметрами</strong></p><ul><li>Задача: Создайте интерфейс, принимающий параметры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> AreaCalculator <span>interface</span> {
    CalculateArea(width, height <span>float64</span>) <span>float64</span>
}

<span>type</span> Area <span>struct</span>{}

<span><span>func</span> <span>(a Area)</span></span> CalculateArea(width, height <span>float64</span>) <span>float64</span> {
    <span>return</span> width * height
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    area := Area{}
    fmt.Println(<span>"Area:"</span>, area.CalculateArea(<span>4</span>, <span>5</span>)) <span>// Вывод: Area: 20</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование интерфейсов с разными реализациями</strong></p><ul><li>Задача: Создайте интерфейс и две реализации.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Speaker <span>interface</span> {
    Speak() <span>string</span>
}

<span>type</span> Dog <span>struct</span>{}

<span><span>func</span> <span>(d Dog)</span></span> Speak() <span>string</span> {
    <span>return</span> <span>"Woof!"</span>
}

<span>type</span> Cat <span>struct</span>{}

<span><span>func</span> <span>(c Cat)</span></span> Speak() <span>string</span> {
    <span>return</span> <span>"Meow!"</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> s Speaker
    s = Dog{}
    fmt.Println(s.Speak()) <span>// Вывод: Woof!</span>
    s = Cat{}
    fmt.Println(s.Speak()) <span>// Вывод: Meow!</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание интерфейсов для обработки различных событий</strong></p><ul><li>Задача: Создайте интерфейс для обработки событий.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Event <span>interface</span> {
    Trigger()
}

<span>type</span> ClickEvent <span>struct</span>{}

<span><span>func</span> <span>(c ClickEvent)</span></span> Trigger() {
    fmt.Println(<span>"Click event triggered!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> e Event = ClickEvent{}
    e.Trigger() <span>// Вывод: Click event triggered!</span>
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Создание сложного интерфейса</strong></p><ul><li>Задача: Создайте интерфейс с несколькими методами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> AdvancedShape <span>interface</span> {
    Shape
    Perimeter() <span>float64</span>
}

<span>type</span> Square <span>struct</span> {
    Side <span>float64</span>
}

<span><span>func</span> <span>(s Square)</span></span> Area() <span>float64</span> {
    <span>return</span> s.Side * s.Side
}

<span><span>func</span> <span>(s Square)</span></span> Perimeter() <span>float64</span> {
    <span>return</span> <span>4</span> * s.Side
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    sq := Square{Side: <span>4</span>}
    fmt.Println(<span>"Square Area:"</span>, sq.Area())       <span>// Вывод: Square Area: 16</span>
    fmt.Println(<span>"Square Perimeter:"</span>, sq.Perimeter()) <span>// Вывод: Square Perimeter: 16</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Определение интерфейсов для разных реализаций</strong></p><ul><li>Задача: Определите интерфейсы для разных реализаций.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Movable <span>interface</span> {
    Move()
}

<span>type</span> Jumpable <span>interface</span> {
    Jump()
}

<span>type</span> Frog <span>struct</span>{}

<span><span>func</span> <span>(f Frog)</span></span> Move() {
    fmt.Println(<span>"Frog is moving"</span>)
}

<span><span>func</span> <span>(f Frog)</span></span> Jump() {
    fmt.Println(<span>"Frog is jumping"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> m Movable = Frog{}
    m.Move() <span>// Вывод: Frog is moving</span>

    <span>var</span> j Jumpable = Frog{}
    j.Jump() <span>// Вывод: Frog is jumping</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание интерфейса для работы с базами данных</strong></p><ul><li>Задача: Создайте интерфейс для работы с базами данных.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Database <span>interface</span> {
    Connect() <span>error</span>
    Query(query <span>string</span>) (<span>string</span>, <span>error</span>)
}

<span>type</span> MySQL <span>struct</span>{}

<span><span>func</span> <span>(m MySQL)</span></span> Connect() <span>error</span> {
    fmt.Println(<span>"Connecting to MySQL"</span>)
    <span>return</span> <span>nil</span>
}

<span><span>func</span> <span>(m MySQL)</span></span> Query(query <span>string</span>) (<span>string</span>, <span>error</span>) {
    <span>return</span> <span>"MySQL Result"</span>, <span>nil</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    db := MySQL{}
    db.Connect()
    result, _ := db.Query(<span>"SELECT * FROM users"</span>)
    fmt.Println(<span>"Query Result:"</span>, result) <span>// Вывод: Query Result: MySQL Result</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание интерфейса для обработки изображений</strong></p><ul><li>Задача: Создайте интерфейс для обработки изображений.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> ImageProcessor <span>interface</span> {
    Process() <span>error</span>
}

<span>type</span> PNGImage <span>struct</span>{}

<span><span>func</span> <span>(p PNGImage)</span></span> Process() <span>error</span> {
    fmt.Println(<span>"Processing PNG Image"</span>)
    <span>return</span> <span>nil</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    img := PNGImage{}
    img.Process() <span>// Вывод: Processing PNG Image</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание интерфейсов для отправки уведомлений</strong></p><ul><li>Задача: Создайте интерфейс для отправки уведомлений.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Notifier <span>interface</span> {
    Notify(message <span>string</span>)
}

<span>type</span> EmailNotifier <span>struct</span>{}

<span><span>func</span> <span>(e EmailNotifier)</span></span> Notify(message <span>string</span>) {
    fmt.Println(<span>"Sending email notification:"</span>, message)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    notifier := EmailNotifier{}
    notifier.Notify(<span>"Hello, World!"</span>) <span>// Вывод: Sending email notification: Hello, World!</span>
}
</code></div></div></pre></li></ul></li></ol><h2></h2><h1 id="heading-27" class="numbered" data-id="27" style="--bg-color: blue;">ПОЛИМОРФИЗМ</h1><h3>Базовые задачи</h3><ol><li><p><strong>Применение полиморфизма</strong></p><ul><li>Задача: Используйте полиморфизм для различных фигур.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>PrintArea</span><span>(s Shape)</span></span> {
    fmt.Println(<span>"Area:"</span>, s.Area())
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    shapes := []Shape{Rectangle{Width: <span>4</span>, Height: <span>5</span>}, Circle{Radius: <span>3</span>}}
    <span>for</span> _, shape := <span>range</span> shapes {
        PrintArea(shape)
    }
    <span>// Вывод:</span>
    <span>// Area: 20</span>
    <span>// Area: 28.26</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание интерфейса с полиморфными методами</strong></p><ul><li>Задача: Создайте интерфейс с методами, которые могут принимать различные типы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Printer <span>interface</span> {
    Print()
}

<span>type</span> TextPrinter <span>struct</span> {
    Text <span>string</span>
}

<span><span>func</span> <span>(t TextPrinter)</span></span> Print() {
    fmt.Println(<span>"Text:"</span>, t.Text)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> p Printer = TextPrinter{Text: <span>"Hello"</span>}
    p.Print() <span>// Вывод: Text: Hello</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание полиморфной функции</strong></p><ul><li>Задача: Создайте функцию, которая принимает интерфейс.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>PrintShapeDetails</span><span>(s Shape)</span></span> {
    fmt.Println(<span>"Shape Area:"</span>, s.Area())
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    PrintShapeDetails(Rectangle{Width: <span>4</span>, Height: <span>5</span>}) <span>// Вывод: Shape Area: 20</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Полиморфизм с использованием методов</strong></p><ul><li>Задача: Используйте полиморфизм с методами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Animal <span>interface</span> {
    Speak() <span>string</span>
}

<span>type</span> Dog <span>struct</span>{}
<span>type</span> Cat <span>struct</span>{}

<span><span>func</span> <span>(d Dog)</span></span> Speak() <span>string</span> {
    <span>return</span> <span>"Woof"</span>
}

<span><span>func</span> <span>(c Cat)</span></span> Speak() <span>string</span> {
    <span>return</span> <span>"Meow"</span>
}

<span><span>func</span> <span>MakeSound</span><span>(a Animal)</span></span> {
    fmt.Println(a.Speak())
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    MakeSound(Dog{}) <span>// Вывод: Woof</span>
    MakeSound(Cat{}) <span>// Вывод: Meow</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Полиморфизм в методах структур</strong></p><ul><li>Задача: Реализуйте полиморфизм в методах структур.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Vehicle <span>interface</span> {
    Start() <span>string</span>
}

<span>type</span> Car <span>struct</span>{}
<span>type</span> Bike <span>struct</span>{}

<span><span>func</span> <span>(c Car)</span></span> Start() <span>string</span> {
    <span>return</span> <span>"Car started"</span>
}

<span><span>func</span> <span>(b Bike)</span></span> Start() <span>string</span> {
    <span>return</span> <span>"Bike started"</span>
}

<span><span>func</span> <span>StartVehicle</span><span>(v Vehicle)</span></span> {
    fmt.Println(v.Start())
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    StartVehicle(Car{}) <span>// Вывод: Car started</span>
    StartVehicle(Bike{}) <span>// Вывод: Bike started</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Полиморфизм с коллекциями</strong></p><ul><li>Задача: Используйте полиморфизм с коллекциями.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>MakeAllSounds</span><span>(animals []Animal)</span></span> {
    <span>for</span> _, a := <span>range</span> animals {
        fmt.Println(a.Speak())
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    animals := []Animal{Dog{}, Cat{}}
    MakeAllSounds(animals) <span>// Вывод: Woof, Meow</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Полиморфизм с интерфейсами для обработки событий</strong></p><ul><li>Задача: Реализуйте полиморфизм для обработки различных событий.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Event <span>interface</span> {
    Trigger()
}

<span>type</span> ClickEvent <span>struct</span>{}
<span>type</span> MouseOverEvent <span>struct</span>{}

<span><span>func</span> <span>(c ClickEvent)</span></span> Trigger() {
    fmt.Println(<span>"Click event triggered!"</span>)
}

<span><span>func</span> <span>(m MouseOverEvent)</span></span> Trigger() {
    fmt.Println(<span>"Mouse over event triggered!"</span>)
}

<span><span>func</span> <span>TriggerEvent</span><span>(e Event)</span></span> {
    e.Trigger()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    TriggerEvent(ClickEvent{})      <span>// Вывод: Click event triggered!</span>
    TriggerEvent(MouseOverEvent{}) <span>// Вывод: Mouse over event triggered!</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование полиморфизма с функциями обратного вызова</strong></p><ul><li>Задача: Используйте полиморфизм для функций обратного вызова.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Callback <span><span>func</span><span>(<span>string</span>)</span></span>

<span><span>func</span> <span>ProcessData</span><span>(data <span>string</span>, callback Callback)</span></span> {
    callback(data)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    ProcessData(<span>"Hello, World!"</span>, <span><span>func</span><span>(data <span>string</span>)</span></span> {
        fmt.Println(<span>"Processed data:"</span>, data)
    })
    <span>// Вывод: Processed data: Hello, World!</span>
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Создание полиморфной системы с вложенными структурами</strong></p><ul><li>Задача: Создайте систему с вложенными структурами и полиморфизмом.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}

<span>type</span> Polygon <span>struct</span> {
    Sides []<span>float64</span>
}

<span><span>func</span> <span>(p Polygon)</span></span> Area() <span>float64</span> {
    <span>// Простой расчет площади многоугольника</span>
    <span>return</span> <span>0</span> <span>// Здесь должен быть правильный расчет</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    polygon := Polygon{Sides: []<span>float64</span>{<span>4</span>, <span>5</span>, <span>6</span>}}
    fmt.Println(<span>"Polygon Area:"</span>, polygon.Area()) <span>// Вывод: Polygon Area: 0</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание полиморфной системы с различными интерфейсами</strong></p><ul><li>Задача: Создайте систему с различными интерфейсами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Animal <span>interface</span> {
    Speak() <span>string</span>
}

<span>type</span> Vehicle <span>interface</span> {
    Start() <span>string</span>
}

<span>type</span> Dog <span>struct</span>{}
<span>type</span> Car <span>struct</span>{}

<span><span>func</span> <span>(d Dog)</span></span> Speak() <span>string</span> {
    <span>return</span> <span>"Woof"</span>
}

<span><span>func</span> <span>(c Car)</span></span> Start() <span>string</span> {
    <span>return</span> <span>"Car started"</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> a Animal = Dog{}
    <span>var</span> v Vehicle = Car{}
    fmt.Println(a.Speak()) <span>// Вывод: Woof</span>
    fmt.Println(v.Start()) <span>// Вывод: Car started</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание полиморфной системы с обработчиками событий</strong></p><ul><li>Задача: Создайте систему с обработчиками событий.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Event <span>interface</span> {
    Trigger()
}

<span>type</span> ClickEvent <span>struct</span>{}
<span>type</span> KeyPressEvent <span>struct</span>{}

<span><span>func</span> <span>(c ClickEvent)</span></span> Trigger() {
    fmt.Println(<span>"Click event triggered!"</span>)
}

<span><span>func</span> <span>(k KeyPressEvent)</span></span> Trigger() {
    fmt.Println(<span>"Key press event triggered!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    events := []Event{ClickEvent{}, KeyPressEvent{}}
    <span>for</span> _, e := <span>range</span> events {
        e.Trigger()
    }
    <span>// Вывод:</span>
    <span>// Click event triggered!</span>
    <span>// Key press event triggered!</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Полиморфизм с использованием интерфейсов для различных реализаций</strong></p><ul><li>Задача: Реализуйте полиморфизм для различных реализаций интерфейсов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}

<span>type</span> Circle <span>struct</span>{ Radius <span>float64</span> }
<span>type</span> Square <span>struct</span>{ Side <span>float64</span> }

<span><span>func</span> <span>(c Circle)</span></span> Area() <span>float64</span> {
    <span>return</span> <span>3.14</span> * c.Radius * c.Radius
}

<span><span>func</span> <span>(s Square)</span></span> Area() <span>float64</span> {
    <span>return</span> s.Side * s.Side
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    shapes := []Shape{Circle{Radius: <span>3</span>}, Square{Side: <span>4</span>}}
    <span>for</span> _, shape := <span>range</span> shapes {
        fmt.Println(<span>"Area:"</span>, shape.Area())
    }
    <span>// Вывод:</span>
    <span>// Area: 28.26</span>
    <span>// Area: 16</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Полиморфизм с функциями обратного вызова</strong></p><ul><li>Задача: Используйте полиморфизм с функциями обратного вызова.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span>type</span> Callback <span><span>func</span><span>(<span>int</span>)</span></span> <span>string</span>

<span><span>func</span> <span>ProcessNumbers</span><span>(numbers []<span>int</span>, callback Callback)</span></span> {
    <span>for</span> _, n := <span>range</span> numbers {
        fmt.Println(callback(n))
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    ProcessNumbers([]<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>}, <span><span>func</span><span>(n <span>int</span>)</span></span> <span>string</span> {
        <span>return</span> fmt.Sprintf(<span>"Number: %d"</span>, n)
    })
    <span>// Вывод:</span>
    <span>// Number: 1</span>
    <span>// Number: 2</span>
    <span>// Number: 3</span>
}
</code></div></div></pre></li></ul></li></ol><h3></h3><h1 id="heading-28" class="numbered" data-id="28" style="--bg-color: green;">РЕФЛЕКСИЯ</h1><h3>Базовые задачи</h3><ol><li><p><strong>Использование рефлексии для получения типа</strong></p><ul><li>Задача: Используйте рефлексию для получения типа переменной.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span><span>func</span> <span>PrintType</span><span>(i <span>interface</span>{})</span></span> {
    t := reflect.TypeOf(i)
    fmt.Println(<span>"Type:"</span>, t)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    PrintType(<span>42</span>)         <span>// Вывод: Type: int</span>
    PrintType(<span>"Hello"</span>)    <span>// Вывод: Type: string</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование рефлексии для получения значений</strong></p><ul><li>Задача: Используйте рефлексию для получения значений полей структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>PrintFields</span><span>(p <span>interface</span>{})</span></span> {
    val := reflect.ValueOf(p)
    <span>for</span> i := <span>0</span>; i &lt; val.NumField(); i++ {
        fmt.Println(<span>"Field:"</span>, val.Type().Field(i).Name, <span>"Value:"</span>, val.Field(i).Interface())
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := Person{Name: <span>"Alice"</span>, Age: <span>30</span>}
    PrintFields(p)
    <span>// Вывод:</span>
    <span>// Field: Name Value: Alice</span>
    <span>// Field: Age Value: 30</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Изменение значений с помощью рефлексии</strong></p><ul><li>Задача: Измените значение поля структуры с помощью рефлексии.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>SetAge</span><span>(p <span>interface</span>{}, age <span>int</span>)</span></span> {
    val := reflect.ValueOf(p).Elem()
    val.FieldByName(<span>"Age"</span>).SetInt(<span>int64</span>(age))
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := &amp;Person{Name: <span>"Alice"</span>, Age: <span>30</span>}
    SetAge(p, <span>35</span>)
    fmt.Println(<span>"Updated Age:"</span>, p.Age) <span>// Вывод: Updated Age: 35</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование рефлексии для вызова методов</strong></p><ul><li>Задача: Используйте рефлексию для вызова метода структуры.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
}

<span><span>func</span> <span>(p Person)</span></span> Greet() {
    fmt.Println(<span>"Hello,"</span>, p.Name)
}

<span><span>func</span> <span>CallGreet</span><span>(p <span>interface</span>{})</span></span> {
    val := reflect.ValueOf(p)
    method := val.MethodByName(<span>"Greet"</span>)
    <span>if</span> method.IsValid() {
        method.Call(<span>nil</span>)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := Person{Name: <span>"Alice"</span>}
    CallGreet(p) <span>// Вывод: Hello, Alice</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование рефлексии для создания экземпляров</strong></p><ul><li>Задача: Создайте экземпляр структуры с помощью рефлексии.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>CreatePerson</span><span>(name <span>string</span>, age <span>int</span>)</span></span> <span>interface</span>{} {
    pType := reflect.TypeOf(Person{})
    pValue := reflect.New(pType).Elem()
    pValue.FieldByName(<span>"Name"</span>).SetString(name)
    pValue.FieldByName(<span>"Age"</span>).SetInt(<span>int64</span>(age))
    <span>return</span> pValue.Interface()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := CreatePerson(<span>"Alice"</span>, <span>30</span>).(Person)
    fmt.Println(<span>"Created Person:"</span>, p) <span>// Вывод: Created Person: {Alice 30}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование рефлексии для получения тегов</strong></p><ul><li>Задача: Получите теги полей структуры с помощью рефлексии.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Person <span>struct</span> {
    Name <span>string</span> <span>`json:"name"`</span>
    Age  <span>int</span>    <span>`json:"age"`</span>
}

<span><span>func</span> <span>PrintTags</span><span>(p <span>interface</span>{})</span></span> {
    val := reflect.ValueOf(p)
    <span>for</span> i := <span>0</span>; i &lt; val.NumField(); i++ {
        field := val.Type().Field(i)
        fmt.Println(<span>"Field:"</span>, field.Name, <span>"Tag:"</span>, field.Tag)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := Person{Name: <span>"Alice"</span>, Age: <span>30</span>}
    PrintTags(p)
    <span>// Вывод:</span>
    <span>// Field: Name Tag: json:"name"</span>
    <span>// Field: Age Tag: json:"age"</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование рефлексии для проверки интерфейсов</strong></p><ul><li>Задача: Проверьте, реализует ли тип интерфейс.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}

<span>type</span> Circle <span>struct</span>{}

<span><span>func</span> <span>(c Circle)</span></span> Area() <span>float64</span> {
    <span>return</span> <span>3.14</span>
}

<span><span>func</span> <span>ImplementsInterface</span><span>(i <span>interface</span>{})</span></span> {
    <span>if</span> reflect.TypeOf(i).Implements(reflect.TypeOf((*Shape)(<span>nil</span>)).Elem()) {
        fmt.Println(<span>"Implements Shape interface"</span>)
    } <span>else</span> {
        fmt.Println(<span>"Does not implement Shape interface"</span>)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    ImplementsInterface(Circle{}) <span>// Вывод: Implements Shape interface</span>
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Создание системы с использованием рефлексии для обработки различных типов</strong></p><ul><li>Задача: Создайте систему с использованием рефлексии для обработки различных типов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Shape <span>interface</span> {
    Area() <span>float64</span>
}

<span>type</span> Circle <span>struct</span>{ Radius <span>float64</span> }
<span>type</span> Square <span>struct</span>{ Side <span>float64</span> }

<span><span>func</span> <span>(c Circle)</span></span> Area() <span>float64</span> {
    <span>return</span> <span>3.14</span> * c.Radius * c.Radius
}

<span><span>func</span> <span>(s Square)</span></span> Area() <span>float64</span> {
    <span>return</span> s.Side * s.Side
}

<span><span>func</span> <span>PrintArea</span><span>(s Shape)</span></span> {
    val := reflect.ValueOf(s)
    areaMethod := val.MethodByName(<span>"Area"</span>)
    area := areaMethod.Call(<span>nil</span>)
    fmt.Println(<span>"Area:"</span>, area[<span>0</span>].Interface())
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    shapes := []Shape{Circle{Radius: <span>5</span>}, Square{Side: <span>4</span>}}
    <span>for</span> _, shape := <span>range</span> shapes {
        PrintArea(shape)
    }
    <span>// Вывод:</span>
    <span>// Area: 78.5</span>
    <span>// Area: 16</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание системы с динамическим созданием экземпляров и вызовом методов</strong></p><ul><li>Задача: Создайте систему с динамическим созданием экземпляров и вызовом методов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Animal <span>interface</span> {
    Speak() <span>string</span>
}

<span>type</span> Dog <span>struct</span>{}
<span>type</span> Cat <span>struct</span>{}

<span><span>func</span> <span>(d Dog)</span></span> Speak() <span>string</span> {
    <span>return</span> <span>"Woof"</span>
}

<span><span>func</span> <span>(c Cat)</span></span> Speak() <span>string</span> {
    <span>return</span> <span>"Meow"</span>
}

<span><span>func</span> <span>CreateAnimal</span><span>(animalType <span>string</span>)</span></span> Animal {
    <span>var</span> a Animal
    <span>switch</span> animalType {
    <span>case</span> <span>"dog"</span>:
        a = reflect.New(reflect.TypeOf(Dog{})).Interface().(Animal)
    <span>case</span> <span>"cat"</span>:
        a = reflect.New(reflect.TypeOf(Cat{})).Interface().(Animal)
    }
    <span>return</span> a
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    dog := CreateAnimal(<span>"dog"</span>)
    cat := CreateAnimal(<span>"cat"</span>)
    fmt.Println(dog.Speak()) <span>// Вывод: Woof</span>
    fmt.Println(cat.Speak()) <span>// Вывод: Meow</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание системы с использованием рефлексии для создания объектов с разными параметрами</strong></p><ul><li>Задача: Создайте систему с использованием рефлексии для создания объектов с разными параметрами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>CreatePerson</span><span>(name <span>string</span>, age <span>int</span>)</span></span> <span>interface</span>{} {
    pType := reflect.TypeOf(Person{})
    pValue := reflect.New(pType).Elem()
    pValue.FieldByName(<span>"Name"</span>).SetString(name)
    pValue.FieldByName(<span>"Age"</span>).SetInt(<span>int64</span>(age))
    <span>return</span> pValue.Interface()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := CreatePerson(<span>"Alice"</span>, <span>30</span>).(Person)
    fmt.Println(<span>"Created Person:"</span>, p) <span>// Вывод: Created Person: {Alice 30}</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание системы с динамическим вызовом методов и обработкой ошибок</strong></p><ul><li>Задача: Создайте систему с динамическим вызовом методов и обработкой ошибок.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
}

<span><span>func</span> <span>(p Person)</span></span> Greet() {
    fmt.Println(<span>"Hello,"</span>, p.Name)
}

<span><span>func</span> <span>(p Person)</span></span> InvalidMethod() {}

<span><span>func</span> <span>CallMethod</span><span>(p <span>interface</span>{}, methodName <span>string</span>)</span></span> {
    val := reflect.ValueOf(p)
    method := val.MethodByName(methodName)
    <span>if</span> method.IsValid() {
        method.Call(<span>nil</span>)
    } <span>else</span> {
        fmt.Println(<span>"Method not found:"</span>, methodName)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := Person{Name: <span>"Alice"</span>}
    CallMethod(p, <span>"Greet"</span>)         <span>// Вывод: Hello, Alice</span>
    CallMethod(p, <span>"InvalidMethod"</span>) <span>// Вывод: Method not found: InvalidMethod</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание системы с динамическим изменением полей и проверкой типов</strong></p><ul><li>Задача: Создайте систему с динамическим изменением полей и проверкой типов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"reflect"</span>
)

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>UpdateField</span><span>(p <span>interface</span>{}, fieldName <span>string</span>, value <span>interface</span>{})</span></span> {
    val := reflect.ValueOf(p).Elem()
    field := val.FieldByName(fieldName)
    <span>if</span> field.IsValid() &amp;&amp; field.CanSet() {
        v := reflect.ValueOf(value)
        <span>if</span> v.Type().AssignableTo(field.Type()) {
            field.Set(v)
        } <span>else</span> {
            fmt.Println(<span>"Cannot set field:"</span>, fieldName)
        }
    } <span>else</span> {
        fmt.Println(<span>"Field not found or cannot be set:"</span>, fieldName)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    p := &amp;Person{Name: <span>"Alice"</span>, Age: <span>30</span>}
    UpdateField(p, <span>"Age"</span>, <span>35</span>)
    fmt.Println(<span>"Updated Age:"</span>, p.Age) <span>// Вывод: Updated Age: 35</span>
    UpdateField(p, <span>"Name"</span>, <span>"Bob"</span>)
    fmt.Println(<span>"Updated Name:"</span>, p.Name) <span>// Вывод: Updated Name: Bob</span>
    UpdateField(p, <span>"Age"</span>, <span>"not an int"</span>) <span>// Вывод: Cannot set field: Age</span>
}
</code></div></div></pre></li></ul></li></ol><h3>Примечания</h3><ol><li><p><strong>Изменение структуры</strong></p><ul><li>Если необходимо, можно изменить структуру задач и решений, добавив дополнительные примеры или изменив существующие.</li></ul></li><li><p><strong>Подбор задач</strong></p><ul><li>Можно выбрать наиболее подходящие задачи для вашей аудитории или уровня сложности.</li></ul></li><li><p><strong>Справочные материалы</strong></p><ul><li>Рассмотрите возможность добавления ссылок на документацию или учебные ресурсы по каждому разделу, чтобы читатели могли углубиться в тему.</li></ul></li><li><p><strong>Рекомендуемые книги</strong></p><ul><li>Вы можете также предложить список рекомендуемых книг по Go и рефлексии для дальнейшего изучения.</li></ul></li></ol><h3></h3></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div><div><svg width="41" height="41" viewBox="0 0 41 41" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-md" role="img"><text x="-9999" y="-9999"></text></svg></div></div></div></div></div><div><div><div><div dir="auto"><div><div><p></p><h2></h2><h1 id="heading-29" class="numbered" data-id="29" style="--bg-color: orange;">ГОРУТИНЫ</h1><p>Горутины — это функции, которые выполняются асинхронно и позволяют параллельно выполнять задачи.</p><h3>Базовые задачи</h3><ol><li><p><strong>Создание горутины</strong></p><ul><li>Задача: Запустить функцию как горутину.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
)

<span><span>func</span> <span>printMessage</span><span>()</span></span> {
    fmt.Println(<span>"Hello from Goroutine!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>go</span> printMessage() <span>// Запускаем функцию в отдельной горутине</span>
    fmt.Println(<span>"Main function"</span>)
}
</code></div></div></pre><em>Назначение</em>: <code>go</code> перед функцией запускает её как горутину, то есть параллельно с основной функцией.</li></ul></li><li><p><strong>Горутина с анонимной функцией</strong></p><ul><li>Задача: Использовать анонимную функцию в горутине.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>go</span> <span><span>func</span><span>()</span></span> {
        fmt.Println(<span>"Anonymous Goroutine"</span>)
    }() <span>// Анонимная функция выполняется в отдельной горутине</span>
    fmt.Println(<span>"Main function"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Передача параметров в горутину</strong></p><ul><li>Задача: Передать параметры в горутину.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
)

<span><span>func</span> <span>printNumber</span><span>(n <span>int</span>)</span></span> {
    fmt.Println(<span>"Number:"</span>, n)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>go</span> printNumber(<span>42</span>) <span>// Передаем значение 42 в горутину</span>
    fmt.Println(<span>"Main function"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Горутина с циклом</strong></p><ul><li>Задача: Запустить цикл в горутине.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>printNumbers</span><span>()</span></span> {
    <span>for</span> i := <span>1</span>; i &lt;= <span>5</span>; i++ {
        fmt.Println(i)
        time.Sleep(<span>100</span> * time.Millisecond)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>go</span> printNumbers()
    time.Sleep(<span>600</span> * time.Millisecond) <span>// Ждем завершения горутины</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Ожидание завершения горутины с помощью <code>time.Sleep</code></strong></p><ul><li>Задача: Ожидать выполнения горутины.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>longTask</span><span>()</span></span> {
    time.Sleep(<span>2</span> * time.Second)
    fmt.Println(<span>"Task finished"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>go</span> longTask()
    fmt.Println(<span>"Waiting for task"</span>)
    time.Sleep(<span>3</span> * time.Second) <span>// Ждем завершения задачи</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание нескольких горутин</strong></p><ul><li>Задача: Создать несколько горутин.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>printMessage</span><span>(id <span>int</span>)</span></span> {
    fmt.Println(<span>"Goroutine:"</span>, id)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>for</span> i := <span>1</span>; i &lt;= <span>3</span>; i++ {
        <span>go</span> printMessage(i)
    }
    time.Sleep(<span>1</span> * time.Second) <span>// Ждем выполнения горутин</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Горутины с доступом к общей переменной</strong></p><ul><li>Задача: Модифицировать общую переменную в горутине.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>updateValue</span><span>(n *<span>int</span>)</span></span> {
    *n++
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    num := <span>0</span>
    <span>go</span> updateValue(&amp;num)
    time.Sleep(<span>1</span> * time.Second)
    fmt.Println(<span>"Updated number:"</span>, num)
}
</code></div></div></pre></li></ul></li><li><p><strong>Передача данных между горутинами через канал</strong></p><ul><li>Задача: Использовать канал для передачи данных.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch := <span>make</span>(<span>chan</span> <span>int</span>) <span>// Создаем канал</span>

    <span>go</span> <span><span>func</span><span>()</span></span> {
        ch &lt;- <span>42</span> <span>// Отправляем данные в канал</span>
    }()

    val := &lt;-ch <span>// Получаем данные из канала</span>
    fmt.Println(<span>"Received:"</span>, val)
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Одновременное выполнение нескольких горутин</strong></p><ul><li>Задача: Создать 10 горутин, каждая из которых выполняет отдельную задачу.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>task</span><span>(id <span>int</span>)</span></span> {
    fmt.Printf(<span>"Task %d started\n"</span>, id)
    time.Sleep(<span>2</span> * time.Second)
    fmt.Printf(<span>"Task %d finished\n"</span>, id)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>for</span> i := <span>1</span>; i &lt;= <span>10</span>; i++ {
        <span>go</span> task(i)
    }
    time.Sleep(<span>5</span> * time.Second) <span>// Ожидание завершения всех горутин</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Горутины с мьютексом для синхронизации доступа к общей переменной</strong></p><ul><li>Задача: Использовать мьютекс для безопасного изменения переменной в нескольких горутинах.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> mu sync.Mutex
    count := <span>0</span>

    <span>for</span> i := <span>1</span>; i &lt;= <span>5</span>; i++ {
        <span>go</span> <span><span>func</span><span>(id <span>int</span>)</span></span> {
            mu.Lock() <span>// Захватываем мьютекс</span>
            count++
            fmt.Printf(<span>"Goroutine %d incremented count to %d\n"</span>, id, count)
            mu.Unlock() <span>// Освобождаем мьютекс</span>
        }(i)
    }

    <span>// Ожидание выполнения всех горутин</span>
    time.Sleep(<span>1</span> * time.Second)
    fmt.Println(<span>"Final count:"</span>, count)
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование канала для синхронизации между горутинами</strong></p><ul><li>Задача: Синхронизировать горутины через канал.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>task</span><span>(done <span>chan</span> <span>bool</span>)</span></span> {
    fmt.Println(<span>"Task started"</span>)
    done &lt;- <span>true</span> <span>// Сообщаем, что задача завершена</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    done := <span>make</span>(<span>chan</span> <span>bool</span>)
    <span>go</span> task(done)

    &lt;-done <span>// Ожидаем завершения задачи</span>
    fmt.Println(<span>"Task finished"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование <code>sync.WaitGroup</code> для ожидания завершения всех горутин</strong></p><ul><li>Задача: Использовать <code>WaitGroup</code> для ожидания завершения всех горутин.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>task</span><span>(id <span>int</span>, wg *sync.WaitGroup)</span></span> {
    fmt.Printf(<span>"Task %d started\n"</span>, id)
    <span>defer</span> wg.Done() <span>// Уменьшаем счетчик WaitGroup</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup

    <span>for</span> i := <span>1</span>; i &lt;= <span>5</span>; i++ {
        wg.Add(<span>1</span>) <span>// Увеличиваем счетчик</span>
        <span>go</span> task(i, &amp;wg)
    }

    wg.Wait() <span>// Ожидаем завершения всех горутин</span>
    fmt.Println(<span>"All tasks finished"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Реализация производитель-потребитель с использованием каналов</strong></p><ul><li>Задача: Использовать каналы для передачи данных между производителем и потребителем.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>producer</span><span>(ch <span>chan</span>&lt;- <span>int</span>)</span></span> {
    <span>for</span> i := <span>1</span>; i &lt;= <span>5</span>; i++ {
        ch &lt;- i
    }
    <span>close</span>(ch) <span>// Закрываем канал после отправки всех данных</span>
}

<span><span>func</span> <span>consumer</span><span>(ch &lt;-<span>chan</span> <span>int</span>)</span></span> {
    <span>for</span> val := <span>range</span> ch {
        fmt.Println(<span>"Consumed:"</span>, val)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch := <span>make</span>(<span>chan</span> <span>int</span>)

    <span>go</span> producer(ch) <span>// Запускаем производителя</span>
    <span>go</span> consumer(ch) <span>// Запускаем потребителя</span>

    <span>// Ожидание завершения</span>
    time.Sleep(<span>1</span> * time.Second)
}
</code></div></div></pre></li></ul></li></ol><h2></h2><h1 id="heading-30" class="numbered" data-id="30" style="--bg-color: purple;"></h1></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h2></h2><h1 id="heading-31" class="numbered" data-id="31" style="--bg-color: pink;">КАНАЛЫ</h1><p>Каналы позволяют горутинам обмениваться данными. Они синхронизируют потоки выполнения, обеспечивая передачу данных через однонаправленные или двунаправленные каналы.</p><h3>Базовые задачи</h3><ol><li><p><strong>Однонаправленный канал (Только отправка)</strong></p><ul><li>Задача: Создать канал, который может только отправлять данные.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>sendData</span><span>(ch <span>chan</span>&lt;- <span>int</span>)</span></span> {
    ch &lt;- <span>42</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch := <span>make</span>(<span>chan</span> <span>int</span>)
    <span>go</span> sendData(ch)
    fmt.Println(<span>"Received:"</span>, &lt;-ch)
}
</code></div></div></pre><em>Назначение</em>: Канал <code>chan&lt;- int</code> только отправляет данные.</li></ul></li><li><p><strong>Однонаправленный канал (Только получение)</strong></p><ul><li>Задача: Создать канал, который может только принимать данные.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>receiveData</span><span>(ch &lt;-<span>chan</span> <span>int</span>)</span></span> {
    fmt.Println(<span>"Received:"</span>, &lt;-ch)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch := <span>make</span>(<span>chan</span> <span>int</span>)
    <span>go</span> receiveData(ch)
    ch &lt;- <span>42</span>
}
</code></div></div></pre><em>Назначение</em>: Канал <code>&lt;-chan int</code> только получает данные.</li></ul></li><li><p><strong>Буферизированный канал</strong></p><ul><li>Задача: Создать буферизированный канал для передачи данных.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch := <span>make</span>(<span>chan</span> <span>int</span>, <span>2</span>) <span>// Создаем канал с буфером на 2 элемента</span>
    ch &lt;- <span>1</span>
    ch &lt;- <span>2</span>
    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
}
</code></div></div></pre><em>Назначение</em>: Буферизированный канал позволяет передавать данные без ожидания получения до заполнения буфера.</li></ul></li><li><p><strong>Закрытие канала</strong></p><ul><li>Задача: Закрыть канал и обработать попытку получения данных после его закрытия.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch := <span>make</span>(<span>chan</span> <span>int</span>, <span>2</span>)
    ch &lt;- <span>1</span>
    ch &lt;- <span>2</span>
    <span>close</span>(ch)

    <span>for</span> val := <span>range</span> ch {
        fmt.Println(val) <span>// Выведет 1 и 2</span>
    }
}
</code></div></div></pre><em>Назначение</em>: Закрытие канала предотвращает дальнейшую отправку данных, но можно продолжать получать оставшиеся данные.</li></ul></li><li><p><strong>Выбор каналов с помощью <code>select</code></strong></p><ul><li>Задача: Использовать <code>select</code> для работы с несколькими каналами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch1 := <span>make</span>(<span>chan</span> <span>string</span>)
    ch2 := <span>make</span>(<span>chan</span> <span>string</span>)

    <span>go</span> <span><span>func</span><span>()</span></span> {
        ch1 &lt;- <span>"Message from ch1"</span>
    }()

    <span>go</span> <span><span>func</span><span>()</span></span> {
        ch2 &lt;- <span>"Message from ch2"</span>
    }()

    <span>select</span> {
    <span>case</span> msg := &lt;-ch1:
        fmt.Println(msg)
    <span>case</span> msg := &lt;-ch2:
        fmt.Println(msg)
    }
}
</code></div></div></pre><em>Назначение</em>: <code>select</code> выбирает первое доступное значение из нескольких каналов.</li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Реализация нескольких производителей и одного потребителя с каналами</strong></p><ul><li>Задача: Реализовать несколько производителей данных, отправляющих информацию в один канал для обработки потребителем.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>producer</span><span>(id <span>int</span>, ch <span>chan</span>&lt;- <span>int</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    <span>for</span> i := <span>0</span>; i &lt; <span>5</span>; i++ {
        ch &lt;- id*<span>10</span> + i
    }
}

<span><span>func</span> <span>consumer</span><span>(ch &lt;-<span>chan</span> <span>int</span>, done <span>chan</span>&lt;- <span>bool</span>)</span></span> {
    <span>for</span> val := <span>range</span> ch {
        fmt.Println(<span>"Consumed:"</span>, val)
    }
    done &lt;- <span>true</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch := <span>make</span>(<span>chan</span> <span>int</span>)
    done := <span>make</span>(<span>chan</span> <span>bool</span>)
    <span>var</span> wg sync.WaitGroup

    <span>for</span> i := <span>1</span>; i &lt;= <span>3</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> producer(i, ch, &amp;wg)
    }

    <span>go</span> <span><span>func</span><span>()</span></span> {
        wg.Wait()
        <span>close</span>(ch) <span>// Закрываем канал после завершения всех производителей</span>
    }()

    <span>go</span> consumer(ch, done)
    &lt;-done
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование таймаута с каналами</strong></p><ul><li>Задача: Реализовать таймаут при ожидании данных из канала.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch := <span>make</span>(<span>chan</span> <span>string</span>)

    <span>go</span> <span><span>func</span><span>()</span></span> {
        time.Sleep(<span>2</span> * time.Second)
        ch &lt;- <span>"Task completed"</span>
    }()

    <span>select</span> {
    <span>case</span> msg := &lt;-ch:
        fmt.Println(msg)
    <span>case</span> &lt;-time.After(<span>1</span> * time.Second):
        fmt.Println(<span>"Timeout!"</span>)
    }
}
</code></div></div></pre><em>Назначение</em>: Таймаут реализован с помощью <code>time.After</code>, который возвращает канал через определенное время.</li></ul></li><li><p><strong>Реализация многоканальной синхронизации с использованием <code>select</code></strong></p><ul><li>Задача: Реализовать синхронизацию между несколькими каналами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch1 := <span>make</span>(<span>chan</span> <span>string</span>)
    ch2 := <span>make</span>(<span>chan</span> <span>string</span>)

    <span>go</span> <span><span>func</span><span>()</span></span> {
        ch1 &lt;- <span>"Data from ch1"</span>
    }()

    <span>go</span> <span><span>func</span><span>()</span></span> {
        ch2 &lt;- <span>"Data from ch2"</span>
    }()

    <span>for</span> i := <span>0</span>; i &lt; <span>2</span>; i++ {
        <span>select</span> {
        <span>case</span> msg1 := &lt;-ch1:
            fmt.Println(msg1)
        <span>case</span> msg2 := &lt;-ch2:
            fmt.Println(msg2)
        }
    }
}
</code></div></div></pre></li></ul></li></ol><h2></h2><h1 id="heading-32" class="numbered" data-id="32" style="--bg-color: red;">ЗАКРЫТИЕ КАНАЛА</h1><p>Закрытие канала сигнализирует горутинам, что данные больше не будут отправляться в канал.</p><h3>Базовые задачи</h3><ol><li><p><strong>Закрытие канала после передачи всех данных</strong></p><ul><li>Задача: Закрыть канал после завершения всех операций записи.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch := <span>make</span>(<span>chan</span> <span>int</span>)

    <span>go</span> <span><span>func</span><span>()</span></span> {
        <span>for</span> i := <span>0</span>; i &lt; <span>5</span>; i++ {
            ch &lt;- i
        }
        <span>close</span>(ch) <span>// Закрываем канал</span>
    }()

    <span>for</span> val := <span>range</span> ch {
        fmt.Println(val)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка закрытого канала</strong></p><ul><li>Задача: Использовать цикл <code>for-range</code> для чтения всех данных из закрытого канала.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch := <span>make</span>(<span>chan</span> <span>int</span>)

    <span>go</span> <span><span>func</span><span>()</span></span> {
        <span>for</span> i := <span>1</span>; i &lt;= <span>3</span>; i++ {
            ch &lt;- i
        }
        <span>close</span>(ch)
    }()

    <span>for</span> val := <span>range</span> ch {
        fmt.Println(val) <span>// Обрабатываем все значения до закрытия канала</span>
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Проверка статуса закрытого канала с помощью второго возвращаемого значения</strong></p><ul><li>Задача: Проверить, закрыт ли канал.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch := <span>make</span>(<span>chan</span> <span>int</span>)

    <span>go</span> <span><span>func</span><span>()</span></span> {
        ch &lt;- <span>42</span>
        <span>close</span>(ch)
    }()

    val, ok := &lt;-ch <span>// Второе значение — флаг, показывает, закрыт канал или нет</span>
    <span>if</span> ok {
        fmt.Println(<span>"Received:"</span>, val)
    } <span>else</span> {
        fmt.Println(<span>"Channel closed"</span>)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование закрытого канала для оповещения</strong></p><ul><li>Задача: Использовать закрытие канала для оповещения о завершении задачи.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    done := <span>make</span>(<span>chan</span> <span>struct</span>{})

    <span>go</span> <span><span>func</span><span>()</span></span> {
        fmt.Println(<span>"Task is done"</span>)
        <span>close</span>(done) <span>// Закрытие канала как сигнал завершения</span>
    }()

    &lt;-done <span>// Ожидаем закрытия канала</span>
    fmt.Println(<span>"Main function exits"</span>)
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Одновременная работа с несколькими каналами и проверка на закрытие</strong></p><ul><li>Задача: Реализовать обработку нескольких каналов и проверку их закрытия.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
    ch1 := <span>make</span>(<span>chan</span> <span>int</span>)
    ch2 := <span>make</span>(<span>chan</span> <span>int</span>)

    <span>go</span> <span><span>func</span><span>()</span></span> {
        <span>for</span> i := <span>1</span>; i &lt;= <span>3</span>; i++ {
            ch1 &lt;- i
        }
        <span>close</span>(ch1)
    }()

    <span>go</span> <span><span>func</span><span>()</span></span> {
        <span>for</span> i := <span>4</span>; i &lt;= <span>6</span>; i++ {
            ch2 &lt;- i
        }
        <span>close</span>(ch2)
    }()

    <span>for</span> ch1 != <span>nil</span> || ch2 != <span>nil</span> {
        <span>select</span> {
        <span>case</span> val, ok := &lt;-ch1:
            <span>if</span> ok {
                fmt.Println(<span>"From ch1:"</span>, val)
            } <span>else</span> {
                ch1 = <span>nil</span>
            }
        <span>case</span> val, ok := &lt;-ch2:
            <span>if</span> ok {
                fmt.Println(<span>"From ch2:"</span>, val)
            } <span>else</span> {
                ch2 = <span>nil</span>
            }
        }
    }
    fmt.Println(<span>"All channels closed"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование закрытого канала для синхронизации работы нескольких горутин</strong></p><ul><li>Задача: Синхронизировать несколько горутин с использованием закрытия каналов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>worker</span><span>(id <span>int</span>, done &lt;-<span>chan</span> <span>struct</span>{}, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    <span>for</span> {
        <span>select</span> {
        <span>case</span> &lt;-done:
            fmt.Printf(<span>"Worker %d stopping\n"</span>, id)
            <span>return</span>
        <span>default</span>:
            fmt.Printf(<span>"Worker %d is working\n"</span>, id)
        }
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    done := <span>make</span>(<span>chan</span> <span>struct</span>{})

    <span>for</span> i := <span>1</span>; i &lt;= <span>3</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> worker(i, done, &amp;wg)
    }

    fmt.Println(<span>"Press any key to stop workers..."</span>)
    fmt.Scanln() <span>// Ждем ввода</span>

    <span>close</span>(done) <span>// Закрываем канал и останавливаем всех воркеров</span>
    wg.Wait()
    fmt.Println(<span>"All workers stopped"</span>)
}
</code></div></div></pre></li></ul></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h2></h2><h1 id="heading-33" class="numbered" data-id="33" style="--bg-color: blue;">СИНХРОНИЗАЦИЯ</h1><p>Синхронизация потоков — это координация доступа к общим ресурсам между несколькими горутинами, чтобы избежать состояния гонки и других проблем параллельного выполнения.</p><h3>Базовые задачи</h3><ol><li><p><strong>Синхронизация с помощью <code>sync.Mutex</code></strong></p><ul><li>Задача: Реализовать безопасный доступ к переменной с помощью мьютекса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> (
    counter <span>int</span>
    mutex   sync.Mutex
)

<span><span>func</span> <span>increment</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    counter++
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>0</span>; i &lt; <span>10</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> increment(&amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"Final Counter:"</span>, counter)
}
</code></div></div></pre><em>Назначение</em>: Мьютекс (Mutex) используется для блокировки доступа к общему ресурсу — переменной <code>counter</code>.</li></ul></li><li><p><strong>Использование <code>sync.RWMutex</code> для чтения и записи</strong></p><ul><li>Задача: Разделить доступ для чтения и записи к переменной.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> (
    value <span>int</span>
    rwMutex sync.RWMutex
)

<span><span>func</span> <span>read</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    rwMutex.RLock()
    fmt.Println(<span>"Read Value:"</span>, value)
    rwMutex.RUnlock()
}

<span><span>func</span> <span>write</span><span>(newValue <span>int</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    rwMutex.Lock()
    value = newValue
    fmt.Println(<span>"Written Value:"</span>, newValue)
    rwMutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    wg.Add(<span>2</span>)
    <span>go</span> write(<span>42</span>, &amp;wg)
    <span>go</span> read(&amp;wg)
    wg.Wait()
}
</code></div></div></pre><em>Назначение</em>: <code>sync.RWMutex</code> позволяет разделить блокировки для чтения (RLock) и записи (Lock).</li></ul></li><li><p><strong>Горутины с одновременным чтением данных</strong></p><ul><li>Задача: Реализовать безопасное чтение из общего ресурса несколькими горутинами одновременно.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> counter <span>int</span>
<span>var</span> mutex sync.Mutex

<span><span>func</span> <span>readData</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    fmt.Println(<span>"Read Counter:"</span>, counter)
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    counter = <span>42</span>
    <span>for</span> i := <span>0</span>; i &lt; <span>5</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> readData(&amp;wg)
    }
    wg.Wait()
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование каналов для синхронизации работы горутин</strong></p><ul><li>Задача: Использовать каналы для синхронизации завершения работы всех горутин.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
)

<span><span>func</span> <span>worker</span><span>(done <span>chan</span> <span>bool</span>)</span></span> {
    fmt.Println(<span>"Worker started"</span>)
    <span>// some work</span>
    done &lt;- <span>true</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    done := <span>make</span>(<span>chan</span> <span>bool</span>)
    <span>go</span> worker(done)
    &lt;-done <span>// Ожидаем завершения горутины</span>
    fmt.Println(<span>"Worker finished"</span>)
}
</code></div></div></pre><em>Назначение</em>: Канал используется для синхронизации между главной горутиной и рабочей горутиной.</li></ul></li><li><p><strong>Простая синхронизация с помощью <code>sync.Once</code></strong></p><ul><li>Задача: Гарантировать выполнение кода только один раз при использовании нескольких горутин.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> once sync.Once

<span><span>func</span> <span>initialize</span><span>()</span></span> {
    fmt.Println(<span>"Initialized"</span>)
}

<span><span>func</span> <span>worker</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    once.Do(initialize)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>0</span>; i &lt; <span>3</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> worker(&amp;wg)
    }
    wg.Wait()
}
</code></div></div></pre><em>Назначение</em>: <code>sync.Once</code> гарантирует, что функция <code>initialize</code> будет выполнена только один раз, даже если её вызывают несколько горутин.</li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Реализация синхронизированного счетчика с несколькими горутинами</strong></p><ul><li>Задача: Синхронизировать доступ к счетчику для нескольких горутин.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> counter <span>int</span>
<span>var</span> mutex sync.Mutex

<span><span>func</span> <span>increment</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    counter++
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup

    <span>for</span> i := <span>0</span>; i &lt; <span>100</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> increment(&amp;wg)
    }

    wg.Wait()
    fmt.Println(<span>"Final Counter:"</span>, counter)
}
</code></div></div></pre><em>Назначение</em>: В данном примере обеспечена синхронизация доступа к переменной <code>counter</code> для предотвращения состояния гонки.</li></ul></li><li><p><strong>Использование RWMutex для одновременного чтения и эксклюзивного изменения данных</strong></p><ul><li>Задача: Одновременно позволить нескольким горутинам читать данные, но не позволять изменять их.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> (
    counter  <span>int</span>
    rwMutex  sync.RWMutex
)

<span><span>func</span> <span>read</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    rwMutex.RLock()
    fmt.Println(<span>"Read Counter:"</span>, counter)
    rwMutex.RUnlock()
}

<span><span>func</span> <span>write</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    rwMutex.Lock()
    counter++
    rwMutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup

    <span>for</span> i := <span>0</span>; i &lt; <span>5</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> read(&amp;wg)
    }

    wg.Add(<span>1</span>)
    <span>go</span> write(&amp;wg)

    wg.Wait()
}
</code></div></div></pre><em>Назначение</em>: Здесь <code>RWMutex</code> позволяет горутинам читать данные одновременно, но записывать данные может только одна горутина.</li></ul></li><li><p><strong>Использование каналов для синхронизации выполнения нескольких задач</strong></p><ul><li>Задача: Синхронизировать выполнение нескольких задач через каналы и обработать их по завершению.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> <span>"fmt"</span>

<span><span>func</span> <span>worker</span><span>(id <span>int</span>, done <span>chan</span>&lt;- <span>bool</span>)</span></span> {
    fmt.Printf(<span>"Worker %d is working...\n"</span>, id)
    done &lt;- <span>true</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    done := <span>make</span>(<span>chan</span> <span>bool</span>)
    <span>for</span> i := <span>1</span>; i &lt;= <span>3</span>; i++ {
        <span>go</span> worker(i, done)
    }

    <span>for</span> i := <span>1</span>; i &lt;= <span>3</span>; i++ {
        &lt;-done <span>// Ожидаем завершения каждой горутины</span>
    }
    fmt.Println(<span>"All workers are done"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Модифицированная синхронизация с использованием <code>sync.Cond</code></strong></p><ul><li>Задача: Использовать условную синхронизацию для передачи данных между горутинами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> cond = sync.NewCond(&amp;sync.Mutex{})
<span>var</span> ready = <span>false</span>

<span><span>func</span> <span>worker</span><span>(id <span>int</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    cond.L.Lock()
    <span>for</span> !ready {
        cond.Wait() <span>// Ждем, пока ready не станет true</span>
    }
    fmt.Printf(<span>"Worker %d is working\n"</span>, id)
    cond.L.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>1</span>; i &lt;= <span>3</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> worker(i, &amp;wg)
    }

    <span>// Подготавливаем данные и уведомляем рабочих</span>
    cond.L.Lock()
    ready = <span>true</span>
    cond.Broadcast() <span>// Уведомляем всех рабочих</span>
    cond.L.Unlock()

    wg.Wait()
}
</code></div></div></pre><em>Назначение</em>: <code>sync.Cond</code> используется для координации доступа к общим данным на основе условия, с использованием сигналов.</li></ul></li></ol><h2></h2><h1 id="heading-34" class="numbered" data-id="34" style="--bg-color: green;">МЬЮТЕКСЫ</h1><p>Мьютексы (mutex) — это инструменты для блокировки доступа к общим ресурсам, что предотвращает состояние гонки между горутинами.</p><h3>Базовые задачи</h3><ol><li><strong>Использование мьютекса для защиты данных</strong><ul><li>Задача: Защитить общий счетчик с помощью мьютекса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> counter <span>int</span>
<span>var</span> mutex sync.Mutex

<span><span>func</span> <span>increment</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    counter++
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>0</span>; i &lt; <span>10</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> increment(&amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"Final Counter:"</span>, counter)
}
</code></div></div></pre></li></ul></li></ol></div></div></div></div><div><div></div></div></div></div></div></div></article><article dir="auto"><h5></h5></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><h3></h3><ol start="2"><li><p><strong>Счетчик с мьютексом и несколькими горутинами</strong></p><ul><li>Задача: Создать несколько горутин, которые одновременно инкрементируют общий счетчик.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> (
    counter <span>int</span>
    mutex   sync.Mutex
)

<span><span>func</span> <span>increment</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    counter++
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>0</span>; i &lt; <span>100</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> increment(&amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"Final Counter:"</span>, counter)
}
</code></div></div></pre><em>Назначение</em>: Мьютекс используется для предотвращения состояния гонки при одновременном доступе нескольких горутин к переменной <code>counter</code>.</li></ul></li><li><p><strong>Безопасный доступ к массиву с помощью мьютекса</strong></p><ul><li>Задача: Обеспечить безопасный доступ к элементам массива.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> (
    arr   = [<span>5</span>]<span>int</span>{}
    mutex sync.Mutex
)

<span><span>func</span> <span>writeArray</span><span>(index, value <span>int</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    arr[index] = value
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>0</span>; i &lt; <span>5</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> writeArray(i, i*<span>10</span>, &amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"Array:"</span>, arr)
}
</code></div></div></pre></li></ul></li><li><p><strong>Мьютекс для блокировки при чтении и записи</strong></p><ul><li>Задача: Разделить блокировки для чтения и записи.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> (
    data  <span>int</span>
    mutex sync.Mutex
)

<span><span>func</span> <span>readData</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    fmt.Println(<span>"Read Data:"</span>, data)
    mutex.Unlock()
}

<span><span>func</span> <span>writeData</span><span>(value <span>int</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    data = value
    fmt.Println(<span>"Written Data:"</span>, value)
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    wg.Add(<span>2</span>)
    <span>go</span> writeData(<span>42</span>, &amp;wg)
    <span>go</span> readData(&amp;wg)
    wg.Wait()
}
</code></div></div></pre></li></ul></li><li><p><strong>Синхронизация с использованием <code>sync.RWMutex</code></strong></p><ul><li>Задача: Обеспечить одновременный доступ для чтения и эксклюзивный доступ для записи.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> (
    data     <span>int</span>
    rwMutex  sync.RWMutex
)

<span><span>func</span> <span>readData</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    rwMutex.RLock()
    fmt.Println(<span>"Read Data:"</span>, data)
    rwMutex.RUnlock()
}

<span><span>func</span> <span>writeData</span><span>(value <span>int</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    rwMutex.Lock()
    data = value
    rwMutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    wg.Add(<span>3</span>)

    <span>go</span> writeData(<span>10</span>, &amp;wg)
    <span>go</span> readData(&amp;wg)
    <span>go</span> readData(&amp;wg)

    wg.Wait()
    fmt.Println(<span>"Final Data:"</span>, data)
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Использование мьютексов для управления состоянием</strong></p><ul><li>Задача: Создать состояние системы и управлять им с помощью мьютексов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> (
    status = <span>"Idle"</span>
    mutex  sync.Mutex
)

<span><span>func</span> <span>changeStatus</span><span>(newStatus <span>string</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    status = newStatus
    fmt.Println(<span>"Status changed to:"</span>, status)
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    wg.Add(<span>3</span>)

    <span>go</span> changeStatus(<span>"Running"</span>, &amp;wg)
    <span>go</span> changeStatus(<span>"Stopped"</span>, &amp;wg)
    <span>go</span> changeStatus(<span>"Idle"</span>, &amp;wg)

    wg.Wait()
    fmt.Println(<span>"Final Status:"</span>, status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание простого пула горутин с мьютексами</strong></p><ul><li>Задача: Реализовать пул горутин, который использует мьютексы для управления состоянием.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> (
    wg      sync.WaitGroup
    mutex   sync.Mutex
    counter <span>int</span>
)

<span><span>func</span> <span>worker</span><span>(id <span>int</span>)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    counter++
    fmt.Printf(<span>"Worker %d incremented counter to %d\n"</span>, id, counter)
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>for</span> i := <span>1</span>; i &lt;= <span>5</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> worker(i)
    }
    wg.Wait()
    fmt.Println(<span>"Final Counter:"</span>, counter)
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание безопасного стека с помощью мьютекса</strong></p><ul><li>Задача: Реализовать стек с безопасным доступом с помощью мьютекса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>type</span> Stack <span>struct</span> {
    items []<span>int</span>
    mutex sync.Mutex
}

<span><span>func</span> <span>(s *Stack)</span></span> Push(item <span>int</span>) {
    s.mutex.Lock()
    s.items = <span>append</span>(s.items, item)
    s.mutex.Unlock()
}

<span><span>func</span> <span>(s *Stack)</span></span> Pop() <span>int</span> {
    s.mutex.Lock()
    <span>if</span> <span>len</span>(s.items) == <span>0</span> {
        s.mutex.Unlock()
        <span>return</span> <span>-1</span> <span>// Или можно вернуть ошибку</span>
    }
    item := s.items[<span>len</span>(s.items)<span>-1</span>]
    s.items = s.items[:<span>len</span>(s.items)<span>-1</span>]
    s.mutex.Unlock()
    <span>return</span> item
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    stack := &amp;Stack{}

    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>0</span>; i &lt; <span>5</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> <span><span>func</span><span>(i <span>int</span>)</span></span> {
            <span>defer</span> wg.Done()
            stack.Push(i)
        }(i)
    }

    wg.Wait()
    fmt.Println(<span>"Stack Items:"</span>, stack.items)
}
</code></div></div></pre></li></ul></li><li><p><strong>Критическая секция с мьютексом</strong></p><ul><li>Задача: Реализовать критическую секцию, в которой только одна горутина может выполнять действия одновременно.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> (
    counter <span>int</span>
    mutex   sync.Mutex
)

<span><span>func</span> <span>criticalSection</span><span>(id <span>int</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    counter++
    fmt.Printf(<span>"Goroutine %d entered critical section. Counter: %d\n"</span>, id, counter)
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>0</span>; i &lt; <span>5</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> criticalSection(i, &amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"Final Counter:"</span>, counter)
}
</code></div></div></pre></li></ul></li><li><p><strong>Реализация простого счетчика с использованием мьютексов и горутин</strong></p><ul><li>Задача: Реализовать безопасный счетчик, который увеличивается несколькими горутинами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> (
    count <span>int</span>
    mutex sync.Mutex
)

<span><span>func</span> <span>increment</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    count++
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>0</span>; i &lt; <span>1000</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> increment(&amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"Final Count:"</span>, count)
}
</code></div></div></pre></li></ul></li></ol><h2></h2><h1 id="heading-35" class="numbered" data-id="35" style="--bg-color: orange;">WAITGROUP</h1><p><code>WaitGroup</code> — это структура, которая позволяет ожидать завершения группы горутин. Это полезно, когда нужно дождаться выполнения нескольких параллельных задач перед продолжением.</p><h3>Базовые задачи</h3><ol><li><p><strong>Использование <code>sync.WaitGroup</code> для ожидания завершения горутин</strong></p><ul><li>Задача: Создать несколько горутин и дождаться их завершения.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>worker</span><span>(id <span>int</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    fmt.Printf(<span>"Worker %d is working\n"</span>, id)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>1</span>; i &lt;= <span>5</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> worker(i, &amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"All workers completed"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Вычисление суммы квадратов с использованием <code>WaitGroup</code></strong></p><ul><li>Задача: Разделить вычисление суммы квадратов на несколько горутин.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>square</span><span>(n <span>int</span>, wg *sync.WaitGroup, result *<span>int</span>)</span></span> {
    <span>defer</span> wg.Done()
    *result += n * n
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    result := <span>0</span>

    <span>for</span> i := <span>1</span>; i &lt;= <span>5</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> square(i, &amp;wg, &amp;result)
    }
    wg.Wait()
    fmt.Println(<span>"Sum of squares:"</span>, result)
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание пула горутин с <code>WaitGroup</code></strong></p><ul><li>Задача: Реализовать пул горутин для выполнения заданий.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>task</span><span>(id <span>int</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    fmt.Printf(<span>"Task %d is executing\n"</span>, id)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>1</span>; i &lt;= <span>3</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> task(i, &amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"All tasks completed"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Счётчик с использованием <code>WaitGroup</code></strong></p><ul><li>Задача: Создать несколько горутин, которые будут инкрементировать общий счётчик.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span>var</span> count <span>int</span>
<span>var</span> mutex sync.Mutex

<span><span>func</span> <span>increment</span><span>(wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    mutex.Lock()
    count++
    mutex.Unlock()
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>0</span>; i &lt; <span>10</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> increment(&amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"Final Count:"</span>, count)
}
</code></div></div></pre></li></ul></li><li><p><strong>Выполнение нескольких запросов и ожидание их завершения с помощью <code>WaitGroup</code></strong></p><ul><li>Задача: Запустить несколько запросов (например, HTTP) и дождаться их завершения.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>fetch</span><span>(url <span>string</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    resp, err := http.Get(url)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error fetching:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Fetched:"</span>, url, <span>"Status Code:"</span>, resp.StatusCode)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    urls := []<span>string</span>{<span>"http://example.com"</span>, <span>"http://example.org"</span>, <span>"http://example.net"</span>}

    <span>for</span> _, url := <span>range</span> urls {
        wg.Add(<span>1</span>)
        <span>go</span> fetch(url, &amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"All requests completed"</span>)
}
</code></div></div></pre></li></ul></li></ol><h3>Сложные задачи</h3><ol><li><p><strong>Параллельное вычисление значений Фибоначчи с <code>WaitGroup</code></strong></p><ul><li>Задача: Вычислить значения Фибоначчи для нескольких чисел параллельно.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>fibonacci</span><span>(n <span>int</span>, wg *sync.WaitGroup, result *<span>int</span>)</span></span> {
    <span>defer</span> wg.Done()
    <span>if</span> n &lt;= <span>1</span> {
        *result = n
        <span>return</span>
    }
    fib1, fib2 := <span>0</span>, <span>0</span>
    <span>var</span> wgFib sync.WaitGroup
    wgFib.Add(<span>2</span>)
    <span>go</span> fibonacci(n<span>-1</span>, &amp;wgFib, &amp;fib1)
    <span>go</span> fibonacci(n<span>-2</span>, &amp;wgFib, &amp;fib2)
    wgFib.Wait()
    *result = fib1 + fib2
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>0</span>; i &lt;= <span>5</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> <span><span>func</span><span>(n <span>int</span>)</span></span> {
            <span>defer</span> wg.Done()
            <span>var</span> result <span>int</span>
            fibonacci(n, &amp;wg, &amp;result)
            fmt.Printf(<span>"Fibonacci(%d) = %d\n"</span>, n, result)
        }(i)
    }
    wg.Wait()
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание и обработка задач с использованием <code>WaitGroup</code> и канала</strong></p><ul><li>Задача: Создать задачи и отправить их на обработку в отдельные горутины.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>processTask</span><span>(task <span>int</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    fmt.Printf(<span>"Processing task %d\n"</span>, task)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    tasks := []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}

    <span>for</span> _, task := <span>range</span> tasks {
        wg.Add(<span>1</span>)
        <span>go</span> processTask(task, &amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"All tasks processed"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Счетчик слов в нескольких файлах с использованием <code>WaitGroup</code></strong></p><ul><li>Задача: Подсчитать количество слов в нескольких файлах параллельно.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bufio"</span>
    <span>"fmt"</span>
    <span>"os"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>countWords</span><span>(fileName <span>string</span>, wg *sync.WaitGroup, total *<span>int</span>)</span></span> {
    <span>defer</span> wg.Done()
    file, err := os.Open(fileName)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> file.Close()

    scanner := bufio.NewScanner(file)
    wordCount := <span>0</span>
    <span>for</span> scanner.Scan() {
        words := bufio.NewScanner(scanner.Text())
        words.Split(bufio.ScanWords)
        <span>for</span> words.Scan() {
            wordCount++
        }
    }

    *total += wordCount
    fmt.Printf(<span>"File %s has %d words\n"</span>, fileName, wordCount)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    totalWords := <span>0</span>
    files := []<span>string</span>{<span>"file1.txt"</span>, <span>"file2.txt"</span>}

    <span>for</span> _, file := <span>range</span> files {
        wg.Add(<span>1</span>)
        <span>go</span> countWords(file, &amp;wg, &amp;totalWords)
    }
    wg.Wait()
    fmt.Printf(<span>"Total words in all files: %d\n"</span>, totalWords)
}
</code></div></div></pre></li></ul></li><li><p><strong>Параллельная обработка данных из API с <code>WaitGroup</code></strong></p><ul><li>Задача: Обработать данные, полученные из нескольких API, параллельно.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>fetchAndProcess</span><span>(url <span>string</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    resp, err := http.Get(url)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Printf(<span>"Processed response from %s with status: %s\n"</span>, url, resp.Status)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    urls := []<span>string</span>{<span>"http://example.com"</span>, <span>"http://example.org"</span>}

    <span>for</span> _, url := <span>range</span> urls {
        wg.Add(<span>1</span>)
        <span>go</span> fetchAndProcess(url, &amp;wg)
    }
    wg.Wait()
    fmt.Println(<span>"All API requests processed"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Сбор данных о температуре с нескольких датчиков с <code>WaitGroup</code></strong></p><ul><li>Задача: Получить данные о температуре с нескольких источников параллельно и вывести среднее значение.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"math/rand"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>getTemperature</span><span>(wg *sync.WaitGroup, temperatures *[]<span>float64</span>)</span></span> {
    <span>defer</span> wg.Done()
    temp := rand.Float64()*<span>30</span> + <span>10</span> <span>// Генерация случайной температуры</span>
    *temperatures = <span>append</span>(*temperatures, temp)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>var</span> temperatures []<span>float64</span>
    <span>const</span> sensorCount = <span>5</span>

    <span>for</span> i := <span>0</span>; i &lt; sensorCount; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> getTemperature(&amp;wg, &amp;temperatures)
    }
    wg.Wait()

    <span>var</span> total <span>float64</span>
    <span>for</span> _, temp := <span>range</span> temperatures {
        total += temp
    }
    fmt.Printf(<span>"Average Temperature: %.2f°C\n"</span>, total/<span>float64</span>(sensorCount))
}
</code></div></div></pre></li></ul></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h3></h3><h1 id="heading-36" class="numbered" data-id="36" style="--bg-color: purple;">READER И WRITER</h1><h4>Базовые задачи</h4><ol><li><p><strong>Создание собственного типа, реализующего интерфейсы <code>io.Reader</code> и <code>io.Writer</code></strong></p><ul><li>Задача: Реализовать свой тип, который будет читать и записывать данные.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io"</span>
    <span>"strings"</span>
)

<span>type</span> MyReader <span>struct</span> {
    data <span>string</span>
}

<span><span>func</span> <span>(r *MyReader)</span></span> Read(p []<span>byte</span>) (n <span>int</span>, err <span>error</span>) {
    n = <span>copy</span>(p, r.data)
    r.data = r.data[n:]
    <span>if</span> n == <span>0</span> {
        err = io.EOF
    }
    <span>return</span>
}

<span>type</span> MyWriter <span>struct</span> {
    output *strings.Builder
}

<span><span>func</span> <span>(w *MyWriter)</span></span> Write(p []<span>byte</span>) (n <span>int</span>, err <span>error</span>) {
    n, err = w.output.Write(p)
    <span>return</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> builder strings.Builder
    writer := &amp;MyWriter{output: &amp;builder}

    writer.Write([]<span>byte</span>(<span>"Hello, World!"</span>))
    fmt.Println(builder.String()) <span>// Output: Hello, World!</span>

    reader := &amp;MyReader{data: <span>"Hello, Reader!"</span>}
    buf := <span>make</span>([]<span>byte</span>, <span>8</span>)
    n, _ := reader.Read(buf)
    fmt.Println(<span>string</span>(buf[:n])) <span>// Output: Hello, R</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование стандартного <code>io.Reader</code> и <code>io.Writer</code></strong></p><ul><li>Задача: Чтение из строки и запись в <code>os.Stdout</code>.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io"</span>
    <span>"os"</span>
    <span>"strings"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    reader := strings.NewReader(<span>"Hello, World!"</span>)
    io.Copy(os.Stdout, reader) <span>// Выводит: Hello, World!</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Чтение из файла с использованием <code>io.Reader</code></strong></p><ul><li>Задача: Прочитать содержимое файла и вывести на консоль.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    file, err := os.Open(<span>"example.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> file.Close()

    io.Copy(os.Stdout, file) <span>// Выводит содержимое файла</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Запись в файл с использованием <code>io.Writer</code></strong></p><ul><li>Задача: Записать данные в файл.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io/ioutil"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    data := []<span>byte</span>(<span>"Hello, File!"</span>)
    err := ioutil.WriteFile(<span>"output.txt"</span>, data, <span>0644</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Копирование данных между двумя <code>io.Reader</code> и <code>io.Writer</code></strong></p><ul><li>Задача: Скопировать содержимое одного файла в другой.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    sourceFile, err := os.Open(<span>"source.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> sourceFile.Close()

    destFile, err := os.Create(<span>"dest.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> destFile.Close()

    io.Copy(destFile, sourceFile) <span>// Копирует содержимое source.txt в dest.txt</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Считывание и запись по строкам</strong></p><ul><li>Задача: Считать строки из файла и записать в другой файл.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bufio"</span>
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    inputFile, err := os.Open(<span>"input.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> inputFile.Close()

    outputFile, err := os.Create(<span>"output.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> outputFile.Close()

    scanner := bufio.NewScanner(inputFile)
    writer := bufio.NewWriter(outputFile)

    <span>for</span> scanner.Scan() {
        writer.WriteString(scanner.Text() + <span>"\n"</span>)
    }
    writer.Flush() <span>// Обязательно очищаем буфер</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание буферизированного читателя и писателя</strong></p><ul><li>Задача: Использовать <code>bufio.NewReader</code> и <code>bufio.NewWriter</code> для работы с файлами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bufio"</span>
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    file, err := os.Create(<span>"buffered_output.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> file.Close()

    writer := bufio.NewWriter(file)
    writer.WriteString(<span>"Buffered Output\n"</span>)
    writer.Flush() <span>// Сбрасываем буфер</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование <code>io.MultiReader</code> и <code>io.MultiWriter</code></strong></p><ul><li>Задача: Использовать <code>io.MultiReader</code> для чтения из нескольких источников и <code>io.MultiWriter</code> для записи в несколько файлов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    file1, _ := os.Create(<span>"file1.txt"</span>)
    file2, _ := os.Create(<span>"file2.txt"</span>)
    multiWriter := io.MultiWriter(file1, file2)

    multiWriter.Write([]<span>byte</span>(<span>"Hello, MultiWriter!"</span>))

    file1.Close()
    file2.Close()
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Кастомный <code>io.Reader</code> для чтения данных из API</strong></p><ul><li>Задача: Реализовать собственный <code>Reader</code>, который будет считывать данные из HTTP API.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io"</span>
    <span>"net/http"</span>
)

<span>type</span> APIReader <span>struct</span> {
    resp *http.Response
}

<span><span>func</span> <span>(r *APIReader)</span></span> Read(p []<span>byte</span>) (n <span>int</span>, err <span>error</span>) {
    <span>return</span> r.resp.Body.Read(p)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    response, err := http.Get(<span>"http://example.com"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> response.Body.Close()

    reader := &amp;APIReader{resp: response}
    io.Copy(os.Stdout, reader) <span>// Выводит содержимое ответа</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Копирование файлов с учетом ошибок и повторов</strong></p><ul><li>Задача: Реализовать функцию, которая будет пытаться скопировать файл несколько раз при возникновении ошибки.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>copyFile</span><span>(src <span>string</span>, dest <span>string</span>, attempts <span>int</span>)</span></span> <span>error</span> {
    <span>var</span> err <span>error</span>
    <span>for</span> i := <span>0</span>; i &lt; attempts; i++ {
        sourceFile, err := os.Open(src)
        <span>if</span> err != <span>nil</span> {
            <span>return</span> err
        }
        <span>defer</span> sourceFile.Close()

        destFile, err := os.Create(dest)
        <span>if</span> err != <span>nil</span> {
            <span>return</span> err
        }
        <span>defer</span> destFile.Close()

        _, err = io.Copy(destFile, sourceFile)
        <span>if</span> err == <span>nil</span> {
            <span>return</span> <span>nil</span>
        }
    }
    <span>return</span> fmt.Errorf(<span>"failed to copy file after %d attempts: %v"</span>, attempts, err)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    err := copyFile(<span>"source.txt"</span>, <span>"dest.txt"</span>, <span>3</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Чтение и запись JSON с использованием <code>io.Reader</code> и <code>io.Writer</code></strong></p><ul><li>Задача: Считать JSON из файла, обработать его и записать обратно.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"encoding/json"</span>
    <span>"fmt"</span>
    <span>"io/ioutil"</span>
    <span>"os"</span>
)

<span>type</span> Data <span>struct</span> {
    Name  <span>string</span> <span>`json:"name"`</span>
    Value <span>int</span>    <span>`json:"value"`</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    inputFile, _ := os.Open(<span>"data.json"</span>)
    <span>defer</span> inputFile.Close()

    <span>var</span> data Data
    json.NewDecoder(inputFile).Decode(&amp;data)

    data.Value += <span>10</span> <span>// Обработка данных</span>

    outputFile, _ := os.Create(<span>"output.json"</span>)
    <span>defer</span> outputFile.Close()

    json.NewEncoder(outputFile).Encode(data)
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание логирования с использованием <code>io.Writer</code></strong></p><ul><li>Задача: Реализовать систему логирования, которая записывает логи в файл и выводит на консоль.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io"</span>
    <span>"log"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    file, err := os.OpenFile(<span>"app.log"</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span>0666</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> file.Close()

    multiWriter := io.MultiWriter(os.Stdout, file)
    logger := log.New(multiWriter, <span>"INFO: "</span>, log.Ldate|log.Ltime)

    logger.Println(<span>"This is a log message."</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Буферизированный ввод-вывод из файла</strong></p><ul><li>Задача: Реализовать буферизированное чтение и запись для большого файла.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bufio"</span>
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    inputFile, err := os.Open(<span>"largefile.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> inputFile.Close()

    scanner := bufio.NewScanner(inputFile)
    <span>for</span> scanner.Scan() {
        fmt.Println(scanner.Text())
    }

    outputFile, err := os.Create(<span>"output.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> outputFile.Close()

    writer := bufio.NewWriter(outputFile)
    <span>for</span> i := <span>0</span>; i &lt; <span>100</span>; i++ {
        writer.WriteString(fmt.Sprintf(<span>"Line %d\n"</span>, i))
    }
    writer.Flush()
}
</code></div></div></pre></li></ul></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h3></h3><h1 id="heading-37" class="numbered" data-id="37" style="--bg-color: pink;">СОЗДАНИЕ И ОТКРЫТИЕ ФАЙЛОВ</h1><h4>Базовые задачи</h4><ol><li><p><strong>Создать и открыть файл для записи</strong></p><ul><li>Задача: Создать файл и записать в него строку.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    file, err := os.Create(<span>"example.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> file.Close()

    file.WriteString(<span>"Hello, File!"</span>) <span>// Запись строки в файл</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Открыть существующий файл для чтения</strong></p><ul><li>Задача: Открыть файл и вывести его содержимое.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io/ioutil"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    data, err := ioutil.ReadFile(<span>"example.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    fmt.Println(<span>string</span>(data)) <span>// Вывод содержимого файла</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Проверить существование файла</strong></p><ul><li>Задача: Проверить, существует ли файл, перед его открытием.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>if</span> _, err := os.Stat(<span>"example.txt"</span>); err == <span>nil</span> {
        fmt.Println(<span>"File exists."</span>)
    } <span>else</span> {
        fmt.Println(<span>"File does not exist."</span>)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Удаление файла</strong></p><ul><li>Задача: Удалить файл, если он существует.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    err := os.Remove(<span>"example.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
    } <span>else</span> {
        fmt.Println(<span>"File deleted."</span>)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание файла с правами доступа</strong></p><ul><li>Задача: Создать файл с указанными правами доступа.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    file, err := os.OpenFile(<span>"restricted.txt"</span>, os.O_WRONLY|os.O_CREATE, <span>0600</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> file.Close()
    file.WriteString(<span>"Restricted access file"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Открытие файла в режиме добавления (append)</strong></p><ul><li>Задача: Открыть файл в режиме добавления и добавить текст.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    file, err := os.OpenFile(<span>"log.txt"</span>, os.O_APPEND|os.O_CREATE|os.O_WRONLY, <span>0644</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> file.Close()
    file.WriteString(<span>"New log entry\n"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Переименование файла</strong></p><ul><li>Задача: Переименовать существующий файл.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    err := os.Rename(<span>"old_name.txt"</span>, <span>"new_name.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
    } <span>else</span> {
        fmt.Println(<span>"File renamed successfully."</span>)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание временного файла</strong></p><ul><li>Задача: Создать временный файл и записать в него данные.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io/ioutil"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tempFile, err := ioutil.TempFile(<span>""</span>, <span>"tempfile_*.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> tempFile.Close()
    tempFile.WriteString(<span>"Temporary file data."</span>)
    fmt.Println(<span>"Temporary file created:"</span>, tempFile.Name())
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Чтение большого файла с использованием буферов</strong></p><ul><li>Задача: Реализовать чтение большого файла с буферизацией для оптимизации памяти.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bufio"</span>
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    file, err := os.Open(<span>"large_file.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> file.Close()

    scanner := bufio.NewScanner(file)
    <span>for</span> scanner.Scan() {
        fmt.Println(scanner.Text())
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Асинхронная запись в файл</strong></p><ul><li>Задача: Записывать данные в файл в отдельной горутине.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>asyncWrite</span><span>(data <span>string</span>, filePath <span>string</span>, done <span>chan</span> <span>bool</span>)</span></span> {
    file, err := os.OpenFile(filePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, <span>0644</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        done &lt;- <span>false</span>
        <span>return</span>
    }
    <span>defer</span> file.Close()

    _, err = file.WriteString(data)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        done &lt;- <span>false</span>
        <span>return</span>
    }
    done &lt;- <span>true</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    done := <span>make</span>(<span>chan</span> <span>bool</span>)
    <span>go</span> asyncWrite(<span>"Async log entry\n"</span>, <span>"async_log.txt"</span>, done)

    <span>if</span> &lt;-done {
        fmt.Println(<span>"Async write successful."</span>)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Чтение и запись больших файлов параллельно</strong></p><ul><li>Задача: Реализовать параллельное чтение и запись для улучшения производительности.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>parallelCopy</span><span>(srcFilePath, destFilePath <span>string</span>, done <span>chan</span> <span>bool</span>)</span></span> {
    srcFile, err := os.Open(srcFilePath)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        done &lt;- <span>false</span>
        <span>return</span>
    }
    <span>defer</span> srcFile.Close()

    destFile, err := os.Create(destFilePath)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        done &lt;- <span>false</span>
        <span>return</span>
    }
    <span>defer</span> destFile.Close()

    _, err = io.Copy(destFile, srcFile)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        done &lt;- <span>false</span>
    } <span>else</span> {
        done &lt;- <span>true</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    done := <span>make</span>(<span>chan</span> <span>bool</span>)
    <span>go</span> parallelCopy(<span>"large_source.txt"</span>, <span>"large_dest.txt"</span>, done)

    <span>if</span> &lt;-done {
        fmt.Println(<span>"Parallel file copy successful."</span>)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание ротации файлов журналов</strong></p><ul><li>Задача: Реализовать ротацию файла журнала, когда его размер превышает заданное значение.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"os"</span>
)

<span>const</span> maxLogFileSize = <span>1</span> &lt;&lt; <span>20</span> <span>// 1MB</span>

<span><span>func</span> <span>rotateLog</span><span>(logFileName <span>string</span>)</span></span> {
    file, err := os.OpenFile(logFileName, os.O_RDWR|os.O_CREATE|os.O_APPEND, <span>0666</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> file.Close()

    stat, err := file.Stat()
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }

    <span>if</span> stat.Size() &gt;= maxLogFileSize {
        file.Close()
        os.Rename(logFileName, logFileName+<span>".old"</span>)
        file, _ = os.Create(logFileName)
        file.Close()
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    rotateLog(<span>"log.txt"</span>)
    fmt.Println(<span>"Log file rotated if necessary."</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Мониторинг изменений файла</strong></p><ul><li>Задача: Реализовать наблюдение за изменениями в файле, выводя изменения в реальном времени.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io"</span>
    <span>"os"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>watchFile</span><span>(filePath <span>string</span>)</span></span> {
    file, err := os.Open(filePath)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> file.Close()

    file.Seek(<span>0</span>, io.SeekEnd) <span>// Начать с конца файла</span>
    buf := <span>make</span>([]<span>byte</span>, <span>1024</span>)

    <span>for</span> {
        n, _ := file.Read(buf)
        <span>if</span> n &gt; <span>0</span> {
            fmt.Print(<span>string</span>(buf[:n]))
        }
        time.Sleep(time.Second)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>go</span> watchFile(<span>"log.txt"</span>)
    time.Sleep(<span>30</span> * time.Second) <span>// Продолжать наблюдение за изменениями в течение 30 секунд</span>
}
</code></div></div></pre></li></ul></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><ol><li><strong></strong></li></ol><h3>1. </h3><h1 id="heading-38" class="numbered" data-id="38" style="--bg-color: red;">
ОТПРАВКА ЗАПРОСОВ</h1><h4>Базовые задачи</h4><ol><li><p><strong>Отправка GET-запроса</strong></p><ul><li>Задача: Отправить простой GET-запрос и вывести ответ.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"io/ioutil"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    resp, err := http.Get(<span>"https://jsonplaceholder.typicode.com/posts/1"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    body, _ := ioutil.ReadAll(resp.Body)
    fmt.Println(<span>string</span>(body))
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка POST-запроса</strong></p><ul><li>Задача: Отправить POST-запрос с данными в формате JSON.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bytes"</span>
    <span>"encoding/json"</span>
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    data := <span>map</span>[<span>string</span>]<span>string</span>{<span>"title"</span>: <span>"foo"</span>, <span>"body"</span>: <span>"bar"</span>, <span>"userId"</span>: <span>"1"</span>}
    jsonData, _ := json.Marshal(data)

    resp, err := http.Post(<span>"https://jsonplaceholder.typicode.com/posts"</span>, <span>"application/json"</span>, bytes.NewBuffer(jsonData))
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка запроса с заголовками</strong></p><ul><li>Задача: Добавить пользовательские заголовки в GET-запрос.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    req, _ := http.NewRequest(<span>"GET"</span>, <span>"https://jsonplaceholder.typicode.com/posts"</span>, <span>nil</span>)
    req.Header.Add(<span>"Authorization"</span>, <span>"Bearer token"</span>)

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка ответа</strong></p><ul><li>Задача: Обработать ответ и вывести статус и заголовки.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    resp, err := http.Get(<span>"https://jsonplaceholder.typicode.com/posts/1"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    fmt.Println(<span>"Response Status:"</span>, resp.Status)
    <span>for</span> key, value := <span>range</span> resp.Header {
        fmt.Println(key, <span>":"</span>, value)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка ошибок запроса</strong></p><ul><li>Задача: Реализовать обработку ошибок при отправке запроса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    _, err := http.Get(<span>"https://invalid-url"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Request failed:"</span>, err)
        <span>return</span>
    }
    fmt.Println(<span>"Request successful!"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка запросов с параметрами URL</strong></p><ul><li>Задача: Добавить параметры к URL запроса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"net/url"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    baseURL, _ := url.Parse(<span>"https://jsonplaceholder.typicode.com/posts"</span>)
    params := url.Values{}
    params.Add(<span>"userId"</span>, <span>"1"</span>)
    baseURL.RawQuery = params.Encode()

    resp, err := http.Get(baseURL.String())
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка запросов с куками</strong></p><ul><li>Задача: Отправить запрос с установленными куками.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    req, _ := http.NewRequest(<span>"GET"</span>, <span>"https://jsonplaceholder.typicode.com/posts"</span>, <span>nil</span>)
    req.AddCookie(&amp;http.Cookie{Name: <span>"session_id"</span>, Value: <span>"abc123"</span>})

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка запроса с таймаутом</strong></p><ul><li>Задача: Установить таймаут для запроса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := http.Client{
        Timeout: <span>2</span> * time.Second,
    }

    resp, err := client.Get(<span>"https://jsonplaceholder.typicode.com/posts/1"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Отправка запросов с использованием контекста</strong></p><ul><li>Задача: Использовать контекст для отмены запроса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"context"</span>
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ctx, cancel := context.WithTimeout(context.Background(), <span>1</span>*time.Second)
    <span>defer</span> cancel()

    req, _ := http.NewRequestWithContext(ctx, <span>"GET"</span>, <span>"https://jsonplaceholder.typicode.com/posts/1"</span>, <span>nil</span>)
    resp, err := http.DefaultClient.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с поддержкой различных методов запросов</strong></p><ul><li>Задача: Реализовать клиент, который поддерживает GET и POST методы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bytes"</span>
    <span>"encoding/json"</span>
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>sendPostRequest</span><span>(data <span>map</span>[<span>string</span>]<span>string</span>)</span></span> {
    jsonData, _ := json.Marshal(data)
    resp, err := http.Post(<span>"https://jsonplaceholder.typicode.com/posts"</span>, <span>"application/json"</span>, bytes.NewBuffer(jsonData))
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"POST Response Status:"</span>, resp.Status)
}

<span><span>func</span> <span>sendGetRequest</span><span>()</span></span> {
    resp, err := http.Get(<span>"https://jsonplaceholder.typicode.com/posts/1"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"GET Response Status:"</span>, resp.Status)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    sendGetRequest()
    data := <span>map</span>[<span>string</span>]<span>string</span>{<span>"title"</span>: <span>"foo"</span>, <span>"body"</span>: <span>"bar"</span>, <span>"userId"</span>: <span>"1"</span>}
    sendPostRequest(data)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с авторизацией</strong></p><ul><li>Задача: Реализовать запрос с авторизацией.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    req, _ := http.NewRequest(<span>"GET"</span>, <span>"https://jsonplaceholder.typicode.com/posts"</span>, <span>nil</span>)
    req.Header.Add(<span>"Authorization"</span>, <span>"Bearer your_token_here"</span>)

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Логирование запросов</strong></p><ul><li>Задача: Реализовать логирование всех отправляемых запросов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"log"</span>
    <span>"net/http"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    logFile, _ := os.OpenFile(<span>"request.log"</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span>0666</span>)
    <span>defer</span> logFile.Close()
    logger := log.New(logFile, <span>"LOG: "</span>, log.Ldate|log.Ltime)

    req, _ := http.NewRequest(<span>"GET"</span>, <span>"https://jsonplaceholder.typicode.com/posts"</span>, <span>nil</span>)
    logger.Println(<span>"Sending request:"</span>, req.URL)

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        logger.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    logger.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Параллельные запросы</strong></p><ul><li>Задача: Отправить несколько запросов параллельно.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>fetch</span><span>(url <span>string</span>, wg *sync.WaitGroup)</span></span> {
    <span>defer</span> wg.Done()
    resp, err := http.Get(url)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Fetched"</span>, url, <span>"with status"</span>, resp.Status)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    urls := []<span>string</span>{
        <span>"https://jsonplaceholder.typicode.com/posts/1"</span>,
        <span>"https://jsonplaceholder.typicode.com/posts/2"</span>,
        <span>"https://jsonplaceholder.typicode.com/posts/3"</span>,
    }

    <span>for</span> _, url := <span>range</span> urls {
        wg.Add(<span>1</span>)
        <span>go</span> fetch(url, &amp;wg)
    }
    wg.Wait()
}
</code></div></div></pre></li></ul></li></ol><h3>2.</h3><h1 id="heading-39" class="numbered" data-id="39" style="--bg-color: blue;">
СЕРВЕР. ОБРАБОТКА ПОДКЛЮЧЕНИЙ</h1><h4>Базовые задачи</h4><ol><li><p><strong>Создание простого HTTP-сервера</strong></p><ul><li>Задача: Создать HTTP-сервер, который отвечает на запросы.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>handler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Hello, World!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/"</span>, handler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка различных маршрутов</strong></p><ul><li>Задача: Создать сервер с несколькими маршрутами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>helloHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Hello!"</span>)
}

<span><span>func</span> <span>goodbyeHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Goodbye!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/hello"</span>, helloHandler)
    http.HandleFunc(<span>"/goodbye"</span>, goodbyeHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка параметров URL</strong></p><ul><li>Задача: Получить параметры из URL запроса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>paramHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    name := r.URL.Query().Get(<span>"name"</span>)
    fmt.Fprintf(w, <span>"Hello, %s!"</span>, name)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/"</span>, paramHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Чтение данных из тела запроса</strong></p><ul><li>Задача: Обработать POST-запрос и считать данные из тела.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io/ioutil"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>postHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    body, _ := ioutil.ReadAll(r.Body)
    fmt.Fprintf(w, <span>"Received: %s"</span>, body)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/post"</span>, postHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка ошибок</strong></p><ul><li>Задача: Реализовать обработку ошибок на сервере.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>handler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method != http.MethodGet {
        http.Error(w, <span>"Method not allowed"</span>, http.StatusMethodNotAllowed)
        <span>return</span>
    }
    fmt.Fprintf(w, <span>"Hello, World!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/"</span>, handler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с логированием</strong></p><ul><li>Задача: Добавить логирование запросов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"log"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>handler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    log.Printf(<span>"Received request: %s %s"</span>, r.Method, r.URL)
    fmt.Fprintf(w, <span>"Hello, World!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/"</span>, handler)
    log.Fatal(http.ListenAndServe(<span>":8080"</span>, <span>nil</span>))
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование middleware</strong></p><ul><li>Задача: Реализовать middleware для логирования.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"log"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>loggingMiddleware</span><span>(next http.Handler)</span></span> http.Handler {
    <span>return</span> http.HandlerFunc(<span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        log.Printf(<span>"Request: %s %s"</span>, r.Method, r.URL)
        next.ServeHTTP(w, r)
    })
}

<span><span>func</span> <span>handler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Hello, World!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/"</span>, loggingMiddleware(http.HandlerFunc(handler)))
    log.Fatal(http.ListenAndServe(<span>":8080"</span>, <span>nil</span>))
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с обработкой статических файлов</strong></p><ul><li>Задача: Настроить сервер для обслуживания статических файлов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/static/"</span>, http.StripPrefix(<span>"/static/"</span>, http.FileServer(http.Dir(<span>"static"</span>))))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Сервер с поддержкой CORS</strong></p><ul><li>Задача: Реализовать поддержку CORS на сервере.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>corsMiddleware</span><span>(next http.Handler)</span></span> http.Handler {
    <span>return</span> http.HandlerFunc(<span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        w.Header().Set(<span>"Access-Control-Allow-Origin"</span>, <span>"*"</span>)
        w.Header().Set(<span>"Access-Control-Allow-Methods"</span>, <span>"GET, POST, OPTIONS"</span>)
        <span>if</span> r.Method == http.MethodOptions {
            <span>return</span>
        }
        next.ServeHTTP(w, r)
    })
}

<span><span>func</span> <span>handler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Hello, World!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/"</span>, corsMiddleware(http.HandlerFunc(handler)))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с длительным подключением</strong></p><ul><li>Задача: Реализовать сервер для длительных подключений (например, WebSocket).</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>handler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>// Здесь будет логика для WebSocket</span>
    fmt.Fprintf(w, <span>"WebSocket connection would be handled here."</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/"</span>, handler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка JSON запросов</strong></p><ul><li>Задача: Обработать JSON запросы на сервере.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"encoding/json"</span>
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span>type</span> Message <span>struct</span> {
    Text <span>string</span> <span>`json:"text"`</span>
}

<span><span>func</span> <span>postHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>var</span> msg Message
    <span>if</span> err := json.NewDecoder(r.Body).Decode(&amp;msg); err != <span>nil</span> {
        http.Error(w, err.Error(), http.StatusBadRequest)
        <span>return</span>
    }
    fmt.Fprintf(w, <span>"Received: %s"</span>, msg.Text)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/json"</span>, postHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с авторизацией</strong></p><ul><li>Задача: Реализовать проверку авторизации на сервере.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>authMiddleware</span><span>(next http.Handler)</span></span> http.Handler {
    <span>return</span> http.HandlerFunc(<span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        <span>if</span> r.Header.Get(<span>"Authorization"</span>) != <span>"Bearer mysecret"</span> {
            http.Error(w, <span>"Forbidden"</span>, http.StatusForbidden)
            <span>return</span>
        }
        next.ServeHTTP(w, r)
    })
}

<span><span>func</span> <span>handler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Hello, authorized user!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/"</span>, authMiddleware(http.HandlerFunc(handler)))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Использование маршрутизатора</strong></p><ul><li>Задача: Реализовать сервер с использованием маршрутизатора.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"github.com/gorilla/mux"</span>
)

<span><span>func</span> <span>helloHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Hello!"</span>)
}

<span><span>func</span> <span>goodbyeHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Goodbye!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/hello"</span>, helloHandler)
    r.HandleFunc(<span>"/goodbye"</span>, goodbyeHandler)

    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li></ul></li></ol><h3>3.</h3><h1 id="heading-40" class="numbered" data-id="40" style="--bg-color: green;">
ВЗАИМОДЕЙСТВИЕ КЛИЕНТА И СЕРВЕРА</h1><h4>Базовые задачи</h4><ol><li><p><strong>Клиент, отправляющий запросы к серверу</strong></p><ul><li>Задача: Реализовать клиента для отправки запросов на сервер.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    resp, err := http.Get(<span>"http://localhost:8080/hello"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент, обрабатывающий JSON ответ</strong></p><ul><li>Задача: Отправить запрос и обработать JSON ответ от сервера.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"encoding/json"</span>
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span>type</span> Message <span>struct</span> {
    Text <span>string</span> <span>`json:"text"`</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    resp, err := http.Get(<span>"http://localhost:8080/json"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    <span>var</span> msg Message
    json.NewDecoder(resp.Body).Decode(&amp;msg)
    fmt.Println(<span>"Received message:"</span>, msg.Text)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с обработкой ошибок</strong></p><ul><li>Задача: Реализовать клиента с обработкой ошибок ответа.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    resp, err := http.Get(<span>"http://localhost:8080/invalid"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    <span>if</span> resp.StatusCode != http.StatusOK {
        fmt.Println(<span>"Error:"</span>, resp.Status)
    } <span>else</span> {
        fmt.Println(<span>"Request successful!"</span>)
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с пользовательским заголовком</strong></p><ul><li>Задача: Добавить пользовательский заголовок в запрос.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    req, _ := http.NewRequest(<span>"GET"</span>, <span>"http://localhost:8080/hello"</span>, <span>nil</span>)
    req.Header.Add(<span>"Custom-Header"</span>, <span>"value"</span>)

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с отправкой формы</strong></p><ul><li>Задача: Отправить форму на сервер.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"net/url"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    form := url.Values{}
    form.Add(<span>"name"</span>, <span>"John"</span>)
    form.Add(<span>"age"</span>, <span>"30"</span>)

    resp, err := http.PostForm(<span>"http://localhost:8080/form"</span>, form)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с обработкой сессий</strong></p><ul><li>Задача: Реализовать клиента с использованием сессий.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{}
    req, _ := http.NewRequest(<span>"GET"</span>, <span>"http://localhost:8080/session"</span>, <span>nil</span>)

    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент, работающий с WebSocket</strong></p><ul><li>Задача: Реализовать клиента для подключения к WebSocket серверу.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"github.com/gorilla/websocket"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    url := <span>"ws://localhost:8080/ws"</span>
    conn, _, err := websocket.DefaultDialer.Dial(url, <span>nil</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> conn.Close()
    fmt.Println(<span>"Connected to WebSocket server."</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с получением данных через таймаут</strong></p><ul><li>Задача: Установить таймаут для получения данных.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := http.Client{
        Timeout: <span>2</span> * time.Second,
    }

    resp, err := client.Get(<span>"http://localhost:8080/slow"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Клиент с поддержкой CORS</strong></p><ul><li>Задача: Отправить запрос с клиентом, поддерживающим CORS.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    req, _ := http.NewRequest(<span>"GET"</span>, <span>"http://localhost:8080/hello"</span>, <span>nil</span>)
    req.Header.Add(<span>"Origin"</span>, <span>"http://localhost:3000"</span>)

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с обработкой соединений через прокси</strong></p><ul><li>Задача: Реализовать клиента, который использует прокси-сервер.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    proxyURL, _ := http.ProxyURL(<span>"http://localhost:8080"</span>)
    client := &amp;http.Client{
        Transport: &amp;http.Transport{Proxy: proxyURL},
    }

    resp, err := client.Get(<span>"http://example.com"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с поддержкой HTTP/2</strong></p><ul><li>Задача: Отправить запрос с использованием HTTP/2.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    http2Transport := &amp;http.Transport{
        <span>// Установите нужные параметры для HTTP/2</span>
    }
    client := &amp;http.Client{Transport: http2Transport}

    resp, err := client.Get(<span>"https://http2.golang.org"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с кешированием</strong></p><ul><li>Задача: Реализовать кеширование запросов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{
        Timeout: <span>5</span> * time.Second,
    }

    resp, err := client.Get(<span>"http://localhost:8080/resource"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с использованием кэширования на основе ETag</strong></p><ul><li>Задача: Реализовать кэширование на основе ETag.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    req, _ := http.NewRequest(<span>"GET"</span>, <span>"http://localhost:8080/resource"</span>, <span>nil</span>)
    req.Header.Add(<span>"If-None-Match"</span>, <span>"etag_value_here"</span>)

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li></ol><h3>4. </h3><h1 id="heading-41" class="numbered" data-id="41" style="--bg-color: orange;">
УСТАНОВКА ТАЙМАУТА</h1><h4>Базовые задачи</h4><ol><li><p><strong>Таймаут для HTTP-запросов</strong></p><ul><li>Задача: Установить таймаут для HTTP-запроса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{
        Timeout: <span>2</span> * time.Second,
    }

    resp, err := client.Get(<span>"http://localhost:8080/"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Таймаут для чтения ответа</strong></p><ul><li>Задача: Установить таймаут для чтения ответа.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{
        Transport: &amp;http.Transport{
            ResponseHeaderTimeout: <span>2</span> * time.Second,
        },
    }

    resp, err := client.Get(<span>"http://localhost:8080/"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Таймаут для подключения</strong></p><ul><li>Задача: Установить таймаут для подключения к серверу.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{
        Transport: &amp;http.Transport{
            DialContext: <span><span>func</span><span>(ctx context.Context, network, addr <span>string</span>)</span></span> (net.Conn, <span>error</span>) {
                <span>return</span> net.DialTimeout(network, addr, <span>2</span>*time.Second)
            },
        },
    }

    resp, err := client.Get(<span>"http://localhost:8080/"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Таймаут для чтения тела ответа</strong></p><ul><li>Задача: Установить таймаут для чтения тела ответа.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io/ioutil"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{
        Timeout: <span>2</span> * time.Second,
    }

    resp, err := client.Get(<span>"http://localhost:8080/"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    body, err := ioutil.ReadAll(resp.Body)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error reading body:"</span>, err)
        <span>return</span>
    }
    fmt.Println(<span>"Response Body:"</span>, <span>string</span>(body))
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка превышения таймаута</strong></p><ul><li>Задача: Реализовать обработку превышения таймаута.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{
        Timeout: <span>1</span> * time.Second,
    }

    resp, err := client.Get(<span>"http://localhost:8080/slow"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Таймаут для нескольких запросов</strong></p><ul><li>Задача: Установить таймаут для нескольких параллельных запросов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"sync"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>fetch</span><span>(url <span>string</span>, wg *sync.WaitGroup, client *http.Client)</span></span> {
    <span>defer</span> wg.Done()
    resp, err := client.Get(url)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Fetched"</span>, url, <span>"with status"</span>, resp.Status)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{
        Timeout: <span>2</span> * time.Second,
    }
    <span>var</span> wg sync.WaitGroup
    urls := []<span>string</span>{
        <span>"http://localhost:8080/"</span>,
        <span>"http://localhost:8080/slow"</span>,
    }

    <span>for</span> _, url := <span>range</span> urls {
        wg.Add(<span>1</span>)
        <span>go</span> fetch(url, &amp;wg, client)
    }
    wg.Wait()
}
</code></div></div></pre></li></ul></li><li><p><strong>Таймаут для WebSocket соединений</strong></p><ul><li>Задача: Установить таймаут для WebSocket соединений.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"time"</span>
    <span>"github.com/gorilla/websocket"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    dialer := websocket.Dialer{
        HandshakeTimeout: <span>2</span> * time.Second,
    }

    conn, _, err := dialer.Dial(<span>"ws://localhost:8080/ws"</span>, <span>nil</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> conn.Close()
    fmt.Println(<span>"Connected to WebSocket server."</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Таймаут для HTTP/2 соединений</strong></p><ul><li>Задача: Установить таймаут для HTTP/2 соединений.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{
        Transport: &amp;http.Transport{
            <span>// Установите параметры для HTTP/2</span>
        },
        Timeout: <span>2</span> * time.Second,
    }

    resp, err := client.Get(<span>"https://http2.golang.org"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка таймаута с повторными попытками</strong></p><ul><li>Задача: Реализовать повторные попытки в случае таймаута.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{
        Timeout: <span>2</span> * time.Second,
    }

    <span>for</span> i := <span>0</span>; i &lt; <span>3</span>; i++ {
        resp, err := client.Get(<span>"http://localhost:8080/slow"</span>)
        <span>if</span> err != <span>nil</span> {
            fmt.Println(<span>"Error:"</span>, err)
            time.Sleep(<span>1</span> * time.Second)
            <span>continue</span>
        }
        <span>defer</span> resp.Body.Close()
        fmt.Println(<span>"Response Status:"</span>, resp.Status)
        <span>break</span>
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Таймаут для контекста</strong></p><ul><li>Задача: Использовать контекст с таймаутом для HTTP-запросов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"context"</span>
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ctx, cancel := context.WithTimeout(context.Background(), <span>2</span>*time.Second)
    <span>defer</span> cancel()

    req, _ := http.NewRequestWithContext(ctx, <span>"GET"</span>, <span>"http://localhost:8080/"</span>, <span>nil</span>)
    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response Status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li></ol><h3></h3></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h3>1. </h3><h1 id="heading-42" class="numbered" data-id="42" style="--bg-color: purple;">
СЕТЕВОЕ ПРОГРАММИРОВАНИЕ</h1><h4>Базовые задачи</h4><ol><li><p><strong>Создание TCP-сервера</strong></p><ul><li>Задача: Реализовать простой TCP-сервер, который принимает соединения.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(err)
            <span>continue</span>
        }
        <span>go</span> handleConnection(conn)
    }
}

<span><span>func</span> <span>handleConnection</span><span>(conn net.Conn)</span></span> {
    <span>defer</span> conn.Close()
    fmt.Println(<span>"Client connected:"</span>, conn.RemoteAddr())
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание TCP-клиента</strong></p><ul><li>Задача: Реализовать TCP-клиента, который подключается к серверу.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    conn, err := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> conn.Close()
    fmt.Println(<span>"Connected to server."</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка сообщения с клиента на сервер</strong></p><ul><li>Задача: Реализовать отправку сообщения от клиента на сервер.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
    <span>"bufio"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>go</span> <span><span>func</span><span>()</span></span> {
        conn, _ := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
        fmt.Fprintf(conn, <span>"Hello from client\n"</span>)
    }()

    conn, err := ln.Accept()
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> conn.Close()
    message, _ := bufio.NewReader(conn).ReadString(<span>'\n'</span>)
    fmt.Println(<span>"Message from client:"</span>, message)
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание простого HTTP-сервера</strong></p><ul><li>Задача: Реализовать простой HTTP-сервер.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>handler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Hello, World!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/"</span>, handler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание HTTP-клиента</strong></p><ul><li>Задача: Реализовать HTTP-клиента, который отправляет GET-запрос.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    resp, err := http.Get(<span>"http://localhost:8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Работа с сокетами</strong></p><ul><li>Задача: Создать клиент и сервер для передачи данных по сокету.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
    <span>"bufio"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>go</span> <span><span>func</span><span>()</span></span> {
        conn, _ := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
        fmt.Fprintf(conn, <span>"Data from client\n"</span>)
    }()

    conn, err := ln.Accept()
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> conn.Close()
    message, _ := bufio.NewReader(conn).ReadString(<span>'\n'</span>)
    fmt.Println(<span>"Received:"</span>, message)
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с обработкой нескольких подключений</strong></p><ul><li>Задача: Реализовать сервер, который может обрабатывать несколько подключений одновременно.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(err)
            <span>continue</span>
        }
        <span>go</span> handleConnection(conn)
    }
}

<span><span>func</span> <span>handleConnection</span><span>(conn net.Conn)</span></span> {
    <span>defer</span> conn.Close()
    fmt.Println(<span>"Client connected:"</span>, conn.RemoteAddr())
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с обработкой ошибок соединения</strong></p><ul><li>Задача: Реализовать клиента с обработкой ошибок соединения.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    conn, err := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Connection error:"</span>, err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> conn.Close()
    fmt.Println(<span>"Connected to server."</span>)
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>TCP-сервер с обработкой JSON</strong></p><ul><li>Задача: Реализовать TCP-сервер, который обрабатывает JSON-данные.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"encoding/json"</span>
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span>type</span> Message <span>struct</span> {
    Text <span>string</span> <span>`json:"text"`</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(err)
            <span>continue</span>
        }
        <span>go</span> handleConnection(conn)
    }
}

<span><span>func</span> <span>handleConnection</span><span>(conn net.Conn)</span></span> {
    <span>defer</span> conn.Close()
    <span>var</span> msg Message
    json.NewDecoder(conn).Decode(&amp;msg)
    fmt.Println(<span>"Received message:"</span>, msg.Text)
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с аутентификацией</strong></p><ul><li>Задача: Реализовать сервер с аутентификацией.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(err)
            <span>continue</span>
        }
        <span>go</span> handleConnection(conn)
    }
}

<span><span>func</span> <span>handleConnection</span><span>(conn net.Conn)</span></span> {
    <span>defer</span> conn.Close()
    <span>// Аутентификация пользователя</span>
    fmt.Fprintln(conn, <span>"Enter your username:"</span>)
    <span>var</span> username <span>string</span>
    fmt.Fscanln(conn, &amp;username)
    fmt.Fprintf(conn, <span>"Welcome, %s!\n"</span>, username)
}
</code></div></div></pre></li></ul></li><li><p><strong>Создание HTTP-сервера с маршрутизацией</strong></p><ul><li>Задача: Реализовать HTTP-сервер с маршрутизацией.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>helloHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Hello, World!"</span>)
}

<span><span>func</span> <span>goodbyeHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Goodbye, World!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/hello"</span>, helloHandler)
    http.HandleFunc(<span>"/goodbye"</span>, goodbyeHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с загрузкой файлов</strong></p><ul><li>Задача: Реализовать сервер для загрузки файлов.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io"</span>
    <span>"net/http"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>uploadHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method != http.MethodPost {
        http.Error(w, <span>"Invalid request method"</span>, http.StatusMethodNotAllowed)
        <span>return</span>
    }
    file, err := os.Create(<span>"uploaded_file"</span>)
    <span>if</span> err != <span>nil</span> {
        http.Error(w, <span>"Unable to create file"</span>, http.StatusInternalServerError)
        <span>return</span>
    }
    <span>defer</span> file.Close()
    io.Copy(file, r.Body)
    fmt.Fprintln(w, <span>"File uploaded successfully"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/upload"</span>, uploadHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с поддержкой HTTPS</strong></p><ul><li>Задача: Реализовать HTTP-клиента, который использует HTTPS.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    resp, err := http.Get(<span>"https://www.google.com"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li></ol><h3>2. </h3><h1 id="heading-43" class="numbered" data-id="43" style="--bg-color: pink;">
ОТПРАВКА ЗАПРОСОВ</h1><h4>Базовые задачи</h4><ol><li><p><strong>Отправка GET-запроса</strong></p><ul><li>Задача: Реализовать отправку GET-запроса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    resp, err := http.Get(<span>"http://example.com"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка POST-запроса</strong></p><ul><li>Задача: Реализовать отправку POST-запроса с данными.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bytes"</span>
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    data := []<span>byte</span>(<span>`{"name": "John"}`</span>)
    resp, err := http.Post(<span>"http://example.com"</span>, <span>"application/json"</span>, bytes.NewBuffer(data))
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка запросов с заголовками</strong></p><ul><li>Задача: Отправить запрос с пользовательскими заголовками.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    req, err := http.NewRequest(<span>"GET"</span>, <span>"http://example.com"</span>, <span>nil</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    req.Header.Set(<span>"User-Agent"</span>, <span>"MyCustomUserAgent"</span>)

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка ответа сервера</strong></p><ul><li>Задача: Обработать ответ сервера и вывести его в консоль.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io/ioutil"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    resp, err := http.Get(<span>"http://example.com"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()

    body, err := ioutil.ReadAll(resp.Body)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    fmt.Println(<span>"Response body:"</span>, <span>string</span>(body))
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка ошибок при запросе</strong></p><ul><li>Задача: Обработать ошибки при отправке запроса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    resp, err := http.Get(<span>"http://example.com/invalid"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка запросов с таймаутом</strong></p><ul><li>Задача: Установить таймаут для HTTP-запроса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{
        Timeout: <span>2</span> * time.Second,
    }
    resp, err := client.Get(<span>"http://example.com"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Error:"</span>, err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка PUT-запроса</strong></p><ul><li>Задача: Реализовать отправку PUT-запроса с данными.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bytes"</span>
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    data := []<span>byte</span>(<span>`{"name": "Jane"}`</span>)
    req, err := http.NewRequest(<span>"PUT"</span>, <span>"http://example.com/user/1"</span>, bytes.NewBuffer(data))
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    req.Header.Set(<span>"Content-Type"</span>, <span>"application/json"</span>)

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка DELETE-запроса</strong></p><ul><li>Задача: Реализовать отправку DELETE-запроса.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    req, err := http.NewRequest(<span>"DELETE"</span>, <span>"http://example.com/user/1"</span>, <span>nil</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Отправка запросов с базовой аутентификацией</strong></p><ul><li>Задача: Отправить запрос с базовой аутентификацией.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    req, err := http.NewRequest(<span>"GET"</span>, <span>"http://example.com"</span>, <span>nil</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    req.SetBasicAuth(<span>"user"</span>, <span>"password"</span>)

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка запросов с куками</strong></p><ul><li>Задача: Отправить запрос с куками.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    client := &amp;http.Client{}
    req, _ := http.NewRequest(<span>"GET"</span>, <span>"http://example.com"</span>, <span>nil</span>)
    req.AddCookie(&amp;http.Cookie{Name: <span>"session_id"</span>, Value: <span>"123456"</span>})

    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка запросов с помощью прокси</strong></p><ul><li>Задача: Отправить запрос через прокси-сервер.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"net/url"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    proxyURL, _ := url.Parse(<span>"http://proxyserver:8080"</span>)
    transport := &amp;http.Transport{Proxy: http.ProxyURL(proxyURL)}
    client := &amp;http.Client{Transport: transport}

    resp, err := client.Get(<span>"http://example.com"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка JSON-данных</strong></p><ul><li>Задача: Отправить JSON-данные через POST-запрос.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bytes"</span>
    <span>"encoding/json"</span>
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span>type</span> User <span>struct</span> {
    Name <span>string</span> <span>`json:"name"`</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    user := User{Name: <span>"John"</span>}
    jsonData, _ := json.Marshal(user)

    resp, err := http.Post(<span>"http://example.com/user"</span>, <span>"application/json"</span>, bytes.NewBuffer(jsonData))
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li><li><p><strong>Отправка запросов с использованием контекста</strong></p><ul><li>Задача: Использовать контекст для управления запросами.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"context"</span>
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ctx, cancel := context.WithTimeout(context.Background(), <span>2</span>*time.Second)
    <span>defer</span> cancel()

    req, err := http.NewRequestWithContext(ctx, <span>"GET"</span>, <span>"http://example.com"</span>, <span>nil</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }

    client := &amp;http.Client{}
    resp, err := client.Do(req)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> resp.Body.Close()
    fmt.Println(<span>"Response status:"</span>, resp.Status)
}
</code></div></div></pre></li></ul></li></ol><h3>3. </h3><h1 id="heading-44" class="numbered" data-id="44" style="--bg-color: red;">
СЕРВЕР. ОБРАБОТКА ПОДКЛЮЧЕНИЙ</h1><h4>Базовые задачи</h4><ol><li><p><strong>Создание простого TCP-сервера</strong></p><ul><li>Задача: Создать TCP-сервер, который принимает подключения.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(err)
            <span>continue</span>
        }
        fmt.Println(<span>"Client connected:"</span>, conn.RemoteAddr())
        conn.Close()
    }
}
</code></div></div></pre></li></ul></li><li><p><strong>Обработка сообщений от клиента</strong></p><ul><li>Задача: Обработать сообщения, отправляемые клиентом.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bufio"</span>
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(err)
            <span>continue</span>
        }
        <span>go</span> handleConnection(conn)
    }
}

<span><span>func</span> <span>handleConnection</span><span>(conn net.Conn)</span></span> {
    <span>defer</span> conn.Close()
    message, _ := bufio.NewReader(conn).ReadString(<span>'\n'</span>)
    fmt.Println(<span>"Received:"</span>, message)
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с многопоточностью</strong></p><ul><li>Задача: Реализовать многопоточный сервер для обработки нескольких подключений.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(err)
            <span>continue</span>
        }
        <span>go</span> handleConnection(conn)
    }
}

<span><span>func</span> <span>handleConnection</span><span>(conn net.Conn)</span></span> {
    <span>defer</span> conn.Close()
    fmt.Println(<span>"Client connected:"</span>, conn.RemoteAddr())
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с обработкой ошибок</strong></p><ul><li>Задача: Реализовать сервер с обработкой ошибок при подключении.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(<span>"Connection error:"</span>, err)
            <span>continue</span>
        }
        <span>go</span> handleConnection(conn)
    }
}

<span><span>func</span> <span>handleConnection</span><span>(conn net.Conn)</span></span> {
    <span>defer</span> conn.Close()
    fmt.Println(<span>"Client connected:"</span>, conn.RemoteAddr())
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с ответом клиенту</strong></p><ul><li>Задача: Сервер должен отправлять ответ клиенту.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(err)
            <span>continue</span>
        }
        <span>go</span> handleConnection(conn)
    }
}

<span><span>func</span> <span>handleConnection</span><span>(conn net.Conn)</span></span> {
    <span>defer</span> conn.Close()
    fmt.Fprintf(conn, <span>"Hello from server\n"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с записью логов</strong></p><ul><li>Задача: Сервер должен записывать логи подключений.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(err)
            <span>continue</span>
        }
        <span>go</span> handleConnection(conn)
    }
}

<span><span>func</span> <span>handleConnection</span><span>(conn net.Conn)</span></span> {
    <span>defer</span> conn.Close()
    fmt.Println(<span>"Client connected:"</span>, conn.RemoteAddr())
    <span>// Здесь можно добавить запись в лог</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с поддержкой нескольких протоколов</strong></p><ul><li>Задача: Сервер должен поддерживать несколько протоколов (например, TCP и HTTP).</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"net/http"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>go</span> startHTTPServer()
    startTCPServer()
}

<span><span>func</span> <span>startHTTPServer</span><span>()</span></span> {
    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        fmt.Fprintf(w, <span>"Hello from HTTP server!"</span>)
    })
    http.ListenAndServe(<span>":8081"</span>, <span>nil</span>)
}

<span><span>func</span> <span>startTCPServer</span><span>()</span></span> {
    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(err)
            <span>continue</span>
        }
        <span>go</span> handleConnection(conn)
    }
}

<span><span>func</span> <span>handleConnection</span><span>(conn net.Conn)</span></span> {
    <span>defer</span> conn.Close()
    fmt.Fprintf(conn, <span>"Hello from TCP server\n"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Сервер с взаимодействием с базой данных</strong></p><ul><li>Задача: Сервер должен взаимодействовать с базой данных.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"database/sql"</span>
    <span>"fmt"</span>
    <span>"net"</span>
    _ <span>"github.com/lib/pq"</span> <span>// PostgreSQL driver</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    db, err := sql.Open(<span>"postgres"</span>, <span>"user=username dbname=mydb sslmode=disable"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> db.Close()

    ln, err := net.Listen(<span>"tcp"</span>, <span>":8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> ln.Close()
    fmt.Println(<span>"Listening on :8080"</span>)

    <span>for</span> {
        conn, err := ln.Accept()
        <span>if</span> err != <span>nil</span> {
            fmt.Println(err)
            <span>continue</span>
        }
        <span>go</span> handleConnection(conn, db)
    }
}

<span><span>func</span> <span>handleConnection</span><span>(conn net.Conn, db *sql.DB)</span></span> {
    <span>defer</span> conn.Close()
    <span>// Здесь можно взаимодействовать с базой данных</span>
}
</code></div></div></pre></li></ul></li></ol><h3>4. </h3><h1 id="heading-45" class="numbered" data-id="45" style="--bg-color: blue;">
ВЗАИМОДЕЙСТВИЕ КЛИЕНТА И СЕРВЕРА</h1><h4>Базовые задачи</h4><ol><li><p><strong>Клиент, отправляющий данные серверу</strong></p><ul><li>Задача: Реализовать клиента, который отправляет данные на сервер.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    conn, err := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> conn.Close()

    fmt.Fprintf(conn, <span>"Hello from client\n"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент, получающий ответ от сервера</strong></p><ul><li>Задача: Реализовать клиента, который получает ответ от сервера.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bufio"</span>
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    conn, err := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> conn.Close()

    fmt.Fprintf(conn, <span>"Hello from client\n"</span>)
    message, _ := bufio.NewReader(conn).ReadString(<span>'\n'</span>)
    fmt.Println(<span>"Received:"</span>, message)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с обработкой ошибок</strong></p><ul><li>Задача: Обработать ошибки при подключении к серверу.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    conn, err := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(<span>"Connection error:"</span>, err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> conn.Close()

    fmt.Fprintf(conn, <span>"Hello from client\n"</span>)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с многопоточностью</strong></p><ul><li>Задача: Реализовать клиента, который может отправлять данные в нескольких потоках.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
    <span>"sync"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>var</span> wg sync.WaitGroup
    <span>for</span> i := <span>0</span>; i &lt; <span>5</span>; i++ {
        wg.Add(<span>1</span>)
        <span>go</span> <span><span>func</span><span>(i <span>int</span>)</span></span> {
            <span>defer</span> wg.Done()
            conn, err := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
            <span>if</span> err != <span>nil</span> {
                fmt.Println(err)
                <span>return</span>
            }
            <span>defer</span> conn.Close()
            fmt.Fprintf(conn, <span>"Hello from client %d\n"</span>, i)
        }(i)
    }
    wg.Wait()
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с отправкой JSON-данных</strong></p><ul><li>Задача: Клиент должен отправлять JSON-данные на сервер.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"bytes"</span>
    <span>"encoding/json"</span>
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span>type</span> Message <span>struct</span> {
    Content <span>string</span> <span>`json:"content"`</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    conn, err := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> conn.Close()

    msg := Message{Content: <span>"Hello from client"</span>}
    jsonData, _ := json.Marshal(msg)
    conn.Write(jsonData)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с поддержкой нескольких подключений</strong></p><ul><li>Задача: Клиент должен поддерживать несколько подключений к серверу.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>for</span> i := <span>0</span>; i &lt; <span>5</span>; i++ {
        <span>go</span> <span><span>func</span><span>(i <span>int</span>)</span></span> {
            conn, err := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
            <span>if</span> err != <span>nil</span> {
                fmt.Println(err)
                <span>return</span>
            }
            <span>defer</span> conn.Close()
            fmt.Fprintf(conn, <span>"Hello from client %d\n"</span>, i)
        }(i)
    }
    <span>select</span> {} <span>// Блокируем выполнение</span>
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с отправкой изображений</strong></p><ul><li>Задача: Клиент должен отправлять изображение на сервер.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io/ioutil"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    conn, err := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> conn.Close()

    data, err := ioutil.ReadFile(<span>"image.png"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    conn.Write(data)
}
</code></div></div></pre></li></ul></li><li><p><strong>Клиент с отправкой файлов</strong></p><ul><li>Задача: Клиент должен отправлять файл на сервер.</li><li>Решение:<pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"io/ioutil"</span>
    <span>"net"</span>
    <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    conn, err := net.Dial(<span>"tcp"</span>, <span>"localhost:8080"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        os.Exit(<span>1</span>)
    }
    <span>defer</span> conn.Close()

    fileData, err := ioutil.ReadFile(<span>"file.txt"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    conn.Write(fileData)
}
</code></div></div></pre></li></ul></li></ol><h3></h3></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h3>1. </h3><h1 id="heading-46" class="numbered" data-id="46" style="--bg-color: green;">
MYSQL</h1><h4>Базовые задачи</h4><ol><li><p><strong>Подключение к базе данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"database/sql"</span>
    <span>"fmt"</span>
    _ <span>"github.com/go-sql-driver/mysql"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    db, err := sql.Open(<span>"mysql"</span>, <span>"user:password@tcp(localhost:3306)/dbname"</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    <span>defer</span> db.Close()
    fmt.Println(<span>"Connected to MySQL database"</span>)
}
</code></div></div></pre></li><li><p><strong>Создание таблицы</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>main</span><span>()</span></span> {
    <span>// ... подключение к базе данных</span>
    _, err = db.Exec(<span>`CREATE TABLE users (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255))`</span>)
    <span>if</span> err != <span>nil</span> {
        fmt.Println(err)
        <span>return</span>
    }
    fmt.Println(<span>"Table created"</span>)
}
</code></div></div></pre></li><li><p><strong>Вставка данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`INSERT INTO users (name) VALUES (?)`</span>, <span>"John"</span>)
</code></div></div></pre></li><li><p><strong>Получение данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>rows, err := db.Query(<span>`SELECT id, name FROM users`</span>)
</code></div></div></pre></li><li><p><strong>Обновление данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`UPDATE users SET name = ? WHERE id = ?`</span>, <span>"Jane"</span>, <span>1</span>)
</code></div></div></pre></li><li><p><strong>Удаление данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`DELETE FROM users WHERE id = ?`</span>, <span>1</span>)
</code></div></div></pre></li><li><p><strong>Использование транзакций</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>tx, err := db.Begin()
</code></div></div></pre></li><li><p><strong>Получение количества строк</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>var</span> count <span>int</span>
err = db.QueryRow(<span>`SELECT COUNT(*) FROM users`</span>).Scan(&amp;count)
</code></div></div></pre></li><li><p><strong>Использование JOIN</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>rows, err = db.Query(<span>`SELECT u.id, u.name, o.order_id FROM users u JOIN orders o ON u.id = o.user_id`</span>)
</code></div></div></pre></li><li><p><strong>Создание индекса</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`CREATE INDEX idx_name ON users (name)`</span>)
</code></div></div></pre></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Создание сложного запроса с GROUP BY</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>rows, err = db.Query(<span>`SELECT name, COUNT(*) FROM users GROUP BY name`</span>)
</code></div></div></pre></li><li><p><strong>Создание представления</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`CREATE VIEW user_view AS SELECT id, name FROM users`</span>)
</code></div></div></pre></li><li><p><strong>Хранимая процедура</strong></p><pre><div><div>sql</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>CREATE</span> <span>PROCEDURE</span> GetUsers()
<span>BEGIN</span>
    <span>SELECT</span> <span>*</span> <span>FROM</span> users;
<span>END</span>;
</code></div></div></pre></li><li><p><strong>Обработка ошибок в транзакциях</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>if</span> err != <span>nil</span> {
    tx.Rollback()
}
</code></div></div></pre></li><li><p><strong>Использование триггеров</strong></p><pre><div><div>sql</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>CREATE</span> <span>TRIGGER</span> before_insert_users BEFORE <span>INSERT</span> <span>ON</span> users <span>FOR</span> <span>EACH</span> <span>ROW</span> <span>SET</span> NEW.created_at <span>=</span> NOW();
</code></div></div></pre></li></ol><h3>2. PostgreSQL</h3><h4>Базовые задачи</h4><ol><li><p><strong>Подключение к базе данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"database/sql"</span>
    <span>"fmt"</span>
    _ <span>"github.com/lib/pq"</span>
)

db, err := sql.Open(<span>"postgres"</span>, <span>"user=username dbname=mydb sslmode=disable"</span>)
</code></div></div></pre></li><li><p><strong>Создание таблицы</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT)`</span>)
</code></div></div></pre></li><li><p><strong>Вставка данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`INSERT INTO users (name) VALUES ($1)`</span>, <span>"John"</span>)
</code></div></div></pre></li><li><p><strong>Получение данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>rows, err := db.Query(<span>`SELECT id, name FROM users`</span>)
</code></div></div></pre></li><li><p><strong>Обновление данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`UPDATE users SET name = $1 WHERE id = $2`</span>, <span>"Jane"</span>, <span>1</span>)
</code></div></div></pre></li><li><p><strong>Удаление данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`DELETE FROM users WHERE id = $1`</span>, <span>1</span>)
</code></div></div></pre></li><li><p><strong>Использование транзакций</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>tx, err := db.Begin()
</code></div></div></pre></li><li><p><strong>Получение количества строк</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>var</span> count <span>int</span>
err = db.QueryRow(<span>`SELECT COUNT(*) FROM users`</span>).Scan(&amp;count)
</code></div></div></pre></li><li><p><strong>Использование JOIN</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>rows, err = db.Query(<span>`SELECT u.id, u.name, o.order_id FROM users u JOIN orders o ON u.id = o.user_id`</span>)
</code></div></div></pre></li><li><p><strong>Создание индекса</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`CREATE INDEX idx_name ON users (name)`</span>)
</code></div></div></pre></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Создание сложного запроса с GROUP BY</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>rows, err = db.Query(<span>`SELECT name, COUNT(*) FROM users GROUP BY name`</span>)
</code></div></div></pre></li><li><p><strong>Создание представления</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`CREATE VIEW user_view AS SELECT id, name FROM users`</span>)
</code></div></div></pre></li><li><p><strong>Хранимая процедура</strong></p><pre><div><div>sql</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>CREATE</span> <span>OR</span> REPLACE <span>FUNCTION</span> get_users() <span>RETURNS</span> SETOF users <span>AS</span> $$
<span>BEGIN</span>
    <span>RETURN</span> QUERY <span>SELECT</span> <span>*</span> <span>FROM</span> users;
<span>END</span>;
$$ <span>LANGUAGE</span> plpgsql;
</code></div></div></pre></li><li><p><strong>Обработка ошибок в транзакциях</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>if</span> err != <span>nil</span> {
    tx.Rollback()
}
</code></div></div></pre></li><li><p><strong>Использование триггеров</strong></p><pre><div><div>sql</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>CREATE</span> <span>TRIGGER</span> before_insert_users BEFORE <span>INSERT</span> <span>ON</span> users <span>FOR</span> <span>EACH</span> <span>ROW</span> <span>EXECUTE</span> <span>PROCEDURE</span> set_created_at();
</code></div></div></pre></li></ol><h3>3. SQLite</h3><h4>Базовые задачи</h4><ol><li><p><strong>Подключение к базе данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"database/sql"</span>
    <span>"fmt"</span>
    _ <span>"github.com/mattn/go-sqlite3"</span>
)

db, err := sql.Open(<span>"sqlite3"</span>, <span>"file:test.db"</span>)
</code></div></div></pre></li><li><p><strong>Создание таблицы</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)`</span>)
</code></div></div></pre></li><li><p><strong>Вставка данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`INSERT INTO users (name) VALUES (?)`</span>, <span>"John"</span>)
</code></div></div></pre></li><li><p><strong>Получение данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>rows, err := db.Query(<span>`SELECT id, name FROM users`</span>)
</code></div></div></pre></li><li><p><strong>Обновление данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`UPDATE users SET name = ? WHERE id = ?`</span>, <span>"Jane"</span>, <span>1</span>)
</code></div></div></pre></li><li><p><strong>Удаление данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`DELETE FROM users WHERE id = ?`</span>, <span>1</span>)
</code></div></div></pre></li><li><p><strong>Использование транзакций</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>tx, err := db.Begin()
</code></div></div></pre></li><li><p><strong>Получение количества строк</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>var</span> count <span>int</span>
err = db.QueryRow(<span>`SELECT COUNT(*) FROM users`</span>).Scan(&amp;count)
</code></div></div></pre></li><li><p><strong>Использование JOIN</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>rows, err = db.Query(<span>`SELECT u.id, u.name, o.order_id FROM users u JOIN orders o ON u.id = o.user_id`</span>)
</code></div></div></pre></li><li><p><strong>Создание индекса</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`CREATE INDEX idx_name ON users (name)`</span>)
</code></div></div></pre></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Создание сложного запроса с GROUP BY</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>rows, err = db.Query(<span>`SELECT name, COUNT(*) FROM users GROUP BY name`</span>)
</code></div></div></pre></li><li><p><strong>Создание представления</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = db.Exec(<span>`CREATE VIEW user_view AS SELECT id, name FROM users`</span>)
</code></div></div></pre></li><li><p><strong>Хранимая процедура</strong></p><pre><div><div>sql</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>-- SQLite не поддерживает хранимые процедуры в традиционном понимании</span>
</code></div></div></pre></li><li><p><strong>Обработка ошибок в транзакциях</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>if</span> err != <span>nil</span> {
    tx.Rollback()
}
</code></div></div></pre></li><li><p><strong>Использование триггеров</strong></p><pre><div><div>sql</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>CREATE</span> <span>TRIGGER</span> before_insert_users BEFORE <span>INSERT</span> <span>ON</span> users <span>BEGIN</span> <span>SET</span> NEW.created_at <span>=</span> <span>CURRENT_TIMESTAMP</span>; <span>END</span>;
</code></div></div></pre></li></ol><h3>4. </h3><h1 id="heading-47" class="numbered" data-id="47" style="--bg-color: orange;">
MONGODB</h1><h4>Базовые задачи</h4><ol><li><p><strong>Подключение к базе данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"context"</span>
    <span>"fmt"</span>
    <span>"go.mongodb.org/mongo-driver/mongo"</span>
    <span>"go.mongodb.org/mongo-driver/mongo/options"</span>
)

client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI(<span>"mongodb://localhost:27017"</span>))
</code></div></div></pre></li><li><p><strong>Создание коллекции</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>collection := client.Database(<span>"testdb"</span>).Collection(<span>"users"</span>)
</code></div></div></pre></li><li><p><strong>Вставка документа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = collection.InsertOne(context.TODO(), bson.M{<span>"name"</span>: <span>"John"</span>})
</code></div></div></pre></li><li><p><strong>Получение документов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>cursor, err := collection.Find(context.TODO(), bson.D{})
</code></div></div></pre></li><li><p><strong>Обновление документа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = collection.UpdateOne(context.TODO(), bson.M{<span>"name"</span>: <span>"John"</span>}, bson.M{<span>"$set"</span>: bson.M{<span>"name"</span>: <span>"Jane"</span>}})
</code></div></div></pre></li><li><p><strong>Удаление документа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = collection.DeleteOne(context.TODO(), bson.M{<span>"name"</span>: <span>"Jane"</span>})
</code></div></div></pre></li><li><p><strong>Поиск документа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>var</span> result bson.M
err = collection.FindOne(context.TODO(), bson.M{<span>"name"</span>: <span>"John"</span>}).Decode(&amp;result)
</code></div></div></pre></li><li><p><strong>Использование индексов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>indexModel := mongo.IndexModel{
    Keys: bson.D{{Key: <span>"name"</span>, Value: <span>1</span>}},
}
_, err = collection.Indexes().CreateOne(context.TODO(), indexModel)
</code></div></div></pre></li><li><p><strong>Получение количества документов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>count, err := collection.CountDocuments(context.TODO(), bson.D{})
</code></div></div></pre></li><li><p><strong>Агрегация данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>pipeline := mongo.Pipeline{
    {{<span>"$group"</span>, bson.D{{<span>"_id"</span>, <span>"$name"</span>}, {<span>"count"</span>, bson.D{{<span>"$sum"</span>, <span>1</span>}}}}}},
}
cursor, err = collection.Aggregate(context.TODO(), pipeline)
</code></div></div></pre></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Создание сложного запроса с агрегацией</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>pipeline := mongo.Pipeline{
    {{<span>"$match"</span>, bson.M{<span>"age"</span>: bson.M{<span>"$gt"</span>: <span>18</span>}}}},
    {{<span>"$group"</span>, bson.D{{<span>"_id"</span>, <span>"$gender"</span>}, {<span>"count"</span>, bson.D{{<span>"$sum"</span>, <span>1</span>}}}}}},
}
</code></div></div></pre></li><li><p><strong>Создание индекса с уникальностью</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>indexModel := mongo.IndexModel{
    Keys: bson.D{{Key: <span>"email"</span>, Value: <span>1</span>}},
    Options: options.Index().SetUnique(<span>true</span>),
}
</code></div></div></pre></li><li><p><strong>Использование транзакций</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>session, err := client.StartSession()
</code></div></div></pre></li><li><p><strong>Создание хранимой функции (агрегации)</strong></p><pre><div><div>javascript</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>db.<span>createFunction</span>(<span>"getUsers"</span>, <span>function</span>() {
    <span>return</span> db.<span>users</span>.<span>find</span>();
});
</code></div></div></pre></li><li><p><strong>Вложенные документы</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code>_, err = collection.InsertOne(context.TODO(), bson.M{
    <span>"name"</span>: <span>"John"</span>,
    <span>"address"</span>: bson.M{
        <span>"street"</span>: <span>"123 Main St"</span>,
        <span>"city"</span>:   <span>"New York"</span>,
    },
})
</code></div></div></pre></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h3>1. </h3><h1 id="heading-48" class="numbered" data-id="48" style="--bg-color: purple;">
ФУНКЦИЯ HANDLEFUNC</h1><code></code><h4>Базовые задачи</h4><ol><li><p><strong>Создание простого HTTP-сервера</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>helloHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Hello, World!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/"</span>, helloHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Обработка параметров запроса</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>queryHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    name := r.URL.Query().Get(<span>"name"</span>)
    fmt.Fprintf(w, <span>"Hello, %s!"</span>, name)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/greet"</span>, queryHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Возврат статуса 404</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>notFoundHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.NotFound(w, r)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/notfound"</span>, notFoundHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Обработка POST-запроса</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>postHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        fmt.Fprintf(w, <span>"Received a POST request"</span>)
    } <span>else</span> {
        http.Error(w, <span>"Only POST method is allowed"</span>, http.StatusMethodNotAllowed)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/submit"</span>, postHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Чтение данных из формы</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>formHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    r.ParseForm()
    name := r.FormValue(<span>"name"</span>)
    fmt.Fprintf(w, <span>"Form submitted! Hello, %s!"</span>, name)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/form"</span>, formHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Отправка JSON-ответа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"encoding/json"</span>
)

<span><span>func</span> <span>jsonHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    data := <span>map</span>[<span>string</span>]<span>string</span>{<span>"message"</span>: <span>"Hello, World!"</span>}
    w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
    json.NewEncoder(w).Encode(data)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/json"</span>, jsonHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Передача данных через URL-параметры</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>paramHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    params := r.URL.Path[<span>len</span>(<span>"/params/"</span>):]
    fmt.Fprintf(w, <span>"Params: %s"</span>, params)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/params/"</span>, paramHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Перенаправление</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>redirectHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.Redirect(w, r, <span>"/"</span>, http.StatusSeeOther)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/redirect"</span>, redirectHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Установка заголовков ответа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>headerHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    w.Header().Set(<span>"X-Custom-Header"</span>, <span>"MyValue"</span>)
    fmt.Fprintf(w, <span>"Header set!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/header"</span>, headerHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Использование middleware для логирования</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>loggingMiddleware</span><span>(next http.HandlerFunc)</span></span> http.HandlerFunc {
    <span>return</span> <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        fmt.Printf(<span>"Request received: %s\n"</span>, r.URL.Path)
        next(w, r)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/"</span>, loggingMiddleware(helloHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Отправка файла</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>fileHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.ServeFile(w, r, <span>"file.txt"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/file"</span>, fileHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Установка таймаута</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>timeoutHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>// Simulation of a long-running process</span>
    time.Sleep(<span>5</span> * time.Second)
    fmt.Fprintf(w, <span>"This will take a while..."</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    srv := &amp;http.Server{
        Addr:         <span>":8080"</span>,
        ReadTimeout:  <span>5</span> * time.Second,
        WriteTimeout: <span>10</span> * time.Second,
    }

    http.HandleFunc(<span>"/timeout"</span>, timeoutHandler)
    srv.ListenAndServe()
}
</code></div></div></pre></li><li><p><strong>Работа с cookies</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>cookieHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    cookie := &amp;http.Cookie{
        Name:  <span>"session_id"</span>,
        Value: <span>"123456"</span>,
    }
    http.SetCookie(w, cookie)
    fmt.Fprintf(w, <span>"Cookie set!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/cookie"</span>, cookieHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Кэширование ответов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>cacheHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    w.Header().Set(<span>"Cache-Control"</span>, <span>"public, max-age=3600"</span>)
    fmt.Fprintf(w, <span>"Response cached for 1 hour!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/cache"</span>, cacheHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Обработка ошибок с помощью http.Error</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>errorHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.Error(w, <span>"This is an error!"</span>, http.StatusInternalServerError)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/error"</span>, errorHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Создание RESTful API</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>apiHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>switch</span> r.Method {
    <span>case</span> http.MethodGet:
        <span>// Обработка GET запроса</span>
    <span>case</span> http.MethodPost:
        <span>// Обработка POST запроса</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/api"</span>, apiHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Динамическое создание контента</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>dynamicHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    id := r.URL.Query().Get(<span>"id"</span>)
    fmt.Fprintf(w, <span>"Dynamic content for ID: %s"</span>, id)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/dynamic"</span>, dynamicHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Многоуровневая маршрутизация</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>userHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>// Обработка запросов к пользователям</span>
}

<span><span>func</span> <span>adminHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>// Обработка запросов к администратору</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/user/"</span>, userHandler)
    http.HandleFunc(<span>"/admin/"</span>, adminHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Использование структур для обработки данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>type</span> User <span>struct</span> {
    Name  <span>string</span> <span>`json:"name"`</span>
    Email <span>string</span> <span>`json:"email"`</span>
}

<span><span>func</span> <span>userPostHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>var</span> user User
    json.NewDecoder(r.Body).Decode(&amp;user)
    fmt.Fprintf(w, <span>"User: %+v"</span>, user)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/user"</span>, userPostHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Форматирование ответов на основе заголовков</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>formatHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Header.Get(<span>"Accept"</span>) == <span>"application/json"</span> {
        w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
        json.NewEncoder(w).Encode(<span>map</span>[<span>string</span>]<span>string</span>{<span>"message"</span>: <span>"Hello, World!"</span>})
    } <span>else</span> {
        w.Header().Set(<span>"Content-Type"</span>, <span>"text/plain"</span>)
        fmt.Fprintf(w, <span>"Hello, World!"</span>)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/format"</span>, formatHandler)
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ol><h3>2. </h3><h1 id="heading-49" class="numbered" data-id="49" style="--bg-color: pink;">
ФУНКЦИЯ HANDLE</h1><code></code><h4>Базовые задачи</h4><ol><li><p><strong>Создание HTTP-сервера с <code>Handle</code></strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/"</span>, http.HandlerFunc(helloHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Использование <code>Handle</code> для нескольких маршрутов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/greet"</span>, http.HandlerFunc(queryHandler))
    http.Handle(<span>"/form"</span>, http.HandlerFunc(formHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Обработка ошибок в <code>Handle</code></strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>errorHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.Error(w, <span>"An error occurred"</span>, http.StatusInternalServerError)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/error"</span>, http.HandlerFunc(errorHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Передача структуры обработчику</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>type</span> MyHandler <span>struct</span>{}

<span><span>func</span> <span>(h *MyHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, <span>"Hello from MyHandler!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/myhandler"</span>, &amp;MyHandler{})
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Множественные обработчики для разных методов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>myHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodGet {
        fmt.Fprintf(w, <span>"GET method"</span>)
    } <span>else</span> <span>if</span> r.Method == http.MethodPost {
        fmt.Fprintf(w, <span>"POST method"</span>)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/methods"</span>, http.HandlerFunc(myHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание простого REST API с <code>Handle</code></strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>apiHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>// Обработка API запросов</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/api"</span>, http.HandlerFunc(apiHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Использование логирования в обработчике</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>loggingHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    log.Printf(<span>"Request URL: %s"</span>, r.URL.Path)
    fmt.Fprintf(w, <span>"Logged!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/log"</span>, http.HandlerFunc(loggingHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Обработка CORS</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>corsHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    w.Header().Set(<span>"Access-Control-Allow-Origin"</span>, <span>"*"</span>)
    fmt.Fprintf(w, <span>"CORS enabled"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/cors"</span>, http.HandlerFunc(corsHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Обработка файловых загрузок</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>uploadHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        file, _, err := r.FormFile(<span>"file"</span>)
        <span>if</span> err != <span>nil</span> {
            http.Error(w, <span>"File upload error"</span>, http.StatusBadRequest)
            <span>return</span>
        }
        <span>defer</span> file.Close()
        fmt.Fprintf(w, <span>"File uploaded!"</span>)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/upload"</span>, http.HandlerFunc(uploadHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Форма для ввода данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>formInputHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>`&lt;form method="POST"&gt;&lt;input type="text" name="data"&gt;&lt;input type="submit"&gt;&lt;/form&gt;`</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/form"</span>, http.HandlerFunc(formInputHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Динамическое создание страницы</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>dynamicPageHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    pageTitle := r.URL.Query().Get(<span>"title"</span>)
    fmt.Fprintf(w, <span>"&lt;h1&gt;%s&lt;/h1&gt;"</span>, pageTitle)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/dynamic"</span>, http.HandlerFunc(dynamicPageHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Использование middleware</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>middleware</span><span>(next http.Handler)</span></span> http.Handler {
    <span>return</span> http.HandlerFunc(<span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        log.Println(<span>"Middleware executed"</span>)
        next.ServeHTTP(w, r)
    })
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/middleware"</span>, middleware(http.HandlerFunc(helloHandler)))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Отправка HTML-контента</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>htmlHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    w.Header().Set(<span>"Content-Type"</span>, <span>"text/html"</span>)
    fmt.Fprintf(w, <span>"&lt;h1&gt;Hello, HTML!&lt;/h1&gt;"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/html"</span>, http.HandlerFunc(htmlHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Загрузка изображений</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>imageHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.ServeFile(w, r, <span>"image.jpg"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/image"</span>, http.HandlerFunc(imageHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Форматирование данных в ответе</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>responseFormatHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    response := <span>map</span>[<span>string</span>]<span>string</span>{<span>"status"</span>: <span>"success"</span>}
    w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
    json.NewEncoder(w).Encode(response)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/response"</span>, http.HandlerFunc(responseFormatHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Создание многоуровневой маршрутизации</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/api/v1/users"</span>, http.HandlerFunc(usersHandler))
    http.Handle(<span>"/api/v1/posts"</span>, http.HandlerFunc(postsHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Реализация WebSocket</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>wsHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>// Обработка WebSocket соединения</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/ws"</span>, http.HandlerFunc(wsHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Интеграция с сторонним API</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>apiIntegrationHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    resp, err := http.Get(<span>"https://api.example.com/data"</span>)
    <span>// Обработка ответа</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/external"</span>, http.HandlerFunc(apiIntegrationHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Реализация аутентификации</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>authMiddleware</span><span>(next http.Handler)</span></span> http.Handler {
    <span>return</span> http.HandlerFunc(<span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        <span>// Проверка аутентификации</span>
        next.ServeHTTP(w, r)
    })
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/protected"</span>, authMiddleware(http.HandlerFunc(protectedHandler)))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание API для работы с базой данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>dbHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>// Подключение к БД и обработка запросов</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/db"</span>, http.HandlerFunc(dbHandler))
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><h3>1. </h3><h1 id="heading-50" class="numbered" data-id="50" style="--bg-color: red;">
ФУНКЦИЯ HANDLEFUNC</h1><code></code><h4>Базовые задачи</h4><ol><li><p><strong>Создание простого HTTP-сервера</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
)

<span>// helloHandler обрабатывает корневой URL и возвращает приветствие</span>
<span><span>func</span> <span>helloHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Hello, World!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    <span>// Настройка маршрута для корневого URL</span>
    http.HandleFunc(<span>"/"</span>, helloHandler)
    <span>// Запуск HTTP-сервера на порту 8080</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Обработка параметров запроса</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// queryHandler обрабатывает запросы с параметром "name"</span>
<span><span>func</span> <span>queryHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    name := r.URL.Query().Get(<span>"name"</span>) <span>// Получаем значение параметра "name"</span>
    <span>if</span> name == <span>""</span> {
        name = <span>"World"</span>
    }
    fmt.Fprintf(w, <span>"Hello, %s!"</span>, name) <span>// Форматируем ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/greet"</span>, queryHandler) <span>// Настройка маршрута для "/greet"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Возврат статуса 404</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// notFoundHandler обрабатывает запросы к несуществующим страницам</span>
<span><span>func</span> <span>notFoundHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.NotFound(w, r) <span>// Возвращает статус 404</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/notfound"</span>, notFoundHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Обработка POST-запроса</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// postHandler обрабатывает POST-запросы</span>
<span><span>func</span> <span>postHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        fmt.Fprintf(w, <span>"Received a POST request"</span>) <span>// Ответ на POST</span>
    } <span>else</span> {
        http.Error(w, <span>"Only POST method is allowed"</span>, http.StatusMethodNotAllowed) <span>// Ошибка для других методов</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/submit"</span>, postHandler) <span>// Настройка маршрута для "/submit"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Чтение данных из формы</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// formHandler обрабатывает форму и выводит данные</span>
<span><span>func</span> <span>formHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    r.ParseForm() <span>// Парсинг данных формы</span>
    name := r.FormValue(<span>"name"</span>) <span>// Получаем значение поля "name"</span>
    fmt.Fprintf(w, <span>"Form submitted! Hello, %s!"</span>, name) <span>// Форматируем ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/form"</span>, formHandler) <span>// Настройка маршрута для "/form"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Отправка JSON-ответа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"encoding/json"</span>
)

<span>// jsonHandler отправляет JSON-ответ</span>
<span><span>func</span> <span>jsonHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    data := <span>map</span>[<span>string</span>]<span>string</span>{<span>"message"</span>: <span>"Hello, World!"</span>} <span>// Данные для ответа</span>
    w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>) <span>// Установка заголовка Content-Type</span>
    json.NewEncoder(w).Encode(data) <span>// Кодирование данных в JSON</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/json"</span>, jsonHandler) <span>// Настройка маршрута для "/json"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Передача данных через URL-параметры</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// paramHandler обрабатывает параметры из URL</span>
<span><span>func</span> <span>paramHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    params := r.URL.Path[<span>len</span>(<span>"/params/"</span>):] <span>// Получаем часть URL после "/params/"</span>
    fmt.Fprintf(w, <span>"Params: %s"</span>, params) <span>// Форматируем ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/params/"</span>, paramHandler) <span>// Настройка маршрута для "/params/"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Перенаправление</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// redirectHandler перенаправляет запросы на корневой URL</span>
<span><span>func</span> <span>redirectHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.Redirect(w, r, <span>"/"</span>, http.StatusSeeOther) <span>// Перенаправление на "/"</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/redirect"</span>, redirectHandler) <span>// Настройка маршрута для "/redirect"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Установка заголовков ответа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// headerHandler устанавливает пользовательский заголовок</span>
<span><span>func</span> <span>headerHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    w.Header().Set(<span>"X-Custom-Header"</span>, <span>"MyValue"</span>) <span>// Установка заголовка</span>
    fmt.Fprintf(w, <span>"Header set!"</span>) <span>// Ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/header"</span>, headerHandler) <span>// Настройка маршрута для "/header"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Использование middleware для логирования</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// loggingMiddleware оборачивает обработчик для логирования</span>
<span><span>func</span> <span>loggingMiddleware</span><span>(next http.HandlerFunc)</span></span> http.HandlerFunc {
    <span>return</span> <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        fmt.Printf(<span>"Request received: %s\n"</span>, r.URL.Path) <span>// Логирование запроса</span>
        next(w, r) <span>// Вызов следующего обработчика</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/"</span>, loggingMiddleware(helloHandler)) <span>// Обертывание в middleware</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Отправка файла</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// fileHandler отправляет файл клиенту</span>
<span><span>func</span> <span>fileHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.ServeFile(w, r, <span>"file.txt"</span>) <span>// Отправка файла "file.txt"</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/file"</span>, fileHandler) <span>// Настройка маршрута для "/file"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Установка таймаута</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>timeoutHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>// Имитация длительной обработки</span>
    time.Sleep(<span>5</span> * time.Second)
    fmt.Fprintf(w, <span>"This will take a while..."</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    srv := &amp;http.Server{
        Addr:         <span>":8080"</span>,
        ReadTimeout:  <span>5</span> * time.Second,
        WriteTimeout: <span>10</span> * time.Second,
    }

    http.HandleFunc(<span>"/timeout"</span>, timeoutHandler) <span>// Настройка маршрута для "/timeout"</span>
    srv.ListenAndServe()
}
</code></div></div></pre></li><li><p><strong>Работа с cookies</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// cookieHandler устанавливает cookie</span>
<span><span>func</span> <span>cookieHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    cookie := &amp;http.Cookie{
        Name:  <span>"session_id"</span>,
        Value: <span>"123456"</span>,
    }
    http.SetCookie(w, cookie) <span>// Установка cookie</span>
    fmt.Fprintf(w, <span>"Cookie set!"</span>) <span>// Ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/cookie"</span>, cookieHandler) <span>// Настройка маршрута для "/cookie"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Кэширование ответов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// cacheHandler устанавливает заголовок кэширования</span>
<span><span>func</span> <span>cacheHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    w.Header().Set(<span>"Cache-Control"</span>, <span>"public, max-age=3600"</span>) <span>// Установка заголовка кэширования</span>
    fmt.Fprintf(w, <span>"Response cached for 1 hour!"</span>) <span>// Ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/cache"</span>, cacheHandler) <span>// Настройка маршрута для "/cache"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Обработка ошибок с помощью http.Error</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// errorHandler обрабатывает ошибки</span>
<span><span>func</span> <span>errorHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.Error(w, <span>"This is an error!"</span>, http.StatusInternalServerError) <span>// Отправка ошибки 500</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/error"</span>, errorHandler) <span>// Настройка маршрута для "/error"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Создание RESTful API</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// apiHandler обрабатывает REST API запросы</span>
<span><span>func</span> <span>apiHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>switch</span> r.Method {
    <span>case</span> http.MethodGet:
        <span>// Обработка GET запроса</span>
        fmt.Fprintf(w, <span>"GET request received"</span>)
    <span>case</span> http.MethodPost:
        <span>// Обработка POST запроса</span>
        fmt.Fprintf(w, <span>"POST request received"</span>)
    <span>default</span>:
        http.Error(w, <span>"Method not allowed"</span>, http.StatusMethodNotAllowed)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/api"</span>, apiHandler) <span>// Настройка маршрута для "/api"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание простой системы аутентификации</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// authHandler обрабатывает аутентификацию</span>
<span><span>func</span> <span>authHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    username := r.URL.Query().Get(<span>"username"</span>)
    password := r.URL.Query().Get(<span>"password"</span>)
    <span>if</span> username == <span>"user"</span> &amp;&amp; password == <span>"pass"</span> {
        fmt.Fprintf(w, <span>"Authenticated!"</span>) <span>// Успешная аутентификация</span>
    } <span>else</span> {
        http.Error(w, <span>"Unauthorized"</span>, http.StatusUnauthorized) <span>// Ошибка аутентификации</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/auth"</span>, authHandler) <span>// Настройка маршрута для "/auth"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Логирование всех входящих запросов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// loggingHandler логирует запросы</span>
<span><span>func</span> <span>loggingHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Printf(<span>"Request: %s %s\n"</span>, r.Method, r.URL.Path) <span>// Логирование метода и пути</span>
    fmt.Fprintf(w, <span>"Logged request: %s"</span>, r.URL.Path) <span>// Ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/"</span>, loggingHandler) <span>// Настройка маршрута для "/"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Обработка загружаемых файлов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// uploadHandler обрабатывает загрузку файлов</span>
<span><span>func</span> <span>uploadHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        file, _, err := r.FormFile(<span>"file"</span>) <span>// Получение файла из формы</span>
        <span>if</span> err != <span>nil</span> {
            http.Error(w, <span>"Error uploading file"</span>, http.StatusBadRequest)
            <span>return</span>
        }
        <span>defer</span> file.Close() <span>// Закрываем файл</span>
        fmt.Fprintf(w, <span>"File uploaded successfully!"</span>) <span>// Успешная загрузка</span>
    } <span>else</span> {
        http.Error(w, <span>"Only POST method is allowed"</span>, http.StatusMethodNotAllowed)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/upload"</span>, uploadHandler) <span>// Настройка маршрута для "/upload"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание веб-сервиса для работы с данными</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// dataHandler обрабатывает запросы к данным</span>
<span><span>func</span> <span>dataHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    data := <span>map</span>[<span>string</span>]<span>string</span>{<span>"name"</span>: <span>"John Doe"</span>, <span>"age"</span>: <span>"30"</span>} <span>// Пример данных</span>
    w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
    json.NewEncoder(w).Encode(data) <span>// Отправка данных в формате JSON</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.HandleFunc(<span>"/data"</span>, dataHandler) <span>// Настройка маршрута для "/data"</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ol><h3>2. </h3><h1 id="heading-51" class="numbered" data-id="51" style="--bg-color: blue;">
ФУНКЦИЯ HANDLE</h1><code></code><h4>Базовые задачи</h4><ol><li><p><strong>Создание простого обработчика с <code>Handle</code></strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// helloHandler обрабатывает запросы</span>
<span><span>func</span> <span>helloHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Hello, World!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/hello"</span>, http.HandlerFunc(helloHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>) <span>// Запуск сервера</span>
}
</code></div></div></pre></li><li><p><strong>Обработка различных маршрутов с <code>Handle</code></strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>greetHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Greetings!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/greet"</span>, http.HandlerFunc(greetHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Статус код ответа с <code>Handle</code></strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>statusHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    w.WriteHeader(http.StatusAccepted) <span>// Установка статуса 202</span>
    fmt.Fprintf(w, <span>"Request accepted!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/status"</span>, http.HandlerFunc(statusHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Обработка файлов с <code>Handle</code></strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>fileHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.ServeFile(w, r, <span>"file.txt"</span>) <span>// Отправка файла клиенту</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/file"</span>, http.HandlerFunc(fileHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Использование обработчика для конкретного метода</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>methodHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodGet {
        fmt.Fprintf(w, <span>"GET method!"</span>)
    } <span>else</span> {
        http.Error(w, <span>"Only GET method is allowed"</span>, http.StatusMethodNotAllowed)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/method"</span>, http.HandlerFunc(methodHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Передача структуры в обработчик</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>type</span> MyHandler <span>struct</span>{}

<span><span>func</span> <span>(h *MyHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, <span>"Hello from MyHandler!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    handler := &amp;MyHandler{}
    http.Handle(<span>"/myhandler"</span>, handler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Генерация случайных данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"math/rand"</span>
    <span>"strconv"</span>
)

<span><span>func</span> <span>randomNumberHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    num := rand.Intn(<span>100</span>) <span>// Генерация случайного числа</span>
    fmt.Fprintf(w, <span>"Random number: %d"</span>, num) <span>// Отправка числа</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/random"</span>, http.HandlerFunc(randomNumberHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Форматированный вывод на веб-странице</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>formatHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"&lt;h1&gt;Welcome to the formatted page!&lt;/h1&gt;"</span>) <span>// Форматированный HTML</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/format"</span>, http.HandlerFunc(formatHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Работа с query параметрами</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>queryParamHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    param := r.URL.Query().Get(<span>"param"</span>) <span>// Получение параметра "param"</span>
    fmt.Fprintf(w, <span>"Query param: %s"</span>, param) <span>// Ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/query"</span>, http.HandlerFunc(queryParamHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание обработчика для различных форматов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>contentHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Header.Get(<span>"Accept"</span>) == <span>"application/json"</span> {
        w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
        fmt.Fprintf(w, <span>`{"message": "Hello, JSON!"}`</span>)
    } <span>else</span> {
        w.Header().Set(<span>"Content-Type"</span>, <span>"text/plain"</span>)
        fmt.Fprintf(w, <span>"Hello, Plain Text!"</span>)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/content"</span>, http.HandlerFunc(contentHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание сессии</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>sessionHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>// Пример сессии (требует дополнительной настройки)</span>
    fmt.Fprintf(w, <span>"Session started!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/session"</span>, http.HandlerFunc(sessionHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Сравнение двух значений</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>compareHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    val1 := r.URL.Query().Get(<span>"val1"</span>)
    val2 := r.URL.Query().Get(<span>"val2"</span>)
    <span>if</span> val1 == val2 {
        fmt.Fprintf(w, <span>"Values are equal!"</span>)
    } <span>else</span> {
        fmt.Fprintf(w, <span>"Values are different!"</span>)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/compare"</span>, http.HandlerFunc(compareHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Изменение заголовка ответа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>headerChangeHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    w.Header().Set(<span>"X-Custom-Header"</span>, <span>"MyValue"</span>) <span>// Изменение заголовка</span>
    fmt.Fprintf(w, <span>"Header changed!"</span>) <span>// Ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/headerchange"</span>, http.HandlerFunc(headerChangeHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Взаимодействие с БД (например, SQLite)</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// Для примера с базой данных потребуется установка пакета SQLite</span>
<span>import</span> (
    <span>"database/sql"</span>
    _ <span>"github.com/mattn/go-sqlite3"</span>
)

<span><span>func</span> <span>dbHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    db, _ := sql.Open(<span>"sqlite3"</span>, <span>"test.db"</span>) <span>// Открытие базы данных</span>
    <span>defer</span> db.Close()
    <span>// Взаимодействие с базой данных...</span>
    fmt.Fprintf(w, <span>"Database interaction completed!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/db"</span>, http.HandlerFunc(dbHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание простого API для получения данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>apiDataHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    data := <span>map</span>[<span>string</span>]<span>string</span>{<span>"item"</span>: <span>"value"</span>} <span>// Пример данных</span>
    w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
    json.NewEncoder(w).Encode(data) <span>// Отправка данных в формате JSON</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/api/data"</span>, http.HandlerFunc(apiDataHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ol><h4>Сложные задачи</h4><ol><li><p><strong>Создание API с обработкой разных форматов данных (JSON, XML)</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"encoding/json"</span>
    <span>"encoding/xml"</span>
)

<span>type</span> Response <span>struct</span> {
    Message <span>string</span> <span>`json:"message" xml:"message"`</span>
}

<span><span>func</span> <span>multiFormatHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    response := Response{Message: <span>"Hello, World!"</span>}
    <span>if</span> r.Header.Get(<span>"Accept"</span>) == <span>"application/json"</span> {
        w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
        json.NewEncoder(w).Encode(response) <span>// JSON</span>
    } <span>else</span> {
        w.Header().Set(<span>"Content-Type"</span>, <span>"application/xml"</span>)
        xml.NewEncoder(w).Encode(response) <span>// XML</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/multi-format"</span>, http.HandlerFunc(multiFormatHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание системы аутентификации с JWT</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>// Для использования JWT потребуется установка пакета</span>
<span>import</span> (
    <span>"github.com/dgrijalva/jwt-go"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>jwtAuthHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
        <span>"authorized"</span>: <span>true</span>,
        <span>"exp"</span>:        time.Now().Add(time.Hour * <span>1</span>).Unix(),
    })
    tokenString, _ := token.SignedString([]<span>byte</span>(<span>"secret"</span>)) <span>// Подпись токена</span>
    fmt.Fprintf(w, <span>"JWT: %s"</span>, tokenString) <span>// Ответ с токеном</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/auth/jwt"</span>, http.HandlerFunc(jwtAuthHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание обработчика для работы с WebSocket</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"github.com/gorilla/websocket"</span>
)

<span>var</span> upgrader = websocket.Upgrader{}

<span><span>func</span> <span>wsHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    conn, err := upgrader.Upgrade(w, r, <span>nil</span>) <span>// Обновление соединения</span>
    <span>if</span> err != <span>nil</span> {
        <span>return</span>
    }
    <span>defer</span> conn.Close()
    <span>// Взаимодействие с WebSocket...</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/ws"</span>, http.HandlerFunc(wsHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание обработчика с использованием goroutine для асинхронной обработки</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>asyncHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>go</span> <span><span>func</span><span>()</span></span> {
        <span>// Длительная задача</span>
        time.Sleep(<span>5</span> * time.Second)
        fmt.Println(<span>"Async task completed!"</span>)
    }()
    fmt.Fprintf(w, <span>"Async task started!"</span>) <span>// Ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/async"</span>, http.HandlerFunc(asyncHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание простого REST API для CRUD операций</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>var</span> items = <span>make</span>(<span>map</span>[<span>string</span>]<span>string</span>)

<span><span>func</span> <span>crudHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>switch</span> r.Method {
    <span>case</span> http.MethodGet:
        <span>// Получение элемента</span>
        fmt.Fprintf(w, <span>"Items: %v"</span>, items)
    <span>case</span> http.MethodPost:
        <span>// Создание элемента</span>
        key := r.URL.Query().Get(<span>"key"</span>)
        value := r.URL.Query().Get(<span>"value"</span>)
        items[key] = value
        fmt.Fprintf(w, <span>"Item created: %s = %s"</span>, key, value)
    <span>case</span> http.MethodDelete:
        <span>// Удаление элемента</span>
        key := r.URL.Query().Get(<span>"key"</span>)
        <span>delete</span>(items, key)
        fmt.Fprintf(w, <span>"Item deleted: %s"</span>, key)
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    http.Handle(<span>"/crud"</span>, http.HandlerFunc(crudHandler)) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p> <code></code></p><h1 id="heading-52" class="numbered" data-id="52" style="--bg-color: green;">GORILLA/MUX,</h1> <p></p><h3>Базовые задания (15)</h3><ol><li><p><strong>Простой маршрутизатор</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"github.com/gorilla/mux"</span>
)

<span><span>func</span> <span>homeHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Welcome to the home page!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/"</span>, homeHandler) <span>// Настройка маршрута для главной страницы</span>
    http.ListenAndServe(<span>":8080"</span>, r) <span>// Запуск сервера</span>
}
</code></div></div></pre></li><li><p><strong>Маршрут с переменной</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>userHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    vars := mux.Vars(r) <span>// Получение переменных из маршрута</span>
    user := vars[<span>"user"</span>]
    fmt.Fprintf(w, <span>"Hello, %s!"</span>, user) <span>// Ответ с именем пользователя</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/user/{user}"</span>, userHandler) <span>// Настройка маршрута с переменной</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Маршрут с регулярным выражением</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>postHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    vars := mux.Vars(r)
    postID := vars[<span>"id"</span>]
    fmt.Fprintf(w, <span>"Post ID: %s"</span>, postID) <span>// Ответ с идентификатором поста</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/post/{id:[0-9]+}"</span>, postHandler) <span>// Идентификатор поста - только цифры</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Методы HTTP</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>methodHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Method: %s"</span>, r.Method) <span>// Ответ с методом запроса</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/method"</span>, methodHandler).Methods(<span>"GET"</span>, <span>"POST"</span>) <span>// Поддержка GET и POST</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Группировка маршрутов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>adminHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Welcome to the admin panel!"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    adminRouter := r.PathPrefix(<span>"/admin"</span>).Subrouter() <span>// Подмаршрут для администраторов</span>
    adminRouter.HandleFunc(<span>"/"</span>, adminHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Добавление промежуточного ПО</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>loggingMiddleware</span><span>(next http.Handler)</span></span> http.Handler {
    <span>return</span> http.HandlerFunc(<span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        fmt.Printf(<span>"Request: %s %s\n"</span>, r.Method, r.URL.Path) <span>// Логирование запроса</span>
        next.ServeHTTP(w, r) <span>// Вызов следующего обработчика</span>
    })
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.Use(loggingMiddleware) <span>// Применение промежуточного ПО</span>
    r.HandleFunc(<span>"/"</span>, homeHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Использование query параметров</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>queryParamHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    name := r.URL.Query().Get(<span>"name"</span>) <span>// Получение параметра запроса</span>
    fmt.Fprintf(w, <span>"Hello, %s!"</span>, name) <span>// Ответ с именем</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/greet"</span>, queryParamHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Статус код ответа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>notFoundHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.NotFound(w, r) <span>// Ответ с 404 ошибкой</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.NotFoundHandler = http.HandlerFunc(notFoundHandler) <span>// Обработчик для 404</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Обработка статических файлов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.PathPrefix(<span>"/static/"</span>).Handler(http.StripPrefix(<span>"/static/"</span>, http.FileServer(http.Dir(<span>"./static/"</span>)))) <span>// Отправка статических файлов</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Поддержка CORS</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>corsMiddleware</span><span>(next http.Handler)</span></span> http.Handler {
    <span>return</span> http.HandlerFunc(<span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        w.Header().Set(<span>"Access-Control-Allow-Origin"</span>, <span>"*"</span>) <span>// Разрешение CORS</span>
        next.ServeHTTP(w, r)
    })
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.Use(corsMiddleware) <span>// Применение CORS промежуточного ПО</span>
    r.HandleFunc(<span>"/"</span>, homeHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Настройка заголовков ответа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>headerHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    w.Header().Set(<span>"X-Custom-Header"</span>, <span>"MyValue"</span>) <span>// Установка пользовательского заголовка</span>
    fmt.Fprintf(w, <span>"Header set!"</span>) <span>// Ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/header"</span>, headerHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Работа с JSON</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> <span>"encoding/json"</span>

<span>type</span> Response <span>struct</span> {
    Message <span>string</span> <span>`json:"message"`</span>
}

<span><span>func</span> <span>jsonHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    response := Response{Message: <span>"Hello, JSON!"</span>}
    w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
    json.NewEncoder(w).Encode(response) <span>// Отправка JSON ответа</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/json"</span>, jsonHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Работа с HTML шаблонами</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"html/template"</span>
)

<span><span>func</span> <span>templateHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    t, _ := template.ParseFiles(<span>"template.html"</span>) <span>// Парсинг HTML шаблона</span>
    t.Execute(w, <span>nil</span>) <span>// Выполнение шаблона</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/template"</span>, templateHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Изменение маршрутов в зависимости от условия</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>conditionHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodGet {
        fmt.Fprintf(w, <span>"This is a GET request"</span>)
    } <span>else</span> {
        http.Error(w, <span>"Method not allowed"</span>, http.StatusMethodNotAllowed) <span>// Ошибка для других методов</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/condition"</span>, conditionHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Создание API с различными версиями</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>v1Handler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"API v1"</span>)
}

<span><span>func</span> <span>v2Handler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"API v2"</span>)
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/api/v1"</span>, v1Handler) <span>// Настройка маршрута для v1</span>
    r.HandleFunc(<span>"/api/v2"</span>, v2Handler) <span>// Настройка маршрута для v2</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li></ol><h3>Сложные задания (5)</h3><ol><li><p><strong>Создание REST API для управления пользователями</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>type</span> User <span>struct</span> {
    ID   <span>string</span> <span>`json:"id"`</span>
    Name <span>string</span> <span>`json:"name"`</span>
}

<span>var</span> users = <span>make</span>(<span>map</span>[<span>string</span>]User)

<span><span>func</span> <span>userAPIHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>switch</span> r.Method {
    <span>case</span> http.MethodGet:
        id := mux.Vars(r)[<span>"id"</span>]
        user, exists := users[id]
        <span>if</span> !exists {
            http.NotFound(w, r)
            <span>return</span>
        }
        json.NewEncoder(w).Encode(user) <span>// Ответ с пользователем в формате JSON</span>
    <span>case</span> http.MethodPost:
        <span>var</span> user User
        json.NewDecoder(r.Body).Decode(&amp;user)
        users[user.ID] = user
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user) <span>// Ответ с созданным пользователем</span>
    <span>case</span> http.MethodDelete:
        id := mux.Vars(r)[<span>"id"</span>]
        <span>delete</span>(users, id) <span>// Удаление пользователя</span>
        w.WriteHeader(http.StatusNoContent) <span>// Ответ без содержимого</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/users/{id}"</span>, userAPIHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Создание API для работы с товарами</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>type</span> Product <span>struct</span> {
    ID    <span>string</span>  <span>`json:"id"`</span>
    Name  <span>string</span>  <span>`json:"name"`</span>
    Price <span>float64</span> <span>`json:"price"`</span>
}

<span>var</span> products = <span>make</span>(<span>map</span>[<span>string</span>]Product)

<span><span>func</span> <span>productAPIHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>switch</span> r.Method {
    <span>case</span> http.MethodGet:
        id := mux.Vars(r)[<span>"id"</span>]
        product, exists := products[id]
        <span>if</span> !exists {
            http.NotFound(w, r)
            <span>return</span>
        }
        json.NewEncoder(w).Encode(product) <span>// Ответ с товаром</span>
    <span>case</span> http.MethodPost:
        <span>var</span> product Product
        json.NewDecoder(r.Body).Decode(&amp;product)
        products[product.ID] = product
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(product) <span>// Ответ с созданным товаром</span>
    <span>case</span> http.MethodDelete:
        id := mux.Vars(r)[<span>"id"</span>]
        <span>delete</span>(products, id) <span>// Удаление товара</span>
        w.WriteHeader(http.StatusNoContent) <span>// Ответ без содержимого</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/products/{id}"</span>, productAPIHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Создание API для аутентификации</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>var</span> users = <span>map</span>[<span>string</span>]<span>string</span>{<span>"user"</span>: <span>"password"</span>} <span>// Простой "пользователь"</span>

<span><span>func</span> <span>authHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    r.ParseForm()
    username := r.FormValue(<span>"username"</span>)
    password := r.FormValue(<span>"password"</span>)

    <span>if</span> storedPassword, ok := users[username]; ok &amp;&amp; storedPassword == password {
        fmt.Fprintf(w, <span>"Authenticated!"</span>) <span>// Успешная аутентификация</span>
    } <span>else</span> {
        http.Error(w, <span>"Unauthorized"</span>, http.StatusUnauthorized) <span>// Ошибка аутентификации</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/auth"</span>, authHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Создание веб-приложения с сессиями</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"github.com/gorilla/sessions"</span>
)

<span>var</span> store = sessions.NewCookieStore([]<span>byte</span>(<span>"secret-key"</span>))

<span><span>func</span> <span>sessionHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    session, _ := store.Get(r, <span>"session"</span>)
    session.Values[<span>"foo"</span>] = <span>"bar"</span> <span>// Запись в сессию</span>
    session.Save(r, w) <span>// Сохранение сессии</span>
    fmt.Fprintf(w, <span>"Session set!"</span>) <span>// Ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/session"</span>, sessionHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Создание веб-приложения с WebSocket</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"github.com/gorilla/websocket"</span>
)

<span>var</span> upgrader = websocket.Upgrader{}

<span><span>func</span> <span>wsHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    conn, err := upgrader.Upgrade(w, r, <span>nil</span>) <span>// Обновление соединения</span>
    <span>if</span> err != <span>nil</span> {
        http.Error(w, <span>"Could not upgrade connection"</span>, http.StatusInternalServerError)
        <span>return</span>
    }
    <span>defer</span> conn.Close()
    <span>for</span> {
        _, msg, err := conn.ReadMessage()
        <span>if</span> err != <span>nil</span> {
            <span>break</span>
        }
        conn.WriteMessage(websocket.TextMessage, msg) <span>// Эхо-сообщение</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/ws"</span>, wsHandler) <span>// Настройка маршрута для WebSocket</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><div>
 <h1 id="heading-53" class="numbered" data-id="53" style="--bg-color: orange;">
ОТПРАВКА ФОРМ
</h1>
 </div></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div dir="auto"><div><div><p></p><h3>Базовые задания (15)</h3><ol><li><p><strong>Простой обработчик строки запроса</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"fmt"</span>
    <span>"net/http"</span>
    <span>"github.com/gorilla/mux"</span>
)

<span><span>func</span> <span>queryHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    name := r.URL.Query().Get(<span>"name"</span>) <span>// Получение параметра строки запроса</span>
    <span>if</span> name == <span>""</span> {
        name = <span>"Guest"</span>
    }
    fmt.Fprintf(w, <span>"Hello, %s!"</span>, name) <span>// Ответ с именем</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/greet"</span>, queryHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Обработка нескольких параметров строки запроса</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>multiQueryHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    firstName := r.URL.Query().Get(<span>"first"</span>)
    lastName := r.URL.Query().Get(<span>"last"</span>)
    fmt.Fprintf(w, <span>"Hello, %s %s!"</span>, firstName, lastName) <span>// Ответ с полным именем</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/greet"</span>, multiQueryHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Отправка формы с методом POST</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>formHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        r.ParseForm() <span>// Парсинг данных формы</span>
        name := r.FormValue(<span>"name"</span>)
        fmt.Fprintf(w, <span>"Received name: %s"</span>, name) <span>// Ответ с именем</span>
    } <span>else</span> {
        http.ServeFile(w, r, <span>"form.html"</span>) <span>// Отправка HTML формы</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/form"</span>, formHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre><p><em>HTML файл (form.html)</em></p><pre><div><div>html</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>&lt;<span>form</span> <span>method</span>=<span>"post"</span> <span>action</span>=<span>"/form"</span>&gt;</span>
    Name: <span>&lt;<span>input</span> <span>type</span>=<span>"text"</span> <span>name</span>=<span>"name"</span>&gt;</span>
    <span>&lt;<span>input</span> <span>type</span>=<span>"submit"</span> <span>value</span>=<span>"Submit"</span>&gt;</span>
<span>&lt;/<span>form</span>&gt;</span>
</code></div></div></pre></li><li><p><strong>Валидация данных формы</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>validatedFormHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        r.ParseForm()
        name := r.FormValue(<span>"name"</span>)
        <span>if</span> name == <span>""</span> {
            http.Error(w, <span>"Name is required"</span>, http.StatusBadRequest) <span>// Ошибка валидации</span>
            <span>return</span>
        }
        fmt.Fprintf(w, <span>"Hello, %s!"</span>, name) <span>// Ответ с именем</span>
    } <span>else</span> {
        http.ServeFile(w, r, <span>"form.html"</span>) <span>// Отправка HTML формы</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/validated-form"</span>, validatedFormHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Обработка данных формы и редирект</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>redirectFormHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        r.ParseForm()
        name := r.FormValue(<span>"name"</span>)
        http.Redirect(w, r, <span>"/greet?name="</span>+name, http.StatusFound) <span>// Редирект с параметром</span>
        <span>return</span>
    }
    http.ServeFile(w, r, <span>"form.html"</span>) <span>// Отправка HTML формы</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/redirect-form"</span>, redirectFormHandler) <span>// Настройка маршрута</span>
    r.HandleFunc(<span>"/greet"</span>, queryHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Получение параметров строки запроса и ответ в JSON</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>import</span> (
    <span>"encoding/json"</span>
)

<span>type</span> Response <span>struct</span> {
    Message <span>string</span> <span>`json:"message"`</span>
}

<span><span>func</span> <span>jsonQueryHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    name := r.URL.Query().Get(<span>"name"</span>)
    response := Response{Message: <span>"Hello, "</span> + name}
    w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
    json.NewEncoder(w).Encode(response) <span>// Ответ в формате JSON</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/json-greet"</span>, jsonQueryHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Работа с регулярными выражениями в маршрутах</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>regexHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    id := mux.Vars(r)[<span>"id"</span>] <span>// Получение параметра с регулярным выражением</span>
    fmt.Fprintf(w, <span>"Item ID: %s"</span>, id) <span>// Ответ с идентификатором</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/item/{id:[0-9]+}"</span>, regexHandler) <span>// Регулярное выражение для чисел</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Формирование URL с параметрами</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>generateURLHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    url := r.URL.Path + <span>"?name=John"</span> <span>// Формирование URL</span>
    fmt.Fprintf(w, <span>"Generated URL: %s"</span>, url) <span>// Ответ с URL</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/generate-url"</span>, generateURLHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Отправка формы с выбором файла</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>fileUploadHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        file, _, err := r.FormFile(<span>"file"</span>) <span>// Получение файла из формы</span>
        <span>if</span> err != <span>nil</span> {
            http.Error(w, <span>"Error uploading file"</span>, http.StatusBadRequest)
            <span>return</span>
        }
        <span>defer</span> file.Close() <span>// Закрытие файла</span>
        fmt.Fprintf(w, <span>"File uploaded successfully!"</span>) <span>// Ответ</span>
        <span>return</span>
    }
    http.ServeFile(w, r, <span>"upload.html"</span>) <span>// Отправка HTML формы</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/upload"</span>, fileUploadHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre><p><em>HTML файл (upload.html)</em></p><pre><div><div>html</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>&lt;<span>form</span> <span>method</span>=<span>"post"</span> <span>action</span>=<span>"/upload"</span> <span>enctype</span>=<span>"multipart/form-data"</span>&gt;</span>
    Select file: <span>&lt;<span>input</span> <span>type</span>=<span>"file"</span> <span>name</span>=<span>"file"</span>&gt;</span>
    <span>&lt;<span>input</span> <span>type</span>=<span>"submit"</span> <span>value</span>=<span>"Upload"</span>&gt;</span>
<span>&lt;/<span>form</span>&gt;</span>
</code></div></div></pre></li><li><p><strong>Обработка JSON данных из формы</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>jsonFormHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        <span>var</span> data <span>map</span>[<span>string</span>]<span>string</span>
        <span>if</span> err := json.NewDecoder(r.Body).Decode(&amp;data); err != <span>nil</span> {
            http.Error(w, <span>"Invalid JSON"</span>, http.StatusBadRequest) <span>// Ошибка парсинга JSON</span>
            <span>return</span>
        }
        fmt.Fprintf(w, <span>"Received data: %v"</span>, data) <span>// Ответ с данными</span>
    } <span>else</span> {
        http.ServeFile(w, r, <span>"jsonform.html"</span>) <span>// Отправка HTML формы</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/json-form"</span>, jsonFormHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre><p><em>HTML файл (jsonform.html)</em></p><pre><div><div>html</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>&lt;<span>form</span> <span>method</span>=<span>"post"</span> <span>action</span>=<span>"/json-form"</span> <span>onsubmit</span>=<span>"submitForm(event)"</span>&gt;</span>
    Name: <span>&lt;<span>input</span> <span>type</span>=<span>"text"</span> <span>name</span>=<span>"name"</span>&gt;</span>
    <span>&lt;<span>input</span> <span>type</span>=<span>"submit"</span> <span>value</span>=<span>"Submit"</span>&gt;</span>
<span>&lt;/<span>form</span>&gt;</span>
<span>&lt;<span>script</span>&gt;</span><span>
    <span>function</span> <span>submitForm</span>(<span>event</span>) {
        event.<span>preventDefault</span>();
        <span>const</span> formData = <span>new</span> <span>FormData</span>(event.<span>target</span>);
        <span>const</span> data = {};
        formData.<span>forEach</span>(<span>(<span>value, key</span>) =&gt;</span> (data[key] = value));
        <span>fetch</span>(<span>'/json-form'</span>, {
            <span>method</span>: <span>'POST'</span>,
            <span>body</span>: <span>JSON</span>.<span>stringify</span>(data),
            <span>headers</span>: {
                <span>'Content-Type'</span>: <span>'application/json'</span>,
            },
        });
    }
</span><span>&lt;/<span>script</span>&gt;</span>
</code></div></div></pre></li><li><p><strong>Отправка форм с использованием AJAX</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>ajaxHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        r.ParseForm()
        name := r.FormValue(<span>"name"</span>)
        w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
        json.NewEncoder(w).Encode(<span>map</span>[<span>string</span>]<span>string</span>{<span>"message"</span>: <span>"Hello, "</span> + name}) <span>// Ответ в формате JSON</span>
        <span>return</span>
    }
    http.ServeFile(w, r, <span>"ajaxform.html"</span>) <span>// Отправка HTML формы</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/ajax"</span>, ajaxHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre><p><em>HTML файл (ajaxform.html)</em></p><pre><div><div>html</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>&lt;<span>form</span> <span>method</span>=<span>"post"</span> <span>action</span>=<span>"/ajax"</span> <span>onsubmit</span>=<span>"sendData(event)"</span>&gt;</span>
    Name: <span>&lt;<span>input</span> <span>type</span>=<span>"text"</span> <span>name</span>=<span>"name"</span>&gt;</span>
    <span>&lt;<span>input</span> <span>type</span>=<span>"submit"</span> <span>value</span>=<span>"Submit"</span>&gt;</span>
<span>&lt;/<span>form</span>&gt;</span>
<span>&lt;<span>script</span>&gt;</span><span>
    <span>function</span> <span>sendData</span>(<span>event</span>) {
        event.<span>preventDefault</span>();
        <span>const</span> formData = <span>new</span> <span>FormData</span>(event.<span>target</span>);
        <span>fetch</span>(<span>'/ajax'</span>, {
            <span>method</span>: <span>'POST'</span>,
            <span>body</span>: formData,
        })
        .<span>then</span>(<span><span>response</span> =&gt;</span> response.<span>json</span>())
        .<span>then</span>(<span><span>data</span> =&gt;</span> <span>console</span>.<span>log</span>(data));
    }
</span><span>&lt;/<span>script</span>&gt;</span>
</code></div></div></pre></li><li><p><strong>Обработка разных методов в одном маршруте</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>multiMethodHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>switch</span> r.Method {
    <span>case</span> http.MethodGet:
        fmt.Fprintf(w, <span>"GET method"</span>)
    <span>case</span> http.MethodPost:
        fmt.Fprintf(w, <span>"POST method"</span>)
    <span>default</span>:
        http.Error(w, <span>"Method not allowed"</span>, http.StatusMethodNotAllowed) <span>// Ошибка при недопустимом методе</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/multi-method"</span>, multiMethodHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Создание и отправка куки</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>cookieHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.SetCookie(w, &amp;http.Cookie{
        Name:  <span>"username"</span>,
        Value: <span>"JohnDoe"</span>,
        Path:  <span>"/"</span>,
    })
    fmt.Fprintf(w, <span>"Cookie set!"</span>) <span>// Ответ о установке куки</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/set-cookie"</span>, cookieHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Чтение куки</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>readCookieHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    cookie, err := r.Cookie(<span>"username"</span>)
    <span>if</span> err != <span>nil</span> {
        http.Error(w, <span>"Cookie not found"</span>, http.StatusNotFound) <span>// Ошибка при отсутствии куки</span>
        <span>return</span>
    }
    fmt.Fprintf(w, <span>"Hello, %s!"</span>, cookie.Value) <span>// Ответ с именем из куки</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/read-cookie"</span>, readCookieHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Сохранение и удаление куки</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>deleteCookieHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.SetCookie(w, &amp;http.Cookie{
        Name:   <span>"username"</span>,
        Value:  <span>""</span>,
        Path:   <span>"/"</span>,
        MaxAge: <span>-1</span>,
    })
    fmt.Fprintf(w, <span>"Cookie deleted!"</span>) <span>// Ответ об удалении куки</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/delete-cookie"</span>, deleteCookieHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li></ol><h3>Сложные задания (5)</h3><ol><li><p><strong>Создание API для работы с пользователями с отправкой форм</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>type</span> User <span>struct</span> {
    ID   <span>string</span> <span>`json:"id"`</span>
    Name <span>string</span> <span>`json:"name"`</span>
}

<span>var</span> users = <span>make</span>(<span>map</span>[<span>string</span>]User)

<span><span>func</span> <span>userAPIHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>switch</span> r.Method {
    <span>case</span> http.MethodGet:
        id := mux.Vars(r)[<span>"id"</span>]
        user, exists := users[id]
        <span>if</span> !exists {
            http.NotFound(w, r) <span>// Ошибка: пользователь не найден</span>
            <span>return</span>
        }
        json.NewEncoder(w).Encode(user) <span>// Ответ с пользователем</span>
    <span>case</span> http.MethodPost:
        <span>var</span> user User
        json.NewDecoder(r.Body).Decode(&amp;user)
        users[user.ID] = user
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user) <span>// Ответ с созданным пользователем</span>
    <span>case</span> http.MethodDelete:
        id := mux.Vars(r)[<span>"id"</span>]
        <span>delete</span>(users, id) <span>// Удаление пользователя</span>
        w.WriteHeader(http.StatusNoContent) <span>// Ответ без содержимого</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/users/{id}"</span>, userAPIHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Создание API для аутентификации с формой</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>var</span> credentials = <span>map</span>[<span>string</span>]<span>string</span>{<span>"user"</span>: <span>"password"</span>} <span>// Простой "пользователь"</span>

<span><span>func</span> <span>authHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        r.ParseForm()
        username := r.FormValue(<span>"username"</span>)
        password := r.FormValue(<span>"password"</span>)
        <span>if</span> storedPassword, ok := credentials[username]; ok &amp;&amp; storedPassword == password {
            fmt.Fprintf(w, <span>"Authenticated!"</span>) <span>// Успешная аутентификация</span>
        } <span>else</span> {
            http.Error(w, <span>"Unauthorized"</span>, http.StatusUnauthorized) <span>// Ошибка аутентификации</span>
        }
        <span>return</span>
    }
    http.ServeFile(w, r, <span>"auth.html"</span>) <span>// Отправка HTML формы</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/auth"</span>, authHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre><p><em>HTML файл (auth.html)</em></p><pre><div><div>html</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>&lt;<span>form</span> <span>method</span>=<span>"post"</span> <span>action</span>=<span>"/auth"</span>&gt;</span>
    Username: <span>&lt;<span>input</span> <span>type</span>=<span>"text"</span> <span>name</span>=<span>"username"</span>&gt;</span>
    Password: <span>&lt;<span>input</span> <span>type</span>=<span>"password"</span> <span>name</span>=<span>"password"</span>&gt;</span>
    <span>&lt;<span>input</span> <span>type</span>=<span>"submit"</span> <span>value</span>=<span>"Login"</span>&gt;</span>
<span>&lt;/<span>form</span>&gt;</span>
</code></div></div></pre></li><li><p><strong>Создание системы обратной связи с отправкой формы и JSON ответом</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>type</span> Feedback <span>struct</span> {
    Name    <span>string</span> <span>`json:"name"`</span>
    Message <span>string</span> <span>`json:"message"`</span>
}

<span><span>func</span> <span>feedbackHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        <span>var</span> feedback Feedback
        json.NewDecoder(r.Body).Decode(&amp;feedback) <span>// Декодирование JSON</span>
        fmt.Fprintf(w, <span>"Feedback received: %s"</span>, feedback.Message) <span>// Ответ</span>
        <span>return</span>
    }
    http.ServeFile(w, r, <span>"feedback.html"</span>) <span>// Отправка HTML формы</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/feedback"</span>, feedbackHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre><p><em>HTML файл (feedback.html)</em></p><pre><div><div>html</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>&lt;<span>form</span> <span>method</span>=<span>"post"</span> <span>action</span>=<span>"/feedback"</span>&gt;</span>
    Name: <span>&lt;<span>input</span> <span>type</span>=<span>"text"</span> <span>name</span>=<span>"name"</span>&gt;</span>
    Message: <span>&lt;<span>textarea</span> <span>name</span>=<span>"message"</span>&gt;</span><span>&lt;/<span>textarea</span>&gt;</span>
    <span>&lt;<span>input</span> <span>type</span>=<span>"submit"</span> <span>value</span>=<span>"Send"</span>&gt;</span>
<span>&lt;/<span>form</span>&gt;</span>
</code></div></div></pre></li><li><p><strong>Создание системы регистрации пользователей с валидацией</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>registrationHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        r.ParseForm()
        username := r.FormValue(<span>"username"</span>)
        password := r.FormValue(<span>"password"</span>)
        <span>if</span> username == <span>""</span> || password == <span>""</span> {
            http.Error(w, <span>"Username and password are required"</span>, http.StatusBadRequest) <span>// Ошибка валидации</span>
            <span>return</span>
        }
        <span>// Здесь можно добавить логику сохранения пользователя в БД</span>
        fmt.Fprintf(w, <span>"User registered: %s"</span>, username) <span>// Ответ</span>
        <span>return</span>
    }
    http.ServeFile(w, r, <span>"register.html"</span>) <span>// Отправка HTML формы</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/register"</span>, registrationHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre><p><em>HTML файл (register.html)</em></p><pre><div><div>html</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>&lt;<span>form</span> <span>method</span>=<span>"post"</span> <span>action</span>=<span>"/register"</span>&gt;</span>
    Username: <span>&lt;<span>input</span> <span>type</span>=<span>"text"</span> <span>name</span>=<span>"username"</span>&gt;</span>
    Password: <span>&lt;<span>input</span> <span>type</span>=<span>"password"</span> <span>name</span>=<span>"password"</span>&gt;</span>
    <span>&lt;<span>input</span> <span>type</span>=<span>"submit"</span> <span>value</span>=<span>"Register"</span>&gt;</span>
<span>&lt;/<span>form</span>&gt;</span>
</code></div></div></pre></li><li><p><strong>Создание API для работы с продуктами с фильтрацией по строке запроса</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>type</span> Product <span>struct</span> {
    ID    <span>string</span>  <span>`json:"id"`</span>
    Name  <span>string</span>  <span>`json:"name"`</span>
    Price <span>float64</span> <span>`json:"price"`</span>
}

<span>var</span> products = []Product{
    {ID: <span>"1"</span>, Name: <span>"Laptop"</span>, Price: <span>1000</span>},
    {ID: <span>"2"</span>, Name: <span>"Phone"</span>, Price: <span>500</span>},
}

<span><span>func</span> <span>productFilterHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    minPrice := r.URL.Query().Get(<span>"minPrice"</span>)
    <span>var</span> filteredProducts []Product
    <span>for</span> _, product := <span>range</span> products {
        <span>if</span> minPrice == <span>""</span> || product.Price &gt;= <span>500</span> {
            filteredProducts = <span>append</span>(filteredProducts, product) <span>// Фильтрация продуктов</span>
        }
    }
    w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
    json.NewEncoder(w).Encode(filteredProducts) <span>// Ответ в формате JSON</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/products"</span>, productFilterHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li></ol><p></p></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div><div><svg width="41" height="41" viewBox="0 0 41 41" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-md" role="img"><text x="-9999" y="-9999"></text></svg></div></div></div></div></div><div><div><div><div dir="auto"><div><div><h3></h3><h1 id="heading-54" class="numbered" data-id="54" style="--bg-color: purple;">ОПРЕДЕЛЕНИЕ И ИСПОЛЬЗОВАНИЕ ШАБЛОНОВ МАРШРУТОВ В GO С ИСПОЛЬЗОВАНИЕМ GORILLA/MUX</h1><code></code><p>Шаблоны маршрутов позволяют создавать гибкие и мощные API, обрабатывающие различные URL. В Go с использованием <code>gorilla/mux</code> можно использовать шаблоны для создания маршрутов с параметрами.</p><h3>Базовые задания (15)</h3><ol><li><p><strong>Создание простого маршрута</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>homeHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"Welcome to the Home Page!"</span>) <span>// Ответ на запрос</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/"</span>, homeHandler) <span>// Настройка маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Маршрут с параметром</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>greetingHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    name := mux.Vars(r)[<span>"name"</span>] <span>// Получение параметра из URL</span>
    fmt.Fprintf(w, <span>"Hello, %s!"</span>, name) <span>// Ответ с использованием параметра</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/hello/{name}"</span>, greetingHandler) <span>// Шаблон маршрута</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Маршрут с несколькими параметрами</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>profileHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    username := mux.Vars(r)[<span>"username"</span>]
    id := mux.Vars(r)[<span>"id"</span>]
    fmt.Fprintf(w, <span>"Profile of %s with ID %s"</span>, username, id) <span>// Ответ с параметрами</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/user/{username}/id/{id}"</span>, profileHandler) <span>// Множественные параметры</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Маршрут с необязательным параметром</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>optionalParamHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    param := mux.Vars(r)[<span>"param"</span>]
    <span>if</span> param == <span>""</span> {
        fmt.Fprintf(w, <span>"No parameter provided!"</span>) <span>// Ответ при отсутствии параметра</span>
    } <span>else</span> {
        fmt.Fprintf(w, <span>"Parameter: %s"</span>, param) <span>// Ответ с параметром</span>
    }
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/optional/{param:.*}"</span>, optionalParamHandler) <span>// Необязательный параметр</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Маршрут с регулярным выражением</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>regexHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprintf(w, <span>"This route matches a number!"</span>) <span>// Ответ на соответствующий запрос</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/number/{num:[0-9]+}"</span>, regexHandler) <span>// Регулярное выражение для чисел</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Маршрут для статических файлов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>staticFileHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.ServeFile(w, r, <span>"static/index.html"</span>) <span>// Отправка статического HTML файла</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/static/{filename}"</span>, staticFileHandler) <span>// Обработка статических файлов</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Обработка ошибки 404</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>notFoundHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.NotFound(w, r) <span>// Ответ с ошибкой 404</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.NotFoundHandler = http.HandlerFunc(notFoundHandler) <span>// Обработка 404</span>
    r.HandleFunc(<span>"/"</span>, homeHandler)
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Использование middleware для логирования</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>loggingMiddleware</span><span>(next http.Handler)</span></span> http.Handler {
    <span>return</span> http.HandlerFunc(<span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        fmt.Printf(<span>"Request: %s %s\n"</span>, r.Method, r.URL) <span>// Логирование запроса</span>
        next.ServeHTTP(w, r) <span>// Передача управления следующему обработчику</span>
    })
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.Use(loggingMiddleware) <span>// Применение middleware</span>
    r.HandleFunc(<span>"/"</span>, homeHandler)
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Маршрут с использованием query параметров</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>searchHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    query := r.URL.Query().Get(<span>"q"</span>) <span>// Получение query параметра</span>
    fmt.Fprintf(w, <span>"Search query: %s"</span>, query) <span>// Ответ с параметром</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/search"</span>, searchHandler) <span>// Обработка поиска</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Отправка JSON ответа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>jsonResponseHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>) <span>// Установка заголовка</span>
    json.NewEncoder(w).Encode(<span>map</span>[<span>string</span>]<span>string</span>{<span>"message"</span>: <span>"Hello, World!"</span>}) <span>// JSON ответ</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/json"</span>, jsonResponseHandler) <span>// Обработка JSON ответа</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Форма для отправки данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>formHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    <span>if</span> r.Method == http.MethodPost {
        r.ParseForm()
        name := r.FormValue(<span>"name"</span>) <span>// Получение данных из формы</span>
        fmt.Fprintf(w, <span>"Hello, %s!"</span>, name) <span>// Ответ с данными из формы</span>
        <span>return</span>
    }
    http.ServeFile(w, r, <span>"form.html"</span>) <span>// Отправка HTML формы</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/form"</span>, formHandler) <span>// Обработка формы</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre><p><em>HTML файл (form.html)</em></p><pre><div><div>html</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>&lt;<span>form</span> <span>method</span>=<span>"post"</span> <span>action</span>=<span>"/form"</span>&gt;</span>
    Name: <span>&lt;<span>input</span> <span>type</span>=<span>"text"</span> <span>name</span>=<span>"name"</span>&gt;</span>
    <span>&lt;<span>input</span> <span>type</span>=<span>"submit"</span> <span>value</span>=<span>"Submit"</span>&gt;</span>
<span>&lt;/<span>form</span>&gt;</span>
</code></div></div></pre></li><li><p><strong>Использование шаблонов для HTML</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>type</span> PageVariables <span>struct</span> {
    Title <span>string</span>
}

<span><span>func</span> <span>templateHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    vars := PageVariables{Title: <span>"Welcome to Go Templates!"</span>} <span>// Переменные для шаблона</span>
    t, _ := template.ParseFiles(<span>"template.html"</span>) <span>// Парсинг шаблона</span>
    t.Execute(w, vars) <span>// Заполнение и вывод шаблона</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/template"</span>, templateHandler) <span>// Обработка шаблона</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre><p><em>HTML файл (template.html)</em></p><pre><div><div>html</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>&lt;<span>html</span>&gt;</span>
<span>&lt;<span>head</span>&gt;</span><span>&lt;<span>title</span>&gt;</span>{{.Title}}<span>&lt;/<span>title</span>&gt;</span><span>&lt;/<span>head</span>&gt;</span>
<span>&lt;<span>body</span>&gt;</span>
    <span>&lt;<span>h1</span>&gt;</span>{{.Title}}<span>&lt;/<span>h1</span>&gt;</span>
<span>&lt;/<span>body</span>&gt;</span>
<span>&lt;/<span>html</span>&gt;</span>
</code></div></div></pre></li><li><p><strong>Создание API для получения данных</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>type</span> Item <span>struct</span> {
    ID   <span>int</span>    <span>`json:"id"`</span>
    Name <span>string</span> <span>`json:"name"`</span>
}

<span>var</span> items = []Item{{ID: <span>1</span>, Name: <span>"Item 1"</span>}, {ID: <span>2</span>, Name: <span>"Item 2"</span>}} <span>// Пример данных</span>

<span><span>func</span> <span>itemsHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    w.Header().Set(<span>"Content-Type"</span>, <span>"application/json"</span>)
    json.NewEncoder(w).Encode(items) <span>// Ответ с данными в формате JSON</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/items"</span>, itemsHandler) <span>// Обработка API для получения данных</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Создание редиректа</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>redirectHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
    http.Redirect(w, r, <span>"/new-url"</span>, http.StatusSeeOther) <span>// Редирект на другой маршрут</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.HandleFunc(<span>"/old-url"</span>, redirectHandler) <span>// Обработка редиректа</span>
    r.HandleFunc(<span>"/new-url"</span>, homeHandler) <span>// Новый маршрут</span>
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li><li><p><strong>Настройка CORS</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span><span>func</span> <span>corsMiddleware</span><span>(next http.Handler)</span></span> http.Handler {
    <span>return</span> http.HandlerFunc(<span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        w.Header().Set(<span>"Access-Control-Allow-Origin"</span>, <span>"*"</span>) <span>// Разрешение CORS</span>
        next.ServeHTTP(w, r) <span>// Передача управления следующему обработчику</span>
    })
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    r := mux.NewRouter()
    r.Use(corsMiddleware) <span>// Применение middleware для CORS</span>
    r.HandleFunc(<span>"/"</span>, homeHandler)
    http.ListenAndServe(<span>":8080"</span>, r)
}
</code></div></div></pre></li></ol><h3>Сложные задания (5)</h3><ol><li><p><strong>Создание RESTful API для управления задачами</strong></p><ul><li>Создайте маршруты для создания, получения, обновления и удаления задач.</li><li>Используйте <code>gorilla/mux</code> для определения маршрутов и обработки JSON данных.</li></ul></li><li><p><strong>Авторизация с использованием JWT</strong></p><ul><li>Реализуйте маршруты для регистрации и входа в систему.</li><li>Используйте JWT для защиты определенных маршрутов.</li></ul></li><li><p><strong>Обработка файловых загрузок</strong></p><ul><li>Создайте маршрут для загрузки файлов на сервер.</li><li>Обработайте полученные файлы и сохраните их на сервере.</li></ul></li><li><p><strong>Создание многоуровневой навигации</strong></p><ul><li>Используйте маршруты для создания многоуровневого API, который будет возвращать данные в зависимости от уровня вложенности.</li></ul></li><li><p><strong>Параметры URL и обработка ошибок</strong></p><ul><li>Создайте API, который принимает параметры URL и обрабатывает различные ошибки, возвращая корректные статусы и сообщения.</li></ul></li></ol><h3></h3></div></div></div></div></div></div></div></div></article><article dir="auto"><div><div><div><div><div><div><div><svg width="41" height="41" viewBox="0 0 41 41" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-md" role="img"><text x="-9999" y="-9999"></text></svg></div></div></div></div></div><div><div><div><div dir="auto"><div><div><h3></h3><h1 id="heading-55" class="numbered" data-id="55" style="--bg-color: pink;">СИНТАКСИС ШАБЛОНОВ, ЦИКЛЫ И УСЛОВНЫЕ КОНСТРУКЦИИ В GO</h1><p>В Go шаблоны (templates) позволяют динамически генерировать HTML, а также обрабатывать циклы и условные конструкции в шаблонах. В этом разделе мы рассмотрим 15 базовых и 5 сложных заданий для практики.</p><h3>Синтаксис шаблонов (15 базовых заданий)</h3><ol><li><p><strong>Создание простого шаблона</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"index"</span>).Parse(<span>"&lt;h1&gt;Welcome to Go Templates!&lt;/h1&gt;"</span>))
    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        tmpl.Execute(w, <span>nil</span>) <span>// Генерация HTML с помощью шаблона</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Передача данных в шаблон</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"greeting"</span>).Parse(<span>"&lt;h1&gt;Hello, {{.}}!&lt;/h1&gt;"</span>))
    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        tmpl.Execute(w, <span>"World"</span>) <span>// Передача данных в шаблон</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Использование структур в шаблонах</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span>type</span> Person <span>struct</span> {
    Name <span>string</span>
    Age  <span>int</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"profile"</span>).Parse(<span>"&lt;h1&gt;{{.Name}} is {{.Age}} years old&lt;/h1&gt;"</span>))
    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        person := Person{Name: <span>"Alice"</span>, Age: <span>30</span>}
        tmpl.Execute(w, person) <span>// Использование структур в шаблонах</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Циклы в шаблонах</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"list"</span>).Parse(<span>`
        &lt;ul&gt;
            {{range .}}
                &lt;li&gt;{{.}}&lt;/li&gt;
            {{end}}
        &lt;/ul&gt;
    `</span>))
    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        items := []<span>string</span>{<span>"Item 1"</span>, <span>"Item 2"</span>, <span>"Item 3"</span>}
        tmpl.Execute(w, items) <span>// Цикл по элементам в шаблоне</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Условные конструкции в шаблонах</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"status"</span>).Parse(<span>`
        &lt;h1&gt;Status: {{if .}}Active{{else}}Inactive{{end}}&lt;/h1&gt;
    `</span>))
    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        tmpl.Execute(w, <span>true</span>) <span>// Условная конструкция в шаблоне</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Комбинирование циклов и условий</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"mixed"</span>).Parse(<span>`
        &lt;ul&gt;
            {{range .}}
                {{if .isActive}}
                    &lt;li&gt;{{.Name}} - Active&lt;/li&gt;
                {{else}}
                    &lt;li&gt;{{.Name}} - Inactive&lt;/li&gt;
                {{end}}
            {{end}}
        &lt;/ul&gt;
    `</span>))

    <span>type</span> Item <span>struct</span> {
        Name     <span>string</span>
        isActive <span>bool</span>
    }

    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        items := []Item{{<span>"Item 1"</span>, <span>true</span>}, {<span>"Item 2"</span>, <span>false</span>}}
        tmpl.Execute(w, items) <span>// Комбинирование циклов и условий</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Шаблон с вложенными структурами</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span>type</span> Address <span>struct</span> {
    City  <span>string</span>
    State <span>string</span>
}

<span>type</span> User <span>struct</span> {
    Name    <span>string</span>
    Address Address
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"user"</span>).Parse(<span>`
        &lt;h1&gt;{{.Name}}&lt;/h1&gt;
        &lt;p&gt;{{.Address.City}}, {{.Address.State}}&lt;/p&gt;
    `</span>))

    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        user := User{Name: <span>"John Doe"</span>, Address: Address{City: <span>"New York"</span>, State: <span>"NY"</span>}}
        tmpl.Execute(w, user) <span>// Вложенные структуры в шаблоне</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание простого HTML-файла с использованием шаблона</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.ParseFiles(<span>"index.html"</span>)) <span>// Чтение HTML файла</span>
    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        tmpl.Execute(w, <span>nil</span>) <span>// Генерация HTML с помощью шаблона</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre><p><em>HTML файл (index.html)</em></p><pre><div><div>html</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>&lt;!DOCTYPE <span>html</span>&gt;</span>
<span>&lt;<span>html</span>&gt;</span>
<span>&lt;<span>head</span>&gt;</span>
    <span>&lt;<span>title</span>&gt;</span>My Page<span>&lt;/<span>title</span>&gt;</span>
<span>&lt;/<span>head</span>&gt;</span>
<span>&lt;<span>body</span>&gt;</span>
    <span>&lt;<span>h1</span>&gt;</span>Welcome to My Page!<span>&lt;/<span>h1</span>&gt;</span>
<span>&lt;/<span>body</span>&gt;</span>
<span>&lt;/<span>html</span>&gt;</span>
</code></div></div></pre></li><li><p><strong>Передача массива в шаблон</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"array"</span>).Parse(<span>`
        &lt;h1&gt;Array Items&lt;/h1&gt;
        &lt;ul&gt;
            {{range .}}
                &lt;li&gt;{{.}}&lt;/li&gt;
            {{end}}
        &lt;/ul&gt;
    `</span>))

    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        items := []<span>string</span>{<span>"Apple"</span>, <span>"Banana"</span>, <span>"Cherry"</span>}
        tmpl.Execute(w, items) <span>// Передача массива в шаблон</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Использование функций в шаблонах</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>upperCase</span><span>(s <span>string</span>)</span></span> <span>string</span> {
    <span>return</span> strings.ToUpper(s) <span>// Функция для преобразования в верхний регистр</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"funcs"</span>).Funcs(template.FuncMap{<span>"upper"</span>: upperCase}).Parse(<span>`
        &lt;h1&gt;{{upper .}}&lt;/h1&gt;
    `</span>))

    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        tmpl.Execute(w, <span>"hello world"</span>) <span>// Использование функции в шаблоне</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Работа с числовыми значениями в шаблонах</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"numbers"</span>).Parse(<span>`
        &lt;h1&gt;Numbers&lt;/h1&gt;
        &lt;p&gt;Sum: {{add .a .b}}&lt;/p&gt;
    `</span>))

    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        tmpl.Execute(w, <span>map</span>[<span>string</span>]<span>int</span>{<span>"a"</span>: <span>3</span>, <span>"b"</span>: <span>4</span>}) <span>// Использование чисел в шаблоне</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}

<span><span>func</span> <span>add</span><span>(a, b <span>int</span>)</span></span> <span>int</span> {
    <span>return</span> a + b <span>// Функция для сложения</span>
}
</code></div></div></pre></li><li><p><strong>Работа с датами в шаблонах</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
    <span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"date"</span>).Parse(<span>`
        &lt;h1&gt;Current Date&lt;/h1&gt;
        &lt;p&gt;{{.}}&lt;/p&gt;
    `</span>))

    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        tmpl.Execute(w, time.Now().Format(<span>"2006-01-02"</span>)) <span>// Форматирование даты в шаблоне</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Использование <code>with</code> в шаблонах</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span>type</span> Product <span>struct</span> {
    Name  <span>string</span>
    Price <span>float64</span>
}

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"product"</span>).Parse(<span>`
        &lt;h1&gt;Product&lt;/h1&gt;
        {{with .}}
            &lt;p&gt;Name: {{.Name}}&lt;/p&gt;
            &lt;p&gt;Price: ${{.Price}}&lt;/p&gt;
        {{end}}
    `</span>))

    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        product := Product{Name: <span>"Laptop"</span>, Price: <span>999.99</span>}
        tmpl.Execute(w, product) <span>// Использование with в шаблоне</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Отображение ошибок в шаблонах</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.New(<span>"error"</span>).Parse(<span>`
        &lt;h1&gt;Error&lt;/h1&gt;
        {{if .}}
            &lt;p&gt;{{.}}&lt;/p&gt;
        {{else}}
            &lt;p&gt;No errors!&lt;/p&gt;
        {{end}}
    `</span>))

    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        tmpl.Execute(w, <span>"Page not found"</span>) <span>// Отображение ошибки в шаблоне</span>
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li><li><p><strong>Создание многоуровневых шаблонов</strong></p><pre><div><div>go</div><div></div><div dir="ltr" style="border: 2px dashed black; border-radius: 10px; padding: 10px;"><code><span>package</span> main

<span>import</span> (
    <span>"html/template"</span>
    <span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
    tmpl := template.Must(template.ParseFiles(<span>"header.html"</span>, <span>"footer.html"</span>, <span>"content.html"</span>)) <span>// Многоуровневые шаблоны</span>

    http.HandleFunc(<span>"/"</span>, <span><span>func</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
        tmpl.Execute(w, <span>nil</span>)
    })
    http.ListenAndServe(<span>":8080"</span>, <span>nil</span>)
}
</code></div></div></pre></li></ol><h3></h3><p></p></div></div></div></div><div><div></div></div></div></div></div></div></article></div><script id="scrpr"> 
          
           let elementhd = document.getElementById("scrollPercentage");

// Проверяем, что элемент найден, и удаляем его
        if (elementhd) {
            elementhd.remove();
        }
          
          const scrollPercentage = document.createElement('div');
    scrollPercentage.id = 'scrollPercentage';
    
    // Добавляем стиль к элементу через JavaScript
    Object.assign(scrollPercentage.style, {
        position: 'fixed',
        top: '10px',
        right: '10px',
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        color: 'white',
        padding: '10px',
        borderRadius: '5px',
        fontSize: '18px',
        zIndex: '1000' // Убедитесь, что элемент всегда сверху
    });
 let elementhd22= document.getElementById("scrollPercentage");

// Проверяем, что элемент найден, и удаляем его
        if (elementhd22) {
            elementhd22.remove();
        }
    // Добавляем элемент в body
    document.body.appendChild(scrollPercentage);

    // Обработчик события прокрутки
    document.addEventListener('scroll', () => {
        // Высота документа
        const documentHeight = document.documentElement.scrollHeight;

        // Высота видимой области
        const windowHeight = window.innerHeight;

        // Текущая позиция прокрутки
        const scrollTop = window.scrollY;

        // Рассчитываем процент просмотренной части страницы
        const totalScroll = scrollTop + windowHeight;
        const percentage = Math.round((totalScroll / documentHeight) * 100);

        // Обновляем текст на экране
        scrollPercentage.textContent = percentage + '%';
    });</script><div id="bcon" style="position: fixed; bottom: 20px; right: 150px; z-index: 10000;"><button id="hidebt" class="actionButton"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10" stroke="black" fill="none"></circle><path d="M12 16v.01M12 12c0-1.1.9-2 2-2 1.1 0 2 .9 2 2 0 1.1-.9 2-2 2H10v-.01M10 8h1c.6 0 1-.4 1-1s-.4-1-1-1H9c-.6 0-1 .4-1 1s.4 1 1 1z"></path></svg></button><button id="backButton" class="actionButton"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"></path></svg></button><button class="actionButton" id="actionButton"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10" stroke="black" fill="none"></circle><rect x="8" y="8" width="8" height="8" fill="currentColor"></rect></svg></button></div><script id="scrhide"> 
   document.getElementById("hidebt").addEventListener("click", function() {
    const ltrElements = document.querySelectorAll('[dir="ltr"]');

    ltrElements.forEach((element, index) => {
        // Сохраняем текущее содержимое элемента
        let originalContent;
        if (element.hasAttribute('data-base')) {
            originalContent = element.dataset.base;
        } else {
            originalContent = element.innerHTML;
        }

        // Создаем кнопку для показа скрытого содержимого
        const showButton = document.createElement('button');
        showButton.textContent = 'Показать содержимое';
        showButton.style.cursor = 'pointer';
        showButton.classList.add("btnhid");
        showButton.style.margin = '10px';
        showButton.style.padding = '10px';
        showButton.style.backgroundColor = '#3498db';
        showButton.style.color = 'white';
        showButton.style.border = 'none';
        showButton.style.borderRadius = '5px';

        // Скрываем текущее содержимое и заменяем его кнопкой
        element.dataset.base = originalContent;
        element.innerHTML = ''; // Очищаем элемент
        element.appendChild(showButton); // Добавляем кнопку вместо содержимого
    });

    // Добавляем обработчики для всех кнопок
    const ltrElements2 = document.querySelectorAll('.btnhid');
    ltrElements2.forEach((element) => {
        element.addEventListener('click', function() {
            element.parentNode.innerHTML = element.parentNode.dataset.base; // Восстанавливаем содержимое
        });
    });
});

</script><script id="sbit"> document.getElementById("backButton").addEventListener("click", function() {
            // Возвращаем пользователя на главную страницу
            // Замените 'index.html' на нужный URL вашей главной страницы
            window.location.href = '#toc'; 
        });

        let isDarkMode = false;

        // Назначаем обработчик события на кнопку переключения цветов
        document.getElementById("actionButton").addEventListener("click", function() {
            // Переключаем цветовую схему
            if (isDarkMode) {
                document.body.style.backgroundColor = "white"; // Белый фон
                document.body.style.color = "black"; // Черный текст
             //   document.querySelector('.code-container').style.backgroundColor = "white"; // Белый фон для кода
             //   document.querySelector('.code-container').style.color = "black"; // Черный текст для кода
                isDarkMode = false; // Устанавливаем флаг на светлую тему
                       const divs = document.querySelectorAll('div[dir="ltr"]');

divs.forEach(function(div) {
    div.style.backgroundColor = "white"; // Устанавливаем фоновый цвет в черный
});   
            } else {
                document.body.style.backgroundColor = "black"; // Черный фон
                document.body.style.color = "white"; // Белый текст
               // document.querySelector('.code-container').style.backgroundColor = "black"; // Черный фон для кода

             //   document.querySelector('.code-container').style.color = "white"; // Белый текст для кода
              const divs = document.querySelectorAll('div[dir="ltr"]');

divs.forEach(function(div) {
    div.style.backgroundColor = "black"; // Устанавливаем фоновый цвет в черный
});
                isDarkMode = true; // Устанавливаем флаг на темную тему
            }
        });</script><style id="stid">.copy-button {
                    position: absolute; /* Позиционирование кнопки */
                    top: 5px; /* Расстояние от верхнего края */
                    right: 5px; /* Расстояние от правого края */
                    padding: 3px 5px;
                    font-size: 12px;
                    cursor: pointer;
                    border: 1px solid #3498db;
                    background-color: #3498db;
                    color: white;
                    border-radius: 4px;
                    transition: background-color 0.3s ease;
                }

                /* Эффект наведения для кнопки */
                .copy-button:hover {
                    background-color: #2980b9;
                }

                /* Убедитесь, что элементы с dir="ltr" имеют относительное позиционирование */
                [dir="ltr"] {
                    position: relative; /* Устанавливаем позиционирование для контейнера */
                    padding: 10px; /* Отступ для элемента */
                    border: 1px solid #ccc; /* Обводка контейнера */
                    margin: 10px 0; /* Отступ между элементами */
                }
             </style><script id="scrcpu"> document.addEventListener('DOMContentLoaded', () => {
            // Функция для копирования текста в буфер обмена
            function copyToClipboard(text) {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert('Содержимое скопировано в буфер обмена!');
            }

            // Создание и добавление стилей для кнопки
              allElements = document.querySelectorAll('.copy-button');

        allElements.forEach(element => {
            element.remove();
            });
            // Поиск всех элементов с атрибутом dir="ltr"
            const ltrElements = document.querySelectorAll('[dir="ltr"]');

            ltrElements.forEach(element => {
                // Создание кнопки "Копировать"
                const copyButton = document.createElement('button');
                copyButton.innerText = 'Копировать';
                copyButton.className = 'copy-button'; // Добавляем класс для стилей

                // Обработчик клика для кнопки
                copyButton.addEventListener('click', () => {
                    copyToClipboard(element.innerText);
                });

                // Добавление кнопки к элементу
                element.appendChild(copyButton);
            });
        }); </script></body></html>